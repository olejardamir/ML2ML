FILE: START-HERE.md
===================
# UML_OS Start Here (Core Profile)
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Onboarding.StartHereCore_v1`  
**Purpose (1 sentence):** Provide the minimum deterministic onboarding path for first successful Core profile execution.  
**Spec Version:** `UML_OS.Onboarding.StartHereCore_v1` | 2026-02-21 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Onboarding.StartHereCore_v1`
- **Purpose (1 sentence):** Deterministic onboarding contract for Core profile first run.
- **Spec Version:** `UML_OS.Onboarding.StartHereCore_v1` | 2026-02-21 | Authors: Olejar Damir
- **Domain / Problem Class:** onboarding and first-run determinism verification.

### 0.A Objective Semantics
- Ensure a new user can deterministically produce core evidence identities on first successful run.

---
## 2) Scope (Normative)
- This document defines the minimal file set and expected deterministic identities for first-run Core profile validation.
- Core profile target: single-node, one backend adapter, one artifact store adapter, default trace policy.

---
## 3) Required File Set (Normative)
- `docs/layer4-implementation/Reference-Stack-Minimal.md`
- `docs/layer4-implementation/Hello-World-End-to-End-Example.md`
- `docs/layer2-specs/UML_OS-Kernel-v3.22-OS.md`
- `docs/layer2-specs/Run-Commit-WAL.md`
- `docs/layer2-specs/Trace-Sidecar.md`
- `docs/layer2-specs/Execution-Certificate.md`
- `docs/examples/hello-core/manifest.core.yaml`
- `docs/examples/hello-core/hello-core-golden.json`

---
## 4) Expected Deterministic Outputs (Normative)
- First successful run MUST emit:
  - `trace_final_hash`
  - `certificate_hash`
  - `interface_hash`
- The expected values are sourced from `docs/examples/hello-core/hello-core-golden.json`.
- Any mismatch is a deterministic onboarding failure for this profile fixture.

## 6) Procedure
```text
1. Load Core fixture manifest: docs/examples/hello-core/manifest.core.yaml.
2. Execute minimal reference stack workflow (WAL -> trace -> checkpoint -> certificate -> replay check).
3. Compute trace_final_hash, certificate_hash, interface_hash via canonical CBOR hashing rules.
4. Compare emitted values against docs/examples/hello-core/hello-core-golden.json.
5. Emit deterministic onboarding verdict.
```

---
## 7) Golden Demo Evidence Bundle (Normative)
- Bundle identity:
  - `hello_core_demo_bundle_hash = SHA-256(CBOR_CANONICAL(["hello_core_demo_v1", fixture_ids, expected_identities]))`.
- Required fixture bindings:
  - `manifest_fixture_ref = fixtures/hello-core/manifest.core.yaml`
  - `fixture_manifest_ref = fixtures/hello-core/fixture-manifest.json`
  - `golden_identity_ref = goldens/hello-core/golden-identities.json`
  - `golden_manifest_ref = goldens/hello-core/golden-manifest.json`
  - `catalog_manifest_ref = contracts/catalog-manifest.json`
- Required verifier refs:
  - `docs/layer4-implementation/Evidence-Catalog.md`
  - `docs/layer4-implementation/Determinism-Audit-Playbook.md`
  - `tools/verify_doc_artifacts.py`

## 8) Artifact Verification Command (Normative)
- Verification command:
  - `python tools/verify_doc_artifacts.py`
- Result policy:
  - PASS is required before profile onboarding can be considered complete.

FILE: layer1-foundation/API-Interfaces.md
=========================================
# UML_OS API Interface Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.APIInterfaceContract_v1`  
**Purpose (1 sentence):** Define deterministic, typed, versioned callable interfaces for kernel and core operators.  
**Spec Version:** `UML_OS.Implementation.APIInterfaceContract_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** API contract specification and interoperability.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.APIInterfaceContract_v1`
- **Purpose (1 sentence):** Deterministic API interface contract.
- **Spec Version:** `UML_OS.Implementation.APIInterfaceContract_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Typed API contracts.

### 0.A Objective Semantics
- This algorithm performs deterministic validation only; no optimization is involved.
- Objective type: N/A.
- Primary comparison rule: exact schema and signature equality.
- Invalid objective policy: schema mismatch is failure.

### 0.B Reproducibility Contract
- Seed space: `seed âˆˆ {0..2^64-1}` where applicable.
- PRNG family: inherited from calling operator.
- Randomness locality: no sampling in interface contract checks.
- Replay guarantee: replayable given `(spec_version, interface_hash)`.
- Replay token: `api_replay_t = SHA-256(CBOR_CANONICAL(["api_interfaces_v1", spec_version, interface_hash]))`.

### 0.C Numeric Policy
- Numeric fields specify explicit scalar kinds (`uint64`, `float64`, etc.).
- Rounding mode / fast-math: N/A for contract validation.
- NaN/Inf policy: invalid unless explicitly allowed by API field definition.
- Approx-equality: exact type match; no implicit coercion.

### 0.D Ordering and Tie-Break Policy
- Parameter order is canonical and positional.
- Tie-break for map-like fields MUST follow canonical CBOR key ordering from `docs/layer1-foundation/Canonical-CBOR-Profile.md` (canonical encoded-key byte ordering per RFC 8949).

### 0.D.1 Canonicalization Procedure (Normative)
- Interface signatures MUST be represented as CBOR data-model objects and encoded with `CBOR_CANONICAL` from `docs/layer1-foundation/Canonical-CBOR-Profile.md`.
- Optional fields are represented by key omission (not implicit `null`) unless a consuming schema explicitly permits `null`.
- String content is consumed as provided by upstream contracts; canonicalization does not apply locale transforms.

### 0.E Parallel, Concurrency, and Reduction Policy
- Contract validation is deterministic and single-pass.
- No async behavior.

### 0.F Environment and Dependency Policy
- Reference runtime: language-agnostic schema validator.
- Dependencies: deterministic canonical CBOR canonicalization.
- Determinism level: `BITWISE` for signature serialization and hashes.
- Canonicalization procedure is normative and profile-bound to `CanonicalSerialization_v1` in `docs/layer1-foundation/Canonical-CBOR-Profile.md`.

### 0.G Operator Manifest
- `UML_OS.Implementation.ValidateAPISignature_v1`
- `UML_OS.Implementation.ValidateIOShape_v1`
- `UML_OS.Implementation.ComputeInterfaceHash_v1`
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- Fully-qualified names required.
- Sidecar mapping (`operator -> module/function`) required.
- Sidecar mapping schema (normative): canonical CBOR map
  - key: `operator_fqn:string`
  - value: `{module:string, function:string}`.

### 0.I Outputs and Metric Schema
- Declared outputs: `(validation_report, interface_hash)`.
- Metrics: `validated_operators`, `schema_mismatches`, `hash`.
- Completion status: `success | failed`.

### 0.J Spec Lifecycle Governance
- Breaking signature change requires MAJOR bump.
- Backward-compatible field additions require MINOR bump.
- Equivalence target: E0.

### 0.K Failure and Error Semantics
- Abort-only with deterministic error record.
- Codes: `API_SIGNATURE_MISMATCH`, `API_SHAPE_MISMATCH`, `API_TYPE_MISMATCH`.

### 0.L Input/Data Provenance
- Input schemas must be versioned and hash-addressable.

---

### 0.Z EQC Mandatory Declarations Addendum
- `stochastic_used: false`
- `seed_space: N/A`
- `prng_family: N/A`
- `rng_ownership: N/A`
- `numeric_kernel: N/A`
- `tolerances: N/A`
- `determinism_level: BITWISE` (for signature serialization + hashes)
- `error_trace: inherited from docs/layer1-foundation/Error-Codes.md`
- `note: this contract performs deterministic validation only`

## 2) System Model

Numbering convention note:
- Section 1 uses EQC header field labels (`0.*`).
- Section 2 uses model partitions (`I.*`, `II.*`).
- This split is intentional and normative for EQC compatibility.

### I.A Persistent State
- `interface_registry: map<operator, signature>`.

### I.B Inputs and Hyperparameters
- `declared_interfaces`, `implemented_interfaces`.

### I.C Constraints and Feasible Set
- Unconstrained; validity determined by exact schema compatibility.

### I.D Transient Variables
- `diffs`, `validation_report`, `interface_hash`.

### I.E Invariants and Assertions
- Registry entries are unique and versioned.

### II.F Syscall Interface Registry (Concrete, Authoritative)
Canonical display note:
- `allowed_error_codes` values in this rendered table are shown in canonical ordered-array form from `contracts/operator_registry.cbor`.
- Signature computation always uses the canonical ordered array representation.
- `request_schema_digest` and `response_schema_digest` cells are `digest_ref` renderings; canonical signature preimage uses resolved bytes32 values.
- `UML_OS.Error.Emit_v1` is included as a syscall operator because it is callable and listed in the operator manifest.
| surface | name | version | method | request_schema_digest | response_schema_digest | idempotent | side_effects | allowed_error_codes | signature_digest |
|---|---|---|---|---|---|---|---|---|---|
| `SYSCALL` | `UML_OS.Data.NextBatch_v2` | v2 | syscall | `sha256:b3c93fdc0519e72c27a3203174fbb5ac8b96c760f1bdc739874ea6870ae8a500` | `sha256:a74f659e6edfc9a663a78d148981b27ee46f6685bc6786ed1ca7e5e7763b4fa3` | true | `["NONE"]` | `["BATCH_SIZE_INCONSISTENT","INVALID_DATASET_KEY","CARDINALITY_MISMATCH","GLOBAL_POSITION_EXCEEDS_CARDINALITY","INVALID_STAGE_TYPE"]` | `sha256:67069ace699a580ed23a01168b46d0242002d82f8d429266b195d3a459eb972f` |
| `SYSCALL` | `UML_OS.Model.Forward_v2` | v2 | syscall | `sha256:82a1c1413fc3fd8176c351bb828315354fb3434760cdb4a47f30408f92f26fa7` | `sha256:d69a39c6e458a4803aff256e848784fddc34f6db4c5a963b5959fbc264076c09` | false | `["ADVANCES_RNG"]` | `["CONTRACT_VIOLATION","PRIMITIVE_UNSUPPORTED"]` | `sha256:17d85435fe2e601fe522b614938ea7853b9c36be14c8feb84f4e70e1e253bc74` |
| `SYSCALL` | `UML_OS.Model.ModelIR_Executor_v1` | v1 | syscall | `sha256:a50166213aefcd3a51e2660cd50d4dca444353e4d3642c1cacc7300c158ef362` | `sha256:a9788d4553cee1d35d7f79c65d21cdf28d143a066152462568fa5e5d3ad36024` | false | `["ALLOCATES_MEMORY"]` | `["INVALID_IR","PRIMITIVE_UNSUPPORTED","CYCLE_DETECTED","SHAPE_MISMATCH","TMMU_ALLOCATION_FAILURE","CONTRACT_VIOLATION"]` | `sha256:ce1ec3e5cead31a92f46e79847332d3db0fdd824f2f3b6608987c77450a6de70` |
| `SYSCALL` | `UML_OS.DifferentialPrivacy.Apply_v3` | v3 | syscall | `sha256:c788135091bca6dda0dfa6be1903fe534aba3ce8aba22802338f4557c2f62b2c` | `sha256:e4511aa77256d2b3984b25381f8a14e780a0f701bfeb5db134f06143607cb7d6` | false | `["ADVANCES_RNG","MUTATES_ACCOUNTANT"]` | `["PRIVACY_BUDGET_EXCEEDED","INVALID_DP_CONFIG","INVALID_GRADIENT","NAN_IN_SIGMA","ACCOUNTANT_OVERFLOW","ACCOUNTANT_DIVERGENCE","RNG_CONSUMPTION_VIOLATION"]` | `sha256:df574eb8b39a83a8107bce17dbcddbd3c1751aa51ccd6f9dcdd0e95ddab6b52f` |
| `SYSCALL` | `UML_OS.TMMU.PrepareMemory_v2` | v2 | syscall | `sha256:1868515eb2e8b04486ca2a2a0aec0cad27e33a85e1c66369dbdb6dd72f3aa227` | `sha256:5602da41a9eb5e0d7ab21000bb82018688523f01987e498e186ba6854991df1e` | false | `["ALLOCATES_MEMORY"]` | `["INVALID_IR_SHAPES","LIVENESS_CYCLE","ADDRESS_COLLISION","ALLOCATION_OVERFLOW","ARENA_TOO_SMALL","ALIGNMENT_VIOLATION"]` | `sha256:87ad2acf49cc0081824d67a2b0838d03d3bd2f3f2d3ae19a9b07af50bc264b09` |
| `SYSCALL` | `UML_OS.Backend.LoadDriver_v1` | v1 | syscall | `sha256:b9d299c7e1cd2bd04e499b1458b2bb935f47de74daf18652356fc36f117f76b1` | `sha256:c2a0b76a20abbe89e02cd7626c77e300d0f0373d6b47b9e437eec408727c9768` | false | `["PERFORMS_IO","NETWORK_COMM"]` | `["BACKEND_CONTRACT_VIOLATION"]` | `sha256:708fd111f6fc0a8f85853a4218ff9eba82ffc3da285266b15f6714a450728056` |
| `SYSCALL` | `UML_OS.IO.SaveCheckpoint_v1` | v1 | syscall | `sha256:47d294c74846623fdf009597597bfc131190727f15959b846520ccc3162494df` | `sha256:ef98d3bdf59fafb396766c343ffd67b730175f43c34d7d7b64903993132ff430` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:7500cd45013f340439c196a8119f1da650f325f9b9fb22567574df80a78c5d77` |
| `SYSCALL` | `UML_OS.Checkpoint.Restore_v1` | v1 | syscall | `sha256:87e869485275faea2aecf8a8cf8398ecb7452cb0c6df60327b4a1671c8948caf` | `sha256:1ac5f1b5313af3eeba05b0aa2e6df19358d7ee51f957fe07dcd29f4faca2c28a` | false | `["PERFORMS_IO","MUTATES_MODEL_STATE"]` | `["CONTRACT_VIOLATION"]` | `sha256:2ad8fce88d166dfbfd042dfd9e91e1e282e4f549cea088b141872d53a863ef89` |
| `SYSCALL` | `UML_OS.Error.Emit_v1` | v1 | syscall | `sha256:fe80f62ef86ec79731ec8bf913a336651d0326851760667ed1e06c1adbf4bc6e` | `sha256:83e2decc3c6e418f3a61404f91c88cec96b5a2fb573d77fe3db98ffc548622d1` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:0cb1f29e7f28d98dc020d74fdac09b1d56e18e137e6a5f445447480bd450785c` |

### II.G Service API Registry (Concrete, Authoritative)
Canonical display note:
- `allowed_error_codes` values in this rendered table are shown in canonical ordered-array form from `contracts/operator_registry.cbor`.
| surface | name | version | method | request_schema_digest | response_schema_digest | idempotent | side_effects | allowed_error_codes | signature_digest |
|---|---|---|---|---|---|---|---|---|---|
| `SERVICE` | `UML_OS.Tracking.RunCreate_v1` | v1 | service | `sha256:79f63d036b91c33bbd5a0a64468f93107f79b755e73810824d3877aeb6561fc1` | `sha256:658a3e66ec1cf259a71244bc535d7d4efa5fc648ca4aedf8686e50e2bfd29dad` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:f9912032a083a24960b3fce71bef84b6b6669bd4f1455143b793abd46c61d979` |
| `SERVICE` | `UML_OS.Tracking.RunStart_v1` | v1 | service | `sha256:3c9f675dfcb5deb7de64eecff530e2a0d1ad327714e38b22db4b3a40834a319c` | `sha256:663474fa4ef7f6cbf299ef27426b09a36a57a05cde2af9775ccc470f91edf9c1` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:3bbc23354e81d350087a3eb11f45db4202d35b2c3a0d789917ce250c67d604ad` |
| `SERVICE` | `UML_OS.Tracking.RunEnd_v1` | v1 | service | `sha256:2d7735c3a7d1f21b2966ef34279274fdeb2d5cdedf1295d06d69b46ffe6c44c1` | `sha256:e3fbb827b7df3c88ecbe534511e4a681c8f914b03314f45db615b0265f182767` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:61cffc6435589391694727d1950e9b897ecb4a9a1678ad318b7cb4863762bd8a` |
| `SERVICE` | `UML_OS.Tracking.MetricLog_v1` | v1 | service | `sha256:e4dfe80e6d2e71cf3281f732fb4ce3bff8c8fb5cce4b339e0ffb0e10fbf2d705` | `sha256:dbeeadfcd9ce45b81acb44aede35acd0caebba6be61a1bf2b0775644c6812fc3` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:2bfc26d97f932a7f4dc99529872f54dcee07c1f37fa160dc1f09d4bbc0052553` |
| `SERVICE` | `UML_OS.Tracking.ArtifactPut_v1` | v1 | service | `sha256:376c6ac9c8f23bd60de605af173aaedfb29f9a9772a16bc4319d5eaf2ca88212` | `sha256:8d5ec7401a722b52bffd442dc143be279636527005c45b7cde91ce186286f1b5` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:4c83219b6825bbbb8b64254328e6fa7d64e4eb04065f32e214ba7576fe0c3621` |
| `SERVICE` | `UML_OS.Tracking.ArtifactGet_v1` | v1 | service | `sha256:aaa6f3df2d7f7837909b36fb6ffb8a7cb4e7137fa043c35d6d9ed441cd04400f` | `sha256:d2afbd6a00fe8ad77800be3bd21ece5e4508cccda15c614b80e648adb288d8f1` | true | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:89c470402948fd7717c7a89074e466ccaa731270b28bd798c8ef4b3905521d83` |
| `SERVICE` | `UML_OS.Tracking.ArtifactList_v1` | v1 | service | `sha256:390eb2cd44de8e5a8702e2e9ee5a9546fa6f3bad93ede910f191d0b5cafa9d99` | `sha256:32a01fe15e446238cd353af5b0fd517352c4584831062670e1a0d77567767a91` | true | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:a02167e5e2a3f785190069b65127032dd2841544af82da03dd1d237fbdc38f40` |
| `SERVICE` | `UML_OS.Tracking.ArtifactTombstone_v1` | v1 | service | `sha256:34be789a7612797a9bcac210bf5664724e7a1a10b6a1321cd2196b0378accbc5` | `sha256:269fe8e05ec1db5c082f7e3c6b1ef5a37a8e1ae65fd2cc9c9903b1dd3e8de5e1` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:668e41817d89f2aeb2af4e9394302cb935425450e4595c5db1965ed5d3f9ea22` |
| `SERVICE` | `UML_OS.Registry.VersionCreate_v1` | v1 | service | `sha256:1535b143bf15d47cde6b95c1e8bd9d90018d9e631b8565007c3ff0f4c5eeb221` | `sha256:c422b8f784e0a458336a0d7eb7b5adb32d9608aef2d459359e99142bed3bed43` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:5690d2ee8d34c3407e33f14f25198d35af170150c663b5290f9f6460003a8f0e` |
| `SERVICE` | `UML_OS.Registry.StageTransition_v1` | v1 | service | `sha256:e634b4adad159203c88a086e8194833a9b3a718f68bad60fdeec0c616f25e770` | `sha256:39ce69213d5b015a69485eed6bd9065065ae8981b55368c65f2148d0a8490a18` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:df171fad79b74e99a5cf98c98c0dd0d99891c6e28d2b21de21de12e797db46af` |
| `SERVICE` | `UML_OS.Monitor.Register_v1` | v1 | service | `sha256:3812992f06cac5e8845b5707f18487a7abd1c18b797d0d17f0dbef2c5e535988` | `sha256:fc700ecfc6b59d532b0f2090fa9f3f9d5a25365503bad36df2bd7d17ace66605` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:0a5e9373bfba01ba4bbeddba689074a704d538e7ebe4e072a139cef99bbd4440` |
| `SERVICE` | `UML_OS.Monitor.Emit_v1` | v1 | service | `sha256:063a9d6fbd2cc06ca6230a9dd42e740edec0ea0b76eae794c6695f239b9a35ff` | `sha256:6adacbfc76a20bed4a542e1df0090d662e51fb6e9b08ef1d67734dbc6de6d7f2` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:eb4d0698028761a1d5f75b66d7a67a758045aa33846d50296990722b30156550` |
| `SERVICE` | `UML_OS.Monitor.DriftCompute_v1` | v1 | service | `sha256:84751ff5c4f6c4508d2eb3bf6b5fb382a43aeef11b15a7d5f10e392a50742d93` | `sha256:9976dd86b5801ea78df696947695ca62e1e9868f02dd36c2a8cdcbc5b793be3a` | true | `["NONE"]` | `["CONTRACT_VIOLATION"]` | `sha256:901881d54845698125611c9d87d11e7fa5419248a4caf8dbb839465dccfe25fb` |
| `SERVICE` | `UML_OS.Certificate.EvidenceValidate_v1` | v1 | service | `sha256:1165b63ee12061a187b8bbbe0f55eb800d09f5c7ec1e7a45d02fc90ee594960a` | `sha256:b803f8990a492ff39515aa099d0d92297488a07501b37a613e43502afa17dc79` | true | `["NONE"]` | `["CONTRACT_VIOLATION"]` | `sha256:9d55661802f55dacd9695031acfeed3745f9a501b7db5606b814ad546116d5b1` |
| `SERVICE` | `UML_OS.Config.ManifestMigrate_v1` | v1 | service | `sha256:12bfcae0d2cf5d76c722cd4f967eb4a250f2316fc5fc2173a96585f6684500e3` | `sha256:d54f71baddda92b26c3bbdad54037f9573a6d16763c437ff2d6250ddb7ac7ba7` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:29695a8e891b995033fc2508204991bb8cb28067965ebac7bfbe26478b40cc89` |
| `SERVICE` | `UML_OS.Checkpoint.CheckpointMigrate_v1` | v1 | service | `sha256:3be7173771ea6e390239d664e137cc4a54db6fa696587a5bc3f514bdc7e35a57` | `sha256:70c2eaa4515e6662e32aee16a46c9055319fa6f61cb01ea18a7cb9d2b48dfe6f` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:ea0f1f735948058cd9893fe6f9c661ca578097c83c93780c624c4245dc576c59` |
| `SERVICE` | `UML_OS.Trace.TraceMigrate_v1` | v1 | service | `sha256:a79b56d5d8b5629e62bfab67f08432459ffef04ae4beb121f3f098eee5a4365f` | `sha256:53a6622c6b83f35487826cf96e27b7b6cc9afc888d8afd4e76d03250de206e86` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:fe3709bad090dcd8f5f190649a7694bd26ca059e9a47b3eaf784d0268bf442ee` |
| `SERVICE` | `UML_OS.Import.LegacyFramework_v1` | v1 | service | `sha256:64442d19eded7c78bc5b84301b0be39f5c6f3aee6dc35efe0db3cf5545a76d7c` | `sha256:8c834fc6ef6ce6a077d23903f51fc0ccab895f3b5762daf3fc03fd46fc566be5` | false | `["PERFORMS_IO"]` | `["CONTRACT_VIOLATION"]` | `sha256:20c8da5d2c5565476edc1c59ba209b14f19e0f4f3e71be86f4854f28abea0839` |

### II.H Schema/Signature Digest Rules (Normative)
- `SchemaDigest_v1 = SHA-256(CBOR_CANONICAL(schema_ast_normalized))`.
- `SignatureDigest_v1` is defined normatively in `docs/layer1-foundation/Operator-Registry-Schema.md` (`sig_v1` preimage with resolved bytes32 digests).
- Canonical schema sources must be stored under `schemas/` and used as the single source for digest generation in build/codegen.
- `schema_ast_normalized` (normative):
  - schema parsed into AST with resolved type aliases,
  - canonical field ordering (bytewise UTF-8 lexicographic by field name),
  - explicit optionality/default annotations materialized,
  - no implementation-specific metadata fields.

### II.I Canonical Operator Registry Binding (Normative)
- `contracts/operator_registry.cbor` is authoritative for interface metadata.
- Every row in syscall/service registries must match the corresponding artifact record exactly for:
  - `surface`, `request_schema_digest`, `response_schema_digest`, `signature_digest`,
  - `side_effects`, `allowed_error_codes`, `purity_class`, `required_capabilities`.
- This document is a rendered view; edits that are not reflected in the artifact are invalid.
- Rendered-table note:
  - `purity_class` and `required_capabilities` are authoritative in `contracts/operator_registry.cbor` but omitted in rendered tables here for readability.

### II.J Capability/RBAC Binding (Normative)
- Every callable operator must declare `required_capabilities` in the canonical operator registry.
- Authorization verdict per call must be deterministic:
  - `authz_query_hash = SHA-256(CBOR_CANONICAL([tenant_id, principal_id, operator_id, sorted(required_capabilities), authz_policy_hash, capability_matrix_hash]))`.
  - `authz_decision_hash = SHA-256(CBOR_CANONICAL([authz_query_hash, verdict_enum, granted_capabilities_hash, decision_reason_code]))`.
- Denied calls must emit a deterministic failure record and trace event with `authz_decision_hash`.

### II.K Kernel Syscall Registry (Kernel Subset View)
- This table is the kernel syscall subset view and must match `docs/layer2-specs/UML_OS-Kernel-v3.22-OS.md` section 4 (1:1 operator membership).
- For any operator also present in `II.F`, digest fields MUST be byte-identical to `II.F`.
- Each listed operator must resolve to concrete request/response schema digests and signature digest in `contracts/operator_registry.cbor`.
| name | method | request_schema_digest | response_schema_digest | signature_digest |
|---|---|---|---|---|
| `UML_OS.OS.Bootstrap_v1` | syscall | `sha256:6b95add4346e37b63e64c7e208a7df8f4965e372878b8b9fd4fed7c5bbd403b7` | `sha256:d9625678d8addcaf15db3e69d1ffa9e954a64bb290d4981087a5837bce2c87af` | `sha256:08c1cb8901ce5f30ec8015c5eed6efd43061269ef899e03f8a493b54f4a335c7` |
| `UML_OS.OS.ResolvePath_v1` | syscall | `sha256:f82201a6830a4c6d980a9b4b43978c87f7122478d60be2dfbb8a052deb00783b` | `sha256:e647055a824d66af8290fadbe67fad3ca74f8b25c452d2848ed2d427bba80997` | `sha256:d1351c580e2a35476e067c55ed84657c51d716176e24ec14afa9b3e60f9b9a7e` |
| `UML_OS.OS.NamespaceEnter_v1` | syscall | `sha256:2a87e448ed17daf1a91417ecf6bb467a1d379b6c85b0299f5d882d6065620633` | `sha256:8d28371559d3bd93aa1dc4db75b922db61ab64789ccb1b3a468c9e252f6117d9` | `sha256:edd3f2c3428542cf0bfe2eef09c0189da81eb4cbeda72dec97880474d3088682` |
| `UML_OS.Data.Manifest_v1` | syscall | `sha256:3654426af7930039cad3d1dc0369450f7f18066c718f9a186867c1a9f619c3e2` | `sha256:78a4b828924c20cfd65a2112f2ddefeee17c7a60cdffa4a3d3061f8888aa81e1` | `sha256:a6ed8cf76086a6ac859048e40f5980c02c797917039b4f85539169c2a2a60a71` |
| `UML_OS.Data.ValidateManifest_v1` | syscall | `sha256:c1f88fca6f77de2cc6bd833f478e774d2a7430ffbad7367f03f4aeffded23e26` | `sha256:b8d90fedcca9d9ffbce84a11c1c2a48e5722ac3499116d893f94a55e8296239d` | `sha256:6a7868616da975c611ac763a815fe897481b70ad8b888f8bff209233c89b6bf8` |
| `UML_OS.Data.NextBatch_v2` | syscall | `sha256:b3c93fdc0519e72c27a3203174fbb5ac8b96c760f1bdc739874ea6870ae8a500` | `sha256:a74f659e6edfc9a663a78d148981b27ee46f6685bc6786ed1ca7e5e7763b4fa3` | `sha256:67069ace699a580ed23a01168b46d0242002d82f8d429266b195d3a459eb972f` |
| `UML_OS.Data.RegisterDataset_v1` | syscall | `sha256:8e46cc4203902d52e8543728f848463fe1147a106349fe55c251fc9900371b20` | `sha256:8c69578f99e296e93a31b23a15be300c9a1e4e8c16afe55923b8f8054c999aca` | `sha256:fa4fca34ee532474b5ebb5cdbfba175fed2eaadbe4d5e99cbbd4a47387420989` |
| `UML_OS.Data.ImportAndRegister_v1` | syscall | `sha256:d7d5be587bcdcc3459b7873757323b45818a9a0881b4603f8d3a8e5994a13839` | `sha256:caca94241bc539142fabc502bdcb3153aa1592f9c241335397b392076e506adc` | `sha256:a69a029f9fed4e9f654c6d54a3bc2e54285f01285b8d556cf339742ec81eb5ef` |
| `UML_OS.Model.Forward_v2` | syscall | `sha256:82a1c1413fc3fd8176c351bb828315354fb3434760cdb4a47f30408f92f26fa7` | `sha256:d69a39c6e458a4803aff256e848784fddc34f6db4c5a963b5959fbc264076c09` | `sha256:17d85435fe2e601fe522b614938ea7853b9c36be14c8feb84f4e70e1e253bc74` |
| `UML_OS.Model.ExpandPreset_v1` | syscall | `sha256:a29fb645799b57ea4a4032a9a29697bf51ff20ee2469af83098973c2e1fb0826` | `sha256:662de6db6e9b14bf13168b79137682e783b60eb605d9e5610210766195e331e7` | `sha256:8b58dca0a2345b5d115d81187589ec0d61388a19d8d94f3b5cdd5c2334534f83` |
| `UML_OS.Model.ApplyFineTune_v1` | syscall | `sha256:ab5fec71b1c0ed85d7def95b9ca4a93512bfadc76694ad56380c947a88ce4679` | `sha256:f7bfe9be3307d5cf1eb847c5a4908ee959686c238a0903e2e490e3898b77a643` | `sha256:840971d67ece4e5b7eef6eb5d68c1fb5bcac5b61181798a966ba527f5291272a` |
| `UML_OS.Objective.TotalLoss_v1` | syscall | `sha256:9b83b6707b2fa85f58f49ff5a1c66114b1bd8997d89e7402c1146f9d871ea736` | `sha256:1a712c624d506411a4f89b0c50817a7d6fa2aebd7bc960886fc5e00e21c19ddc` | `sha256:2d7e17c8b906d090f7edb238571f68d6f36409a2e886bc80bdc41cdaa33c77d3` |
| `UML_OS.Optimizer.Update_v1` | syscall | `sha256:b67f9f7943effca758fe10599372e960112fe27e689b81fff9d510ef3210a54e` | `sha256:44bc40731fe3f283a666c65c806b6513709608ce8f86cd73575f72fea5768cb5` | `sha256:f5163784a6f0c3e0ab7f9d93ee7652348264809600fc1bdca121ce22707e033f` |
| `UML_OS.Module.RegisterCustom_v1` | syscall | `sha256:4fdba7baab89d6c7ff5c293cc5ddabbae21af8e0f757b0412b7e3ef3e9a3953a` | `sha256:6ffd1b926a3cc7cda04ca017481d05090fba6742d2527714c5de84e1375065a4` | `sha256:dc812a5845fc78fb7b7eae7d42b1b90f7d840d99c5c4cd1d83d09767c166d405` |
| `UML_OS.Policy.Evaluate_v1` | syscall | `sha256:bdaeefcfdafff6ba8d79ee757f08f9d5c5ef9cd4c34110ae9a3c73ec245e4da2` | `sha256:ee125a4968ba99cea329a14b95948b8b27d4cd3d7b63752c8957ecd98609d4dc` | `sha256:d3deb27e807de01491da8f3286a03aa2a95e36c66525cefdc7d08f455396fb34` |
| `UML_OS.Contract.Validate_v1` | syscall | `sha256:0ff020e0e3a53351c77cb0879226c6d51ee5b871027cae906bbfb99e3df1b4c4` | `sha256:43d29709c190ba8f50bad8e0cdf6e473a7a6c7c81ef5fc1c8b3377e3534601df` | `sha256:a29d999bcd747ce0a666e965492bec241a58c0e476a3dcaddf345f64c3740132` |
| `UML_OS.IO.WriteTape_v1` | syscall | `sha256:9f05a18d391747a0fc91def1097592cb2d73d5214650ad37ad48382de2f7be28` | `sha256:c194ac7ca5ed44b138e0a5833d8345d531853f0621e85bd837ee2559de133a62` | `sha256:3f8e9fa6f43b5b95b55806068e662c63669df472a6f2fb9f11be9a6af7ec80b9` |
| `UML_OS.IO.SaveCheckpoint_v1` | syscall | `sha256:47d294c74846623fdf009597597bfc131190727f15959b846520ccc3162494df` | `sha256:ef98d3bdf59fafb396766c343ffd67b730175f43c34d7d7b64903993132ff430` | `sha256:7500cd45013f340439c196a8119f1da650f325f9b9fb22567574df80a78c5d77` |
| `UML_OS.Certificate.WriteExecutionCertificate_v1` | syscall | `sha256:5d67c20d00f6b0c3a6b8e0f3617eebdfc5eca398aed4539b7a63427be372b772` | `sha256:ffcda8c4913eba63cdb31a4b0fd3e79d9e790cb02a29129f551a5ea35de4e0c7` | `sha256:e2b8389dc808da6e631f4d6365ca256c4c0005bf756674b8357c519b3b067514` |
| `UML_OS.State.Journal_v1` | syscall | `sha256:73d6f8f0a2ed2405131cd52a1e8cdd7ac5cdb77391a14054a35ed5a6d66ed0ec` | `sha256:968806f83eb4ec37d8c9f3f76d7a9207ecd1547b7cbf6522582dff57ef29467d` | `sha256:77af6f21db7ad774735a92323cf0635d3576bcdd943abe316aa084540d1dde34` |
| `UML_OS.Termination.Check_v1` | syscall | `sha256:ef7d9d1d2378d1acbf85fd86af5596ecc360fb7a79e63e5c7f220f04150dce7d` | `sha256:2e764c0500e07cc3465e9fa5e71158d9151409bd12d5439414c88831ceaafefc` | `sha256:ec35105bda624ff9d225c800f34e93fdf51c82ad67e928b2c78cfc1a16ef31ef` |
| `UML_OS.Fingerprint.StateFingerprint_v1` | syscall | `sha256:af18d3615139f226da1b6b8f7646e65547681ff49e24346eb7b23403964a004a` | `sha256:d16eb6e8964c2096a4d1632228554c776ac40166f75b910dc7d4caff2e3fac6e` | `sha256:54763a526ff78f14ffe3dec8c0944a9e9d26007f582eedfc85e798887b986669` |
| `UML_OS.Fingerprint.Functional_v1` | syscall | `sha256:6347e5c15b9898e03120ac6a4d9a4a54ba601ac608fb10860c35dae071526c39` | `sha256:ac13b14a64283e8f257ffe80067dd72693968601a05b19a015a3a8bd0dfc500d` | `sha256:64ccf71e54020c3a17cafe24458c0147614310448b64a44749f792bcddc4a6da` |
| `UML_OS.Error.Emit_v1` | syscall | `sha256:fe80f62ef86ec79731ec8bf913a336651d0326851760667ed1e06c1adbf4bc6e` | `sha256:83e2decc3c6e418f3a61404f91c88cec96b5a2fb573d77fe3db98ffc548622d1` | `sha256:0cb1f29e7f28d98dc020d74fdac09b1d56e18e137e6a5f445447480bd450785c` |
| `UML_OS.Distributed.Setup_v1` | syscall | `sha256:7e8fdb0852b617888a3eb423787a9b5e1ba206173a1dda37550139d8d1ade0a2` | `sha256:3f8563b15d2050973185087fa89be664d5cf032bd1ebad0830840e0372778999` | `sha256:8f9f8367e7a00cd1b3fe87a5a9238b761b8c09ede2ec835c4c1abb0f55916702` |
| `UML_OS.Evaluation.Run_v1` | syscall | `sha256:290a073ce9830f68151186bffe02bf6711e79949c4b9871decb3ed1fe9237d8b` | `sha256:bd29a04ed4a4297f712751d5ea1760ae79c5eb16d666708cf8e50bb3cf49b3a5` | `sha256:07d194d0b634a85eef1ca7b6fe4bd1786037a0e6b8a8504850af6533735e95f5` |
| `UML_OS.Security.AttestTEE_v1` | syscall | `sha256:c6f8eada24a2482866d5bae0149c6707851aa7d94b886876ea849a59e55c2889` | `sha256:690253b660f5956bd6f38d5cd16b2f5ddb6a860cdf0053ac3d1b24f5d0233d30` | `sha256:ab930860204463c24c2df98764c6410f6207062a23238448ec3ea84f08148927` |
| `UML_OS.Verifiable.CommitFunctional_v1` | syscall | `sha256:5f7682174b5ff972d570acc219ff07197bd49120980d087993ed42e12053572b` | `sha256:93e5ba69c82f516cd9806b8f9be68e8ae048c102e45ebd8cefea33a7be4ac6b0` | `sha256:8a6eedab6cf4a79fec3a17a23b4c47e91f6bfce1e979ae69210de6ae93b3862c` |
| `UML_OS.DifferentialPrivacy.Apply_v3` | syscall | `sha256:c788135091bca6dda0dfa6be1903fe534aba3ce8aba22802338f4557c2f62b2c` | `sha256:e4511aa77256d2b3984b25381f8a14e780a0f701bfeb5db134f06143607cb7d6` | `sha256:df574eb8b39a83a8107bce17dbcddbd3c1751aa51ccd6f9dcdd0e95ddab6b52f` |
| `UML_OS.Backend.LoadDriver_v1` | syscall | `sha256:b9d299c7e1cd2bd04e499b1458b2bb935f47de74daf18652356fc36f117f76b1` | `sha256:c2a0b76a20abbe89e02cd7626c77e300d0f0373d6b47b9e437eec408727c9768` | `sha256:708fd111f6fc0a8f85853a4218ff9eba82ffc3da285266b15f6714a450728056` |
| `UML_OS.Pipeline.Dispatch_v1` | syscall | `sha256:c4ba86ac3ba9f9e0c322771914848eb72e9c5e36c5a9c8828f8d6f55d3de44bb` | `sha256:451c011e029b5d115e95092cc1952c36a8000a72b65e119bd1dda15d77ce18ca` | `sha256:5c3541f522edf71475ad465ea07303273dbb301db258baa63d4b6d7e25fe911d` |
| `UML_OS.Inference.RunBatch_v1` | syscall | `sha256:413088da6e718570c050892c3e272823a4bc3be2bd85638d228fbeca14306d0f` | `sha256:d7eb4aa78a41d586676f1eb67ac4e3e7404d91648a8c2002b3caf7b899c08cba` | `sha256:d8c6c6c790701ea9f9e8e1a370549e0e059e4520a7414bbb404a56efdf3483be` |
| `UML_OS.Model.Backward_v1` | syscall | `sha256:bc7e0699d6f8a6c778f0cf4dbbaa73cc0f9389682de1512c979608262d11d725` | `sha256:b631a6ac19ba9aa0612db577717dff96a6eebf3fe25aacd3230744b444d78858` | `sha256:703bd22df1f08ac39226c51b08bce7c73396b484c440737497dc79bda672e7af` |
| `UML_OS.Symbolic.Augment_v1` | syscall | `sha256:f1e889eb31bd7d78329a46a40c0ccd21d35db27eb12c38d40d06fa919bace7aa` | `sha256:9edf3ecb9d21824f916f116aac19f05f17b622def37f6641210c6dad409d670e` | `sha256:810cc5b6ce8161a364e3b80f678fb8f3459790a5bdd9346be3bcd87922afec1e` |
| `UML_OS.Security.VerifyCertificate_v1` | syscall | `sha256:11c8108318f8db27dc96b6ecd689fa171d0ea4f20b2aa82dced7e61ea0e9c526` | `sha256:8e953036cfdd7db445cd2ca698ad3aa4735c457e5053c4fc24ff0134ac7bde76` | `sha256:d4d5727241d591689241c55e5056964aba2885b5e543da86c251309dfe2cbbdb` |
| `UML_OS.Transition.SwitchState_v1` | syscall | `sha256:7bbf2cd20736ac4f1c737302f57db2529f93c3d9db2ff83d0df607c887c9e4de` | `sha256:8c47c41abc7289ee18fd528c70289c3cde0d9214f362791ba3713fb0defab9e1` | `sha256:f1ecdd9a111f4333fbf2915bcde851c29deef1aea4f9398726e34da44c8c7452` |

---

## 3) Initialization

1. Load declared interfaces.
2. Canonicalize schemas.
3. Build interface registry.

---

## 4) Operator Manifest

- `UML_OS.Implementation.ValidateAPISignature_v1`
- `UML_OS.Implementation.ValidateIOShape_v1`
- `UML_OS.Implementation.ComputeInterfaceHash_v1`
- `UML_OS.Error.Emit_v1`

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

**Operator:** `UML_OS.Implementation.ValidateAPISignature_v1`  
**Category:** IO  
**Signature:** `(declared, implemented -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** exact field/type/order validation.  
**Output schema (`report`, normative):** `{success:bool, mismatches:array<string>}` where each mismatch is a deterministic field-path string.
**Preconditions / Postconditions:** inputs canonicalized.  
**Edge cases:** missing optional fields.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** field traversal order is canonical CBOR key order of the CBOR-encoded field-name text strings (see `Canonical-CBOR-Profile.md`).  
**Complexity note:** O(total_fields).  
**Failure behavior:** emit deterministic mismatch record.  
**Dependencies:** canonical schema encoder.  
**Test vectors:** matching/mismatching signatures.

**Operator:** `UML_OS.Implementation.ValidateIOShape_v1`  
**Category:** IO  
**Signature:** `(signature, sample_payload -> ok:bool)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates payload type/shape contracts.  
**Preconditions / Postconditions:** signature exists.  
**Edge cases:** optional and nullable fields.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** deterministic key traversal.  
**Complexity note:** O(payload_size).  
**Failure behavior:** `API_SHAPE_MISMATCH`.  
**Dependencies:** schema validator.  
**Test vectors:** representative payload set.

**Operator:** `UML_OS.Implementation.ComputeInterfaceHash_v1`  
**Category:** IO  
**Signature:** `(registry -> interface_hash)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** construct `registry_map` as a canonical CBOR map (`operator_fqn -> signature_object`) and compute `interface_hash = SHA-256(CBOR_CANONICAL(["api_interfaces_v1", registry_map]))`.  
**Preconditions / Postconditions:** unique registry keys.  
**Edge cases:** empty registry.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** map ordering is canonical CBOR key ordering; no ad-hoc secondary sort is allowed.  
**Complexity note:** O(registry_size).  
**Failure behavior:** abort on hash serialization failure.  
**Dependencies:** canonical serializer + hash function.  
**Test vectors:** fixed registry hash snapshots.

---

## 6) Procedure

```text
1. ValidateAPISignature_v1(declared, implemented)
2. ValidateIOShape_v1(...) on representative payloads
3. ComputeInterfaceHash_v1(registry)
4. Return report + hash
```

---

## 7) Trace & Metrics

### Logging rule
Each validation run emits deterministic mismatch and summary records.

### Trace schema
- `run_header`: spec_version, interface_count
- `iter`: operator, check_type, result
- `run_end`: status, interface_hash

### Metric schema
- `validated_operators`, `schema_mismatches`, `hash`

### Comparability guarantee
Comparable iff identical schema keys/typing, identical interface hash domain tag (`"api_interfaces_v1"`), and identical canonical serialization profile/version (`CanonicalSerialization_v1`).

---

## 8) Validation

#### VII.A Lint rules (mandatory)
Passes symbol completeness, no hidden globals, deterministic ordering, trace compliance.

#### VII.B Operator test vectors (mandatory)
Includes exact signature and payload conformance vectors.

#### VII.C Golden traces (mandatory)
Golden hash snapshots for known interface sets.

---

## 9) Refactor & Equivalence

#### VIII.A Equivalence levels
- E0 required.

#### VIII.B Allowed refactor categories
- Validator implementation refactor preserving outputs and hashes.

#### VIII.C Equivalence test procedure (mandatory)
Compare full report and interface hash.

---

## 10) Checkpoint/Restore

### Checkpoint contents
- interface registry snapshot + hash.

### Serialization
- deterministic canonical CBOR.

### Restore semantics
- restored registry yields identical validation outputs.

---
## 11) External API Artifact Generation Addendum (Normative)
- API interface registry MUST be translatable to:
  - OpenAPI artifact bundle,
  - Protobuf artifact bundle.
- Generation identity:
  - `openapi_bundle_hash = SHA-256(CBOR_CANONICAL(openapi_bundle))`
  - `protobuf_bundle_hash = SHA-256(CBOR_CANONICAL(protobuf_bundle))`
- Generated SDK requirement:
  - at minimum Python/Go/TypeScript SDK generation must consume these artifacts without altering canonical request/response semantics.
- Conformance requirement:
  - generated clients must pass interface conformance suites with the same canonicalization and signature-digest rules as runtime operators.
- Conformance catalog identity:
  - `api_artifact_conformance_catalog_hash = SHA-256(CBOR_CANONICAL([test_vector_set_hash, conformance_runner_version_hash, canonical_profile_id]))`.
- Deterministic round-trip requirement:
  - generated client -> server stub -> canonical request/response bytes MUST be byte-identical to runtime canonicalization rules under `CanonicalSerialization_v1`.
- Interoperability bridge reference:
  - `docs/layer4-implementation/Interoperability-Standards-Bridge.md`.

FILE: layer1-foundation/Canonical-CBOR-Profile.md
=================================================
# UML_OS Canonical CBOR Profile Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Serialization.CanonicalCBORProfile_v1`  
**Purpose (1 sentence):** Define the single canonical CBOR encoding profile used for all commitment hashes and signatures.  
**Spec Version:** `UML_OS.Serialization.CanonicalCBORProfile_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Deterministic serialization and cryptographic commitment consistency.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Serialization.CanonicalCBORProfile_v1`
- **Purpose (1 sentence):** Single-source canonical CBOR profile.
### 0.A Objective Semantics
- Primary comparison rule: byte-identical canonical encoding.
- Invalid objective policy: non-canonical payload is invalid.
### 0.B Reproducibility Contract
- Replayable given `(profile_version, input_object)`.
### 0.C Numeric Policy
- All floating-point values MUST encode as IEEE-754 binary64.
- Floating-point inputs MUST already be IEEE-754 binary64 values; encoder preserves exact input bit patterns subject to canonical special-value constraints in II.F.
- No conversion from lower/higher precision floating formats is performed by this profile.
### 0.D Ordering and Tie-Break Policy
- Map keys MUST be sorted in ascending lexicographic order of their canonical encoded key bytes (RFC 8949 canonical ordering).
### 0.D.1 Context Independence Rule
- Canonical encoding is context-free and MUST NOT depend on usage (no signed/hash-critical or commitment-path dependent encoding variants).
### 0.E Parallel, Concurrency, and Reduction Policy
- Encoding output must be deterministic independent of thread scheduling.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE`.
### 0.G Operator Manifest
- `UML_OS.Serialization.EncodeCanonicalCBOR_v1`
- `UML_OS.Serialization.ValidateCanonicalCBOR_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Canonical profile identifier: `CanonicalSerialization_v1`.
### 0.I Outputs and Metric Schema
- `EncodeCanonicalCBOR_v1` output: `(canonical_bytes)`.
- `ValidateCanonicalCBOR_v1` output: `(validation_report)`.
### 0.J Spec Lifecycle Governance
- Any rule change is MAJOR.
### 0.K Failure and Error Semantics
- `EncodeCanonicalCBOR_v1` MUST fail via deterministic error signaling (language-appropriate exception/error result) on invalid input under this profile.
- `ValidateCanonicalCBOR_v1` MUST return `validation_report.valid=false` with deterministic error entries for any violation.
- Callers MUST treat any failure signal or `valid=false` report as nonconformant and MUST NOT use produced bytes for commitments/signatures.
### 0.L Input/Data Provenance
- Input schema and profile id must be declared with hash.

### 0.M Input Data Model Preamble
- All inputs to operators in this document are values in the CBOR data model (RFC 8949 Section 2).
- Implementations MUST map internal language/runtime structures to this model without semantic loss before encoding/validation.

---
## 2) System Model
### I.A Persistent State
- `profile_rules`.
### I.B Inputs and Hyperparameters
- `typed_object` is a value in the CBOR data model (RFC 8949 Section 2), constrained by consuming schema rules.
- profile id.
### I.C Constraints and Feasible Set
- valid iff object can be encoded under all canonical constraints.
- input maps MUST be duplicate-free by key semantics before encoding.
### I.D Transient Variables
- serializer buffers and diagnostics.
### I.E Invariants and Assertions
- stable bytes for identical object semantics.

### II.F Canonical Rules (Normative)
- RFC 8949 canonical CBOR baseline with profile overrides below.
- Additional restrictions:
  - map keys must be UTF-8 strings,
  - encoder MUST NOT normalize Unicode (no NFC/NFD transformation step is applied by canonicalization),
  - where a consuming contract requires NFC validity, non-NFC strings MUST be rejected deterministically by that consuming contract before commitment/hashing,
  - string keys are compared and encoded as raw UTF-8 bytes of the provided code-point sequence,
  - map-key ordering MUST follow canonical encoded-key byte ordering (RFC 8949 canonical ordering),
  - integers (positive and negative) MUST be encoded in the shortest possible canonical form,
  - integer shortest-form examples: `0 -> 0x00`, `23 -> 0x17`, `24 -> 0x1818`, `-1 -> 0x20`,
  - disallow duplicate keys,
  - if input contains duplicate map keys, encoder MUST return deterministic contract-violation error,
  - forbid indefinite-length encodings for strings/arrays/maps,
  - text strings MUST be valid UTF-8; encoder SHALL reject invalid UTF-8 sequences,
  - length of definite-length byte strings and text strings MUST use shortest possible canonical form,
  - length of definite-length arrays and maps MUST use shortest possible canonical form,
  - byte strings MUST be encoded as definite-length major type 2,
  - simple values MUST encode canonically as `false -> 0xf4`, `true -> 0xf5`, `null -> 0xf6`,
  - simple values other than `false`, `true`, `null` are forbidden unless explicitly allowed by schema; when allowed they MUST use canonical single-byte encoding,
  - `null` SHALL appear only when explicitly allowed by schema; otherwise optional fields are omitted,
  - forbid CBOR tags unless explicitly enumerated by consuming schema,
  - if input contains a tag not explicitly allowed by the consuming schema, encoder MUST return deterministic contract-violation error,
  - when a tag is permitted, it MUST use shortest canonical tag encoding (examples: tag 1 -> `0xc1`, tag 23 -> `0xd7`, tag 24 -> `0xd818`),
  - bignums are forbidden by default; if schema explicitly permits tags 2/3, they MUST use shortest canonical tag encoding and definite-length canonical byte strings with no leading zero bytes in the absolute-value representation,
  - floating-point values are encoded as IEEE-754 binary64 (major type 7, additional info 27, then 8 bytes network order),
  - `+Infinity` canonical bits: `0x7ff0000000000000`,
  - `-Infinity` canonical bits: `0xfff0000000000000`,
  - `NaN` canonical bits: `0x7ff8000000000000` (quiet NaN, zero payload); all other NaN payload bit patterns are forbidden,
  - every float is encoded as binary64 regardless of usage context,
  - signed zero is preserved (`+0.0 -> 0x0000000000000000`, `-0.0 -> 0x8000000000000000`),
  - fixed-length digest fields (`bytes32`, `bytes64`) must match required lengths,
  - encoder SHALL validate fixed-length byte fields (e.g., `bytes32`, `bytes64`) and fail deterministically on length mismatch,
  - optional fields absent are encoded by key omission (never implicit `null`),
  - empty map MUST encode as `0xa0`,
  - nonconformant CBOR is a deterministic `CONTRACT_VIOLATION`.

### II.G Commitment Rule (Normative)
- All signatures and commitment hashes MUST use:
  - `SHA-256(CBOR_CANONICAL(commit_array))`
- `commit_array` is always a CBOR array of exactly two elements:
  - element 0: domain-separation tag,
  - element 1: committed data object.
- Domain-separation tag MUST be the first element of `commit_array`.
- If the committed data object is itself an array, it remains nested as element 1 (no flattening).
- Domain-separation tag is a CBOR data item defined by the higher-level protocol using this profile (commonly integer or byte string), and it MUST itself follow all canonical rules in this document.

### II.H Conformance Vectors (Normative)
- Implementations MUST pass canonicalization vectors for key ordering, integer shortest-form encoding, float consistency, simple-value encoding, and optional-field semantics.
- Minimum required vectors:
  - mixed key lengths and UTF-8 multibyte keys,
  - nested maps with independently canonicalized key ordering,
  - integer shortest-form cases (e.g., `0`, `23`, `24`, `255`, `256`, `-1`, `-24`, `-25`),
  - float binary64 encoding stability,
  - float special values (`+Infinity`, `-Infinity`, canonical `NaN`) and rejection of non-canonical NaN payloads,
  - signed zero cases (`+0.0` vs `-0.0`),
  - simple values canonical bytes (`false`, `true`, `null`),
  - optional field omission vs explicit `null` when schema allows null,
  - tag shortest-form encoding and bignum allow/deny behavior,
  - empty map encoding (`0xa0`),
  - commitment-array two-element structure (`[domain_tag, data_object]`) without array flattening.
  - duplicate-key detection and deterministic rejection,
  - invalid UTF-8 text string rejection.

---
## 3) Initialization
1. Load profile rules.
2. Validate encoder/decoder implementation.
3. Initialize deterministic buffer policy.

---
## 4) Operator Manifest
- `UML_OS.Serialization.EncodeCanonicalCBOR_v1`
- `UML_OS.Serialization.ValidateCanonicalCBOR_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Serialization.EncodeCanonicalCBOR_v1`  
**Category:** Serialization  
**Signature:** `(typed_object -> canonical_bytes)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** produces canonical CBOR bytes under profile rules.

**Operator:** `UML_OS.Serialization.ValidateCanonicalCBOR_v1`  
**Category:** Serialization  
**Signature:** `(typed_object, canonical_bytes -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates encoding equivalence and canonical constraints.
**Validation requirements:** MUST reject duplicate map keys and report deterministic violation diagnostics.
**Validation semantics:** decodes `canonical_bytes` under this profile, checks semantic equality with `typed_object` using CBOR-data-model identity rules (including distinctions for signed zero, NaN bit patterns, and integer-vs-float number types), and verifies all canonical constraints (ordering, definite lengths, shortest-form integers/tags, special-value rules).
**Validation report schema (minimum):**
```yaml
validation_report:
  valid: bool
  errors: [string]   # deterministic order
```
**Validation error signaling rule:** validation failures are communicated through `validation_report` (`valid=false`, non-empty `errors`). Implementations should avoid throwing exceptions for canonical violations unless the host runtime requires it.

---
## 6) Procedure
```text
1. Call EncodeCanonicalCBOR_v1 on typed_object; return canonical_bytes on success.
2. Optionally call ValidateCanonicalCBOR_v1(typed_object, canonical_bytes) when validation evidence is required.
3. If validation is executed, return validation_report separately from canonical_bytes (operator outputs remain independent per Section 0.I).
```

---
## 7) Trace & Metrics
### Logging rule
- Serialization emits deterministic validation diagnostics.
### Trace schema
- `run_header`: profile_version
- `iter`: object_id, status
- `run_end`: canonical_hash
### Metric schema
- `encoded_objects`, `canonical_failures`
### Comparability guarantee
- Comparable iff profile version is identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- canonical constraints enforced without exceptions.
#### VII.B Operator test vectors (mandatory)
- map ordering, integer shortest-form, float/signed-zero, tag/bignum policy, duplicate-key rejection, optional-absence vectors.
#### VII.C Golden traces (mandatory)
- golden canonical byte snapshots.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for canonical bytes and hash outputs.
#### VIII.B Allowed refactor categories
- implementation refactors preserving byte output.
#### VIII.C Equivalence test procedure (mandatory)
- byte-for-byte compare against golden vectors.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- profile id and serializer implementation hash.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- identical canonical bytes after restore.

FILE: layer1-foundation/Data-Structures.md
==========================================
# UML_OS Data Structure Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.DataStructureContract_v1`  
**Purpose (1 sentence):** Define deterministic canonical runtime data structures for kernel, model IR, TMMU, data, and DP modules.  
**Spec Version:** `UML_OS.Implementation.DataStructureContract_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Type/layout specification for interoperable deterministic execution.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.DataStructureContract_v1`
- **Purpose (1 sentence):** Canonical data-structure definitions.
- **Spec Version:** `UML_OS.Implementation.DataStructureContract_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Runtime type contracts.

### 0.A Objective Semantics
- This contract defines canonical structure schemas and validation rules (not an optimization objective).
- Primary guarantee: exact type/field consistency across modules.
- Scope split (normative):
  - **Schema layer:** declaration language and schema-registry validation.
  - **Instance layer:** validation and canonical serialization of runtime data records against declared schemas.

### 0.B Reproducibility Contract
- Seed space/PRNG inherited by consuming operators.
- Randomness locality: none in structure contract.
- Replay guarantee: structure version + canonical schema hash sufficient for replay compatibility.
- `replay_token` is constrained in this contract as opaque `bytes32`; generation is defined by replay/runtime contracts.
- Hash primitive for all `bytes32` commitment fields in this document is `SHA-256` over canonical CBOR preimages unless a field definition explicitly overrides it.

### 0.C Numeric Policy
- Numeric scalar kinds are explicit (`uint64`, `float64`, etc.).
- NaN/Inf allowances must be declared by consuming operator.
- Approx-equality: N/A (schema exactness).

### 0.D Ordering and Tie-Break Policy
- Field ordering is canonical and deterministic.
- Map-like structures require sorted key serialization.

### 0.E Parallel, Concurrency, and Reduction Policy
- Structure validation is deterministic and side-effect free.

### 0.F Environment and Dependency Policy
- Reference runtime: any deterministic schema validator.
- Determinism level: `BITWISE` for serialized schema hash.

### 0.G Operator Manifest
- `UML_OS.Implementation.ValidateSchemaDecl_v1`
- `UML_OS.Implementation.ValidateInstance_v1`
- `UML_OS.Implementation.ValidateStruct_v1`
- `UML_OS.Implementation.SerializeCanonical_v1`
- `UML_OS.Implementation.ComputeStructHash_v1`
- `UML_OS.Error.Emit_v1`
- Compatibility note: `UML_OS.Implementation.ValidateStruct_v1` is a compat alias to schema validation.

### 0.H Namespacing and Packaging
- Structure names are namespaced by subsystem.

### 0.I Outputs and Metric Schema
- Outputs:
  - schema path: `(schema_validation_report, schema_canonical_bytes, schema_hash)`
  - instance path: `(instance_validation_report, instance_canonical_bytes, instance_hash)`
- Metrics: `struct_count`, `field_count`, `violations`.
- Completion status: `success | failed`.

### 0.J Spec Lifecycle Governance
- Breaking field deletion/rename/type change => MAJOR.
- Additive backward-compatible field => MINOR.
- Structure evolution policy: compatibility decisions are made at this contract version level; per-structure `StructDecl.version` is metadata for migrations and tooling.

### 0.K Failure and Error Semantics
- Abort-only; deterministic failure records.

### 0.L Input/Data Provenance
- Schema source must be version-tagged and hashable.

---

### 0.Z EQC Mandatory Declarations Addendum
- Seed/PRNG declarations: N/A in this contract (inherited from consuming operators).
- Numeric-kernel/transcendental declarations: N/A in this contract (inherited from consuming operators).
- Determinism declaration: BITWISE for canonical bytes/hash outputs in this contract.
- Error-trace declaration: inherited from `Error-Codes.md` and consuming operators.
- Scope declaration: this document is limited to structure typing, canonical serialization, and deterministic validation.

## 2) System Model

### I.A Persistent State
- `struct_registry: map<name, schema>`.

### I.B Inputs and Hyperparameters
- canonical structure declarations.

### I.C Constraints and Feasible Set
- Unconstrained, validity defined by exact schema rules.

### I.D Transient Variables
- validation diagnostics.

### I.E Invariants and Assertions
- unique structure names and stable field ordering.

### II.E Structure Declaration Language (Normative)
- Canonical declaration meta-model:
  - `StructDecl = {struct_name:string, version:string, fields:array<FieldDecl>, required_fields:array<string>, allow_additional_fields:bool}`
  - `FieldDecl = {name:string, type:string, required:bool, default?:diagnostics_scalar, constraints?:map<string,string>}`
- Type grammar (closed set for this contract):
  - primitive: `uint32|uint64|int64|float64|bool|string|bytes|bytes32|bytes64`
  - composed: `array<T> | map<string,T> | enum(...)`
- `diagnostics_scalar = bool|int64|uint64|float64|string|bytes`
- Enum representation rule:
  - `enum(...)` values are serialized as UTF-8 strings equal to the declared symbol names.
  - allowed symbols are exactly those listed inside `enum(...)` (or explicitly referenced by external enum contract).
- Validation rules:
  - each `required_fields` entry MUST match a declared field name,
  - per-field `required` is normative for instance-validation requiredness; `required_fields` is metadata and MUST equal the set of fields with `required=true`,
  - unknown type tokens are invalid,
  - when `allow_additional_fields=false`, undeclared fields are invalid,
  - default compatibility checks:
    - numeric primitive defaults MUST be representable in the declared numeric type/range,
    - `bytes32`/`bytes64` defaults MUST have exact required length,
    - `enum(...)` defaults MUST match a declared symbol,
    - fields with composed types (`array<T>`, `map<string,T>`) MUST NOT declare defaults.
- Instance validation rule:
  - every instance validation MUST identify the target `StructDecl.struct_name` + `version` and validate required fields/types/constraints against that declaration.
- Optionality encoding rule:
  - `FieldDecl.required` is the sole optionality indicator.
  - absent optional fields MUST be omitted (not encoded as `null`).
  - backward-compat declarations using `optional<T>` type aliases MUST be normalized to `required=false` + base type `T`; conflicting declarations are invalid.
- Default semantics:
  - `FieldDecl.default` MAY be applied by instantiation tooling for convenience.
  - validators and canonical serializers MUST NOT auto-materialize omitted fields from defaults in commitment paths.
- Constraints semantics:
  - `constraints` defaults to empty map when omitted.
  - recognized keys are schema-defined validation keys (for example `min`, `max`, `regex`, `max_len`); unknown keys are invalid unless explicitly allowed by consuming mode.

### II.F Concrete Structure Layouts
- Operator-level enums (`purity_class`, `side_effect`) are authoritative in `docs/layer1-foundation/Operator-Registry-Schema.md` and `docs/layer1-foundation/API-Interfaces.md` and are intentionally not redefined here.
- `privacy_class = PUBLIC | INTERNAL | CONFIDENTIAL`
- `redaction_mode = NONE | HMAC_SHA256_V1`
- `metric_aggregation = sum | mean | min | max | quantile`
- `TraceIterRecord` (CBOR map): `{kind:"ITER", t:uint64, stage_id:string, operator_id:string, operator_seq:uint64, rank:uint32, status:string, replay_token:bytes32, rng_offset_before?:uint64, rng_offset_after?:uint64, dp_accountant_state_hash?:bytes32, sampler_config_hash?:bytes32, tmmu_plan_hash?:bytes32, determinism_profile_hash?:bytes32, state_fp?:bytes32, functional_fp?:bytes32, trace_extensions?:map<string,diagnostics_scalar>, privacy_class:privacy_class}`.
- `TraceRunHeader`: `{kind:"RUN_HEADER", schema_version:string, tenant_id:string, run_id:string, replay_token:bytes32, task_type:string, world_size:uint32, backend_binary_hash:bytes32, driver_runtime_fingerprint_hash:bytes32, policy_bundle_hash:bytes32, monitor_policy_hash:bytes32, operator_contracts_root_hash:bytes32, policy_gate_hash?:bytes32, authz_decision_hash?:bytes32, redaction_mode:redaction_mode, redaction_key_id?:string, redaction_policy_hash?:bytes32, hash_gate_M:uint64, hash_gate_K:uint64}`.
  - `hash_gate_M`/`hash_gate_K` define deterministic hash-gated trace sampling parameters; invariant `0 < M` and `0 <= K <= M`.
  - `H` is the unsigned big-endian integer interpretation of `SHA-256(CBOR_CANONICAL([replay_token, t, operator_seq, rank]))`.
- `TracePolicyGateVerdictRecord`: `{kind:"POLICY_GATE_VERDICT", t:uint64, policy_gate_hash:bytes32, transcript_hash:bytes32}`.
- `TraceCheckpointCommitRecord`: `{kind:"CHECKPOINT_COMMIT", t:uint64, checkpoint_hash:bytes32, checkpoint_header_hash:bytes32, checkpoint_merkle_root:bytes32, trace_snapshot_hash:bytes32}`.
- `TraceCertificateInputsRecord`: `{kind:"CERTIFICATE_INPUTS", t:uint64, certificate_inputs_hash:bytes32}`.
- `TraceRunEndRecord`: `{kind:"RUN_END", status:string, final_state_fp:bytes32, trace_final_hash:bytes32}`.
- `TraceErrorRecord`: `{kind:"ERROR", t:uint64, rank:uint32, failure_code:string, failure_operator:string, replay_token:bytes32, diagnostics_hash:bytes32}`.
- `TraceRecord`: tagged union of `TraceRunHeader` + `TraceIterRecord` + `TracePolicyGateVerdictRecord` + `TraceCheckpointCommitRecord` + `TraceCertificateInputsRecord` + `TraceRunEndRecord` + `TraceErrorRecord`.
- `CheckpointHeader`: `{tenant_id:string, run_id:string, spec_version:string, replay_token:bytes32, t:uint64, manifest_hash:bytes32, ir_hash:bytes32, trace_final_hash:bytes32, sampler_config_hash:bytes32, data_access_plan_hash?:bytes32, tmmu_plan_hash:bytes32, backend_binary_hash:bytes32, checkpoint_merkle_root:bytes32, checkpoint_header_hash:bytes32, checkpoint_manifest_hash:bytes32, checkpoint_hash:bytes32, policy_bundle_hash:bytes32, determinism_profile_hash:bytes32, lockfile_hash:bytes32, toolchain_hash:bytes32, dependencies_lock_hash:bytes32, operator_contracts_root_hash:bytes32, runtime_env_hash:bytes32, code_commit_hash:bytes32, lineage_root_hash:bytes32, tensors_root_hash:bytes32, optimizer_state_root_hash:bytes32, dp_accountant_state_hash?:bytes32}`.
- `ErrorRecord`: `{code_id:string, numeric_code:uint32, severity:enum(FATAL|ERROR|WARN), subsystem:string, t:uint64, rank:uint32, failure_operator:string, replay_token:bytes32, message:string, retryable:bool, diagnostics?:map<string,diagnostics_scalar>, privacy_class:privacy_class}`.
- `diagnostics` scalar contract (normative):
  - allowed scalar leaves are `bool|int64|uint64|float64|string|bytes`,
  - `float64` values in diagnostics MUST be finite (`NaN/Inf` forbidden),
  - keys are UTF-8 strings and MUST be unique.
- `MonitorEvent`: `{tenant_id:string, run_id:string, model_version_id:string, window_id:string, metric_name:string, metric_value:float64, privacy_class:privacy_class}`.
- `MetricSchema`: `{metric_name:string, scalar_type:enum(float64|int64|bool|string), aggregation:metric_aggregation, quantile_p?:float64, window_policy:string, privacy_class:privacy_class}`.
  - `quantile_p` is required iff `aggregation=quantile` and MUST satisfy `0 < quantile_p <= 1`.
- `PipelineTransitionRecord`: `{tenant_id:string, job_id:string, attempt_id:uint32, transition_seq:uint64, idempotency_key:bytes32, from_state:string, to_state:string, status:string, diagnostics?:map<string,diagnostics_scalar>}`.
- `ResourceLedgerRecord`: `{tenant_id:string, run_id:string, t:uint64, bytes_allocated:uint64, peak_bytes:uint64, io_bytes_read:uint64, io_bytes_written:uint64, gpu_time_ms:uint64, cpu_time_ms:uint64, quota_decision:string, quota_policy_hash:bytes32}`.
- Scope partitioning:
  - **Core structure set (required):** `Trace*Record`, `CheckpointHeader`, `ErrorRecord`, `StructDecl`, `FieldDecl`.
  - **Extension structure set (optional modules):** `MonitorEvent`, `MetricSchema`, `PipelineTransitionRecord`, `ResourceLedgerRecord`.
  - If extension structures are used, they are contract-bound by this same canonical serialization profile.
- Alignment policy for binary layouts: applies to in-memory/native struct layouts only; it does not affect canonical CBOR wire encoding. Fields should align to natural size for native runtime efficiency; packed representation is forbidden for cross-language in-memory ABI payloads.
- Registry format (normative): `struct_registry: map<string, StructDecl>`; `ValidateSchemaDecl_v1` validates declarations against this meta-model.
- Checkpoint hash preimage rule (normative):
  - `checkpoint_header_hash = SHA-256(CBOR_CANONICAL(CheckpointHeader excluding fields {checkpoint_header_hash, checkpoint_hash}))`
  - `checkpoint_hash = SHA-256(CBOR_CANONICAL(["checkpoint_commit_v1", checkpoint_header_hash, checkpoint_manifest_hash, checkpoint_merkle_root]))`
  - Stored `checkpoint_header_hash` and `checkpoint_hash` are derived outputs, never recursive inputs.

### II.G Canonical Serialization v1 (Normative)
- All contract-critical hashes/signatures must be computed over canonical CBOR bytes only.
- Serialization domains:
  - **Schema serialization:** canonical CBOR of `StructDecl` / registry objects.
  - **Instance serialization:** canonical CBOR of runtime records conforming to a declared `StructDecl`.
- Canonicalization rules:
  - map keys ordered by `(len(CBOR_ENCODE(key)), CBOR_ENCODE(key))` as defined in `docs/layer1-foundation/Canonical-CBOR-Profile.md`,
  - integers encoded in shortest canonical form,
  - signed fields must encode floats as IEEE-754 binary64 only,
  - `NaN` and `Inf` are forbidden in signed/hash-critical payloads unless explicitly normalized by operator contract,
  - strings must be valid UTF-8; non-NFC forms are invalid for signed payloads when the consuming contract requires NFC validity,
  - fixed-length digests (`bytes32`) must be exactly 32 bytes.
- Domain separation labels (for chained hashes/signatures) must be explicit CBOR string tags in the hashed tuple.
- Redaction determinism rule:
  - redaction is applied before canonical serialization when enabled by consuming contracts,
  - redacted values MUST be deterministic transforms defined by `redaction_mode`/policy (e.g., keyed HMAC digest replacement),
  - resulting redacted structure is the committed/serialized payload.

### II.H Replay Token Binding (Normative in this contract)
- `replay_token` type is `bytes32`.
- Inclusion rule: when a structure includes `replay_token`, it MUST be present and serialized exactly as 32-byte CBOR byte string.
- Generation rule is defined in `docs/layer2-specs/Replay-Determinism.md`; this document does not redefine token derivation.

---

## 3) Initialization

1. Load structure declarations.
2. Canonicalize field order.
3. Build registry.

---

## 4) Operator Manifest

- `UML_OS.Implementation.ValidateSchemaDecl_v1`
- `UML_OS.Implementation.ValidateInstance_v1`
- `UML_OS.Implementation.ValidateStruct_v1`
- `UML_OS.Implementation.SerializeCanonical_v1`
- `UML_OS.Implementation.ComputeStructHash_v1`
- `UML_OS.Error.Emit_v1`
- Compatibility note: `UML_OS.Implementation.ValidateStruct_v1` aliases `UML_OS.Implementation.ValidateSchemaDecl_v1`.

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

**Operator:** `UML_OS.Implementation.ValidateStruct_v1`  
**Category:** IO  
**Signature:** `(registry -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** compatibility alias for `UML_OS.Implementation.ValidateSchemaDecl_v1`.  
**Preconditions / Postconditions:** registry loaded.  
**Edge cases:** optional fields and nested maps.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** N/A.  
**Complexity note:** O(total_fields).  
**Failure behavior:** deterministic schema failures.  
**Dependencies:** canonical schema parser.  
**Test vectors:** valid/invalid schema fixtures.

**Operator:** `UML_OS.Implementation.ValidateSchemaDecl_v1`  
**Category:** IO  
**Signature:** `(registry -> schema_validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates schema declarations (`StructDecl`/`FieldDecl`) and registry invariants.  
**Preconditions / Postconditions:** registry loaded.  
**Edge cases:** optional fields and nested maps.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** N/A.  
**Complexity note:** O(total_fields).  
**Failure behavior:** deterministic schema failures.  
**Dependencies:** canonical schema parser.  
**Test vectors:** valid/invalid schema fixtures.

**Operator:** `UML_OS.Implementation.ValidateInstance_v1`  
**Category:** IO  
**Signature:** `(instance, struct_name, struct_version, registry -> instance_validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates runtime instance payload against a declared schema in the registry.
**Preconditions / Postconditions:** target schema exists and is valid.
**Edge cases:** optional-field omission, unknown fields, constraint violations.
**Numerical considerations:** finite-float checks where required by target schema.
**Ordering/tie handling:** N/A.
**Complexity note:** O(instance_fields + schema_fields).
**Failure behavior:** deterministic validation failure with stable diagnostics.
**Dependencies:** canonical schema parser.
**Test vectors:** valid/invalid instance fixtures.

**Operator:** `UML_OS.Implementation.SerializeCanonical_v1`  
**Category:** IO  
**Signature:** `(object -> canonical_bytes)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** deterministic canonical encoding for hashing and checkpointing (schema objects or runtime instances).  
**Preconditions / Postconditions:** input object validated in its domain (schema or instance).  
**Edge cases:** empty registry/object.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** sorted names then fields.  
**Complexity note:** O(object_size).  
**Failure behavior:** abort on serialization mismatch.  
**Dependencies:** serializer backend.  
**Test vectors:** golden serialized bytes.

**Operator:** `UML_OS.Implementation.ComputeStructHash_v1`  
**Category:** IO  
**Signature:** `(canonical_bytes -> hash)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** computes deterministic structure hash.  
**Preconditions / Postconditions:** canonical bytes only.  
**Edge cases:** zero-length bytes.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** N/A.  
**Complexity note:** O(bytes).  
**Failure behavior:** abort on hash failure.  
**Dependencies:** hash function.  
**Test vectors:** fixed byte->hash vectors.

---

## 6) Procedure

```text
Schema path:
1. ValidateSchemaDecl_v1(registry)
2. SerializeCanonical_v1(registry)
3. ComputeStructHash_v1(schema_canonical_bytes)
4. Return schema_validation_report + schema_canonical_bytes + schema_hash

Instance path:
1. ValidateInstance_v1(instance, struct_name, struct_version, registry)
2. SerializeCanonical_v1(instance)
3. ComputeStructHash_v1(instance_canonical_bytes)
4. Return instance_validation_report + instance_canonical_bytes + instance_hash
```

---

## 7) Trace & Metrics

### Logging rule
Emit deterministic structure validation and hash records.

### Trace schema
- `run_header`: `TraceRunHeader`
- `iter`: `TraceIterRecord` (and optional typed records from `TraceRecord` union)
- `run_end`: `TraceRunEndRecord`
- `error`: `TraceErrorRecord`

### Metric schema
- `struct_count`, `field_count`, `violations`

### Comparability guarantee
Comparable iff schema definitions and canonical serializer are identical.

---

## 8) Validation

#### A. Lint rules (mandatory)
Passes determinism, completeness, ordering, no hidden globals.

#### B. Operator test vectors (mandatory)
Schema fixtures and canonical serialization vectors.
- Minimum vector classes:
  - optional-field omission vs explicit null (when schema permits),
  - duplicate-key rejection,
  - finite/non-finite diagnostics scalar checks,
  - checkpoint hash derivation preimage exclusion (`checkpoint_header_hash`, `checkpoint_hash`),
  - trace extension map canonical ordering.

#### C. Golden traces (mandatory)
Golden hashes for canonical registries.
- Authoritative vector index: `docs/layer3-tests/Test-Vectors-Catalog.md`.
- Missing or stale vectors are a contract violation for release builds.

---

## 9) Refactor & Equivalence

#### A. Equivalence levels
- E0 required.
- `E0` means byte-identical canonical bytes and identical hash outputs for identical logical structure declarations (aligned with `docs/layer2-specs/Replay-Determinism.md`).

#### B. Allowed refactor categories
- Parser/serializer refactor with identical bytes/hash output.

#### C. Equivalence test procedure (mandatory)
Compare report and final hash exactly.

---

## 10) Checkpoint/Restore

### Checkpoint contents
- canonical schema bytes + hash.

### Serialization
- deterministic canonical CBOR.

### Restore semantics
- identical restored registry and hash.

### Normative dependencies
- `docs/layer1-foundation/Canonical-CBOR-Profile.md`
- `docs/layer1-foundation/Error-Codes.md`
- `docs/layer1-foundation/Operator-Registry-Schema.md`
- `docs/layer1-foundation/API-Interfaces.md`
- `docs/layer2-specs/Replay-Determinism.md`
- `docs/layer3-tests/Test-Vectors-Catalog.md`
- Release gate: all normative dependency documents above MUST exist in the same versioned artifact bundle for conformance.

### Embedded example fixture (illustrative, non-authoritative)
```yaml
StructDecl:
  struct_name: "ExampleRecord"
  version: "v1"
  fields:
    - { name: "id", type: "string", required: true }
    - { name: "count", type: "uint64", required: false, default: 0 }
  required_fields: ["id"]
  allow_additional_fields: false
```

FILE: layer1-foundation/Dependency-Lock-Policy.md
=================================================
# UML_OS Dependency Lock Policy
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.DependencyLockPolicy_v1`
**Purpose (1 sentence):** Define deterministic dependency pinning, lock validation, artifact integrity verification, and upgrade-governance semantics for reproducible builds and runs.
**Spec Version:** `UML_OS.Implementation.DependencyLockPolicy_v1` | 2026-02-19 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Build/runtime dependency control.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.DependencyLockPolicy_v1`
- **Purpose (1 sentence):** Deterministic dependency governance.
- **Spec Version:** `UML_OS.Implementation.DependencyLockPolicy_v1` | 2026-02-19 | Authors: Olejar Damir
- **Domain / Problem Class:** Reproducible dependency management.

### 0.A Objective Semantics
- This contract performs deterministic validation and policy evaluation; it is not an optimization algorithm.
- Diagnostic primary metric tuple: `(hash_mismatches:uint64, policy_violations:uint64)`.
- Primary comparison rule: exact lock/schema/policy conformance and exact digest equality.

### 0.B Reproducibility Contract
- Replayable given `(lockfile_blob, policy_blob, artifact_index_blob, sbom_hash, toolchain_hash, runtime_env_hash)`.
- `toolchain_hash` and `runtime_env_hash` are replay inputs.
- `dependencies_lock_hash` is derived output: `SHA-256(CBOR_CANONICAL(["deps_lock_v1", lockfile_hash, toolchain_hash, runtime_env_hash, sbom_hash]))`.
- Artifact verification replay requires content-addressed immutable artifact retrieval from `artifact_index_blob` locations; this store assumption is part of runtime environment reproducibility (anchored by `runtime_env_hash`).

### 0.C Numeric Policy
- This section also defines deterministic version-comparison behavior for dependency governance.
- Semantic version parsing MUST follow SemVer 2.0.0 for valid SemVer strings.
- Non-SemVer version strings MUST be compared as raw UTF-8 strings in bytewise lexicographic order.
- Upgrade-comparison mixed-scheme rule: if one side is SemVer and the other is non-SemVer, the change is invalid (`VERSION_SCHEME_MISMATCH`) unless a future policy version explicitly permits mixed-scheme comparison.

### 0.D Ordering and Tie-Break Policy
- Unless explicitly overridden, all string ordering uses ascending bytewise UTF-8 lexicographic order.
- Lock tuples are sorted by `(name, version, source)`.
- Deterministic report ordering is mandatory for all emitted arrays (defined per schema below).

### 0.E Parallel, Concurrency, and Reduction Policy
- Validation and artifact checks MAY run in parallel.
- Parallel merge rule:
  - overall validity = logical-AND of all partial validity flags,
  - partial lists are concatenated and then globally sorted by their normative order keys before emission,
  - trace `iter` records MUST be emitted in global sorted package/check order independent of execution scheduling.

### 0.F Environment and Dependency Policy
- Determinism target for contract-critical outputs (`lock_verdict`, `dependencies_lock_hash`, trace commitments) is `E0`.

### 0.G Operator Manifest
- `UML_OS.DepLock.ValidateLockfile_v1`
- `UML_OS.DepLock.VerifyArtifactHashes_v1`
- `UML_OS.DepLock.EvaluateUpgradeRequest_v1`
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- Operators are fully-qualified and versioned.
- Canonical lock-policy location: `contracts/dependency_lock_policy.cbor`.

### 0.I Outputs and Metric Schema
- Outputs: `(lock_verdict, upgrade_report?)`.
- `lock_verdict` schema:
  - `is_valid_lock:bool`
  - `is_artifact_integrity_valid:bool`
  - `lockfile_hash:bytes32`
  - `dependencies_lock_hash:bytes32`
  - `policy_bundle_hash:bytes32`
  - `validation_report:LockValidationReport`
  - `verification_report:ArtifactVerificationReport`
- Metric schema:
  - `packages_total:uint64`
  - `hash_mismatches:uint64`
  - `policy_violations:uint64`

### 0.J Spec Lifecycle Governance
- Any normative schema/rule/ordering change requires version bump and migration notes.
- Policy version MUST be included in `policy_bundle_hash` input.

### 0.K Failure and Error Semantics
- Deterministic abort conditions:
  - malformed lockfile (`LOCKFILE_PARSE_ERROR`),
  - malformed policy (`POLICY_SCHEMA_ERROR`),
  - malformed artifact index (`ARTIFACT_INDEX_SCHEMA_ERROR`),
  - forbidden dependency source (`FORBIDDEN_SOURCE`),
  - unresolved required artifact (`ARTIFACT_MISSING`),
  - digest mismatch (`ARTIFACT_HASH_MISMATCH`),
  - missing required toolchain/runtime inputs (`INPUT_MISSING`),
  - checkpoint lockfile mismatch on restore (`LOCKFILE_MISMATCH`),
  - checkpoint policy mismatch on restore (`POLICY_BUNDLE_MISMATCH`),
  - checkpoint artifact-index mismatch on restore (`ARTIFACT_INDEX_MISMATCH`),
  - checkpoint SBOM mismatch on restore (`SBOM_HASH_MISMATCH`),
  - checkpoint toolchain hash mismatch on restore (`TOOLCHAIN_HASH_MISMATCH`),
  - checkpoint runtime environment hash mismatch on restore (`RUNTIME_ENV_HASH_MISMATCH`).
- On abort, emit `UML_OS.Error.Emit_v1` with deterministic `CONTRACT_VIOLATION` payload containing one canonical code above and stop.

### 0.L Input/Data Provenance
- Lockfile source and artifact provenance are mandatory.
- Policy and artifact index blobs MUST be content-addressable and hash-pinned.

---
### 0.Z EQC Mandatory Declarations Addendum
- Contract class: deterministic; stochastic declarations are N/A.
- Floating-point tolerance declarations are N/A for critical verdict computation.
- Error trace rule: final failure record includes `step_index:uint64`, `failure_code`, `failure_operator`, and minimal deterministic diagnostics.
- `step_index` is the 0-based index of the failed step in Section 6 Procedure (step 1 -> index 0, ..., step 8 -> index 7).
- Recovery policy: deterministic abort-only unless explicitly declared by a future version.

---
## 2) System Model
### I.A Persistent State
- Approved lock policy registry.
- Approved artifact index schema version.

### I.B Inputs and Hyperparameters
- `lockfile_blob:bytes`
- `policy_blob:bytes`
- `artifact_index_blob:bytes`
- `sbom_hash:bytes32`
- `toolchain_hash:bytes32`
- `runtime_env_hash:bytes32`
- `upgrade_proposal_blob?:bytes`
- `strict_mode:bool` (from policy; MUST be explicit)

### I.C Constraints and Feasible Set
A run is feasible iff all of the following hold:
- lockfile parses under one supported format with canonical extraction rules,
- policy schema validates,
- artifact index schema validates,
- all required package entries are pinned and policy-compliant,
- all required artifacts are hash-verifiable,
- required external inputs (`sbom_hash`, `toolchain_hash`, `runtime_env_hash`) are provided.

### I.D Transient Variables
- `normalized_lock_entries:array<LockTuple>`
- `violations:array<Violation>`
- `mismatches:array<HashMismatch>`

### I.E Invariants and Assertions
- In strict mode, unlocked transitive dependencies are forbidden.
- Every resolved dependency in lock scope has exactly one normalized tuple.
- Every tuple in lock scope has exactly one effective integrity policy outcome.
- For any given `(name, source)` combination, there is at most one normalized tuple.

### II.F Normative Data Schemas
- Canonical serialization for all typed objects in this contract is canonical CBOR per `docs/layer1-foundation/Canonical-CBOR-Profile.md` and RFC 8949 deterministic encoding rules.

`LockTuple`:
- `name:tstr` (non-empty)
- `version:tstr` (non-empty)
- `source:tstr`
- `integrity_hash:bytes32`

`Policy` (exact fields; no extras):
- `policy_version:uint32` (>=1)
- `strict_mode:bool`
- `allowed_sources:array<tstr>` (sorted unique)
- `allow_direct_url_dependencies:bool` (MUST be `false` in v1)
- `allow_source_changes:bool` (MUST be `false` in v1)
- `allowed_upgrade_scopes:array<enum("patch","minor","major")>` (sorted unique)
- `gpu_runtime_pinning_required:bool`
- `determinism_env_var_allowlist:array<tstr>` (sorted unique)

`ArtifactIndex` (exact fields; no extras):
- `index_version:uint32` (>=1)
- `artifacts:array<ArtifactRecord>`

`ArtifactRecord` (exact fields; no extras):
- `name:tstr`
- `version:tstr`
- `source:tstr`
- `artifact_sha256:bytes32`
- `location:tstr` where `location` MUST be content-addressed (`sha256:<64-hex>` or equivalent content-addressed immutable URI). Non-content-addressed filesystem paths are forbidden in v1.
- runtime requirement: for identical `runtime_env_hash`, content-addressed `location` resolution MUST yield identical bytes.

`UpgradeProposal` (exact fields; no extras):
- `proposal_version:uint32` (>=1)
- `changes:array<UpgradeChange>`

`UpgradeChange`:
- `name:tstr`
- `from_version:tstr`
- `to_version:tstr`
- `source:tstr`

### II.G External Definitions Bound by Reference
- `runtime_env_hash` is the canonical environment commitment (`env_manifest_hash`) from `docs/layer1-foundation/Environment-Manifest.md`.
- Error payload structure and canonical codes are defined in `docs/layer1-foundation/Error-Codes.md`.
- `gpu_runtime_pinning_required` and `determinism_env_var_allowlist` are consumed by environment/deployment validation contracts; this lock-policy contract does not validate live GPU runtime state.

### II.H Normative Hashes and Canonicalization
`toolchain_hash`:
- Input is `toolchain_hash:bytes32` provided by caller.
- `toolchain_hash` is opaque for this contract; production/validation rules are defined by the producer contract that emits it.

`source` canonicalization (normative):
- Normalize source strings before tuple emission:
  - apply Unicode NFC normalization,
  - lowercase scheme and host components when URL-like,
  - `pypi`, `pypi.org`, `pypi.python.org`, `https://pypi.org`, `http://pypi.org/simple`, `https://pypi.org/simple/` map to `https://pypi.org/simple`,
  - if no mapping exists, keep source string unchanged after NFC normalization.
- `allowed_sources` comparison uses the canonicalized source string only.

`LockfileDigest_v1`:
- Parse lockfile into `LockTuple` entries using format-specific canonical rules:
  - `requirements.txt` with hashes:
    - comments MUST be whole-line comments only (first non-whitespace char is `#`); inline comments on requirement lines are invalid in v1,
    - trim whitespace, ignore empty/comment lines,
    - `--index-url` directives MUST appear on their own lines,
    - line continuations (trailing `\\`) are forbidden in v1 and make the lockfile invalid,
    - `--extra-index-url` and `--find-links` directives are forbidden in v1 and make the lockfile invalid,
    - editable installs (`-e`) and include directives (`-r`) are forbidden in v1 and make the lockfile invalid,
    - environment markers (`;` outside quoted strings) are forbidden in v1 and make the lockfile invalid,
    - source context is cumulative top-to-bottom: each `--index-url` directive applies to all subsequent requirement lines until overridden by a later `--index-url`,
    - process effective requirement lines containing `--hash=sha256:<hex>`,
    - extract package name as token before first version comparator (`==`, `>=`, `<=`, `~=`, `!=`, `<`, `>`),
    - strip extras suffix from package token (remove `[...]` and everything after `[`),
    - extract pinned version only when `==` is present; otherwise line is invalid in v1 strict lock mode,
    - source for a requirement line is the most recent prior in-file `--index-url`; if none, canonical PyPI source,
    - integrity hash is the first `sha256` hash token on the line.
    - hash token decoding rule (applies to all formats): token MUST match `sha256:<64-hex>` (case-insensitive `sha256` prefix, hex tail length exactly 64). Decode hex tail to `bytes32`; otherwise lockfile is invalid.
  - `poetry.lock`:
    - traverse `[[package]]` entries,
    - extract `name` and `version`,
    - source comes from package source URL if present else canonical PyPI source,
    - sort package file entries by `file` (bytewise UTF-8) then use the first available `sha256` token and decode per hash token decoding rule above; missing/invalid hash is invalid in v1 strict lock mode.
  - `uv.lock`:
    - traverse locked package records,
    - extract `name`, `version`, source/index URL (or canonical PyPI default),
    - integrity hash token is required and decoded per hash token decoding rule above; missing/invalid hash is invalid in v1 strict lock mode.
- Environment markers and extras policy (v1): include all locked entries exactly as lockfile declares; marker-conditioned activation is out of scope for this contract.
- Artifact-index coverage rule for markers/extras: artifact index MUST include entries for all lockfile tuples, including marker-conditioned entries.
- Sort tuples by `(name, version, source)` using bytewise UTF-8 lexicographic order.
- `lockfile_hash = SHA-256(CBOR_CANONICAL(sorted_lock_tuples))`.

`DependenciesLockDigest_v1`:
- `dependencies_lock_hash = SHA-256(CBOR_CANONICAL(["deps_lock_v1", lockfile_hash, toolchain_hash, runtime_env_hash, sbom_hash]))`.

`policy_bundle_hash`:
- `policy_bundle_hash = SHA-256(CBOR_CANONICAL(["policy_bundle_v1", policy_version, policy_blob]))`.

`artifact_index_hash`:
- `artifact_index_hash = SHA-256(CBOR_CANONICAL(artifact_index_blob))`.

### II.I Policy Rules
- Accepted lockfile formats:
  - `poetry.lock`
  - `requirements.txt` with required hash pins
  - `uv.lock`
- Registry/source rule:
  - dependency source MUST be in `allowed_sources`.
  - direct URL dependency definition (v1): any dependency source not equal to a canonical registry source string in `allowed_sources` is a direct URL dependency and is forbidden (`allow_direct_url_dependencies` MUST be false).
- SBOM rule:
  - `sbom_hash` MUST be provided as input and included in trace `run_header`.
  - `sbom_hash` contributes to `dependencies_lock_hash`; therefore it is part of reproducible verdict commitments, not trace-only metadata.
- GPU/runtime pinning note:
  - this contract carries policy fields but does not enforce runtime hardware/driver state.

---
## 3) Initialization
1. Decode and validate `policy_blob` and `artifact_index_blob` schemas.
2. Parse `lockfile_blob` into normalized `LockTuple` entries.
3. Build deterministic verification context (sorted tuples, source allowlist set, artifact lookup map).

---
## 4) Operator Manifest
- `UML_OS.DepLock.ValidateLockfile_v1`
- `UML_OS.DepLock.VerifyArtifactHashes_v1`
- `UML_OS.DepLock.EvaluateUpgradeRequest_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md`.

`LockValidationReport`:
- `is_valid:bool`
- `violations:array<Violation>` sorted by `(path, code)`

`Violation`:
- `path:tstr`
- `code:enum("LOCKFILE_PARSE_ERROR","POLICY_SCHEMA_ERROR","ARTIFACT_INDEX_SCHEMA_ERROR","FORBIDDEN_SOURCE","UNPINNED_DEPENDENCY","STRICT_MODE_VIOLATION","INPUT_MISSING","LOCKFILE_MISMATCH","POLICY_BUNDLE_MISMATCH","ARTIFACT_INDEX_MISMATCH","SBOM_HASH_MISMATCH","TOOLCHAIN_HASH_MISMATCH","RUNTIME_ENV_HASH_MISMATCH","VERSION_SCHEME_MISMATCH","PACKAGE_NOT_FOUND","PROPOSAL_VERSION_MISMATCH","EMPTY_VERSION","POLICY_CONTRACT_ERROR")`
- `message:tstr`
- `path` semantics:
  - package-specific violation: `path` is package name,
  - global violation: `path` is `GLOBAL`.

`ArtifactVerificationReport`:
- `is_valid:bool`
- `hash_mismatches:array<HashMismatch>` sorted by `(name, version, source)`
- `missing_artifacts:array<tstr>` sorted ascending
- each `missing_artifacts` entry MUST be `name + " " + version + " " + source`.

`HashMismatch`:
- `name:tstr`
- `version:tstr`
- `source:tstr`
- `expected_hash:bytes32`
- `observed_hash:bytes32`

`UpgradeReport`:
- `is_allowed:bool`
- `risk_class:enum("LOW","MEDIUM","HIGH","CRITICAL")`
- `disallowed_changes:array<UpgradeChange>` sorted by `(name, from_version, to_version, source)`
- `notes:array<tstr>` sorted ascending

**Operator:** `UML_OS.DepLock.ValidateLockfile_v1`
- **Category:** IO
- **Signature:** `(lockfile_blob:bytes, policy_blob:bytes -> lock_validation_report:LockValidationReport, lockfile_hash:bytes32, policy_bundle_hash:bytes32)`
- **Purity class:** PURE
- **Determinism:** deterministic
- **Definition:**
  - Validates policy schema before computing `policy_bundle_hash`.
  - Parses and normalizes lock entries.
  - Validates source allowlist and strict-mode invariants.
  - Validates required pins and policy constraints.
  - Returns deterministic sorted violations.

**Operator:** `UML_OS.DepLock.VerifyArtifactHashes_v1`
- **Category:** IO
- **Signature:** `(lockfile_blob:bytes, artifact_index_blob:bytes -> artifact_verification_report:ArtifactVerificationReport)`
- **Purity class:** IO
- **Determinism:** deterministic given immutable content-addressed artifact retrieval
- **Definition:**
  - Resolves each lock tuple against artifact index record by `(name, version, source)`.
  - Retrieves artifact bytes via immutable content-addressed `location`.
  - Computes SHA-256 over artifact bytes as `observed_hash`.
  - Sets `expected_hash` to the lock tuple `integrity_hash`.
  - If `observed_hash != expected_hash`, records a hash mismatch.
  - If artifact retrieval fails, records a missing artifact.
  - Records missing artifacts and mismatches deterministically.

**Operator:** `UML_OS.DepLock.EvaluateUpgradeRequest_v1`
- **Category:** IO
- **Signature:** `(current_lockfile_blob:bytes, proposal_blob:bytes, policy_blob:bytes -> upgrade_report:UpgradeReport)`
- **Purity class:** PURE
- **Determinism:** deterministic
- **Definition:**
  - Parses proposal changes.
  - If `changes` is empty, return `is_allowed=true`, `risk_class=LOW`, and empty `disallowed_changes`/`notes`.
  - Reject duplicate proposal changes by `(name, from_version, to_version, source)`.
  - Canonicalize each change `source` using the source canonicalization rules in Section II.H before comparisons.
  - For each change, find lock tuple by exact `(name, source)` match in current lock using canonicalized `source`.
  - If no tuple with matching `(name, source)` exists, change is disallowed (`PACKAGE_NOT_FOUND`).
  - If `from_version` or `to_version` is empty, change is disallowed (`EMPTY_VERSION`).
  - The matched tuple version MUST equal `from_version`; otherwise disallowed (`PROPOSAL_VERSION_MISMATCH`).
  - `UpgradeProposal` in v1 is delta-only for existing packages; additions/removals are out of scope and therefore disallowed.
  - If exactly one of `from_version` or `to_version` is valid SemVer 2.0.0, change is disallowed (`VERSION_SCHEME_MISMATCH`).
  - Source-change rule:
    - if `source` differs from current source and `allow_source_changes=false`, change is disallowed,
    - if `allow_source_changes=true`, new source MUST be in `allowed_sources`; otherwise disallowed.
  - Downgrade/no-op rule:
    - if `to_version == from_version` and source unchanged, change is a no-op and allowed,
    - if `to_version < from_version` according to version comparison policy in `0.C`, change is disallowed in v1.
  - SemVer pre-release/build metadata uses SemVer 2.0.0 precedence.
  - SemVer scope classification (when both versions are valid SemVer):
    - compare version core `(major.minor.patch)` ignoring pre-release/build metadata,
    - major differs -> `major`,
    - else minor differs -> `minor`,
    - else patch differs -> `patch`,
    - else same core with metadata-only change -> `patch`.
  - If both versions are non-SemVer, classify as `non_semver`.
  - Because policy `allowed_upgrade_scopes` excludes `non_semver` in v1, any `non_semver` change is automatically disallowed.
  - Applies `allowed_upgrade_scopes` policy.
  - Risk is the highest scope among all allowed changes with ranking `patch < minor < major = non_semver`; if any disallowed change exists, `risk_class = CRITICAL`.

---
## 6) Procedure
1. Run `ValidateLockfile_v1`.
2. If `lock_validation_report.is_valid=false`, emit deterministic `CONTRACT_VIOLATION` and abort.
3. Run `VerifyArtifactHashes_v1`.
4. If `artifact_verification_report.is_valid=false`, emit deterministic `CONTRACT_VIOLATION` and abort.
5. Form `dependencies_lock_hash` from `lockfile_hash` and provided inputs `toolchain_hash`, `runtime_env_hash`, and `sbom_hash`.
6. Include provided `sbom_hash` in trace commitments and dependency-lock commitment calculation.
7. Optionally run `EvaluateUpgradeRequest_v1` when proposal is provided.
8. Emit `lock_verdict` and optional `upgrade_report`.

---
## 7) Trace & Metrics
### Logging rule
- Every verification run emits deterministic trace records encoded in canonical CBOR.

### Trace schema
- `run_header`:
  - `lockfile_hash:bytes32`
  - `policy_bundle_hash:bytes32`
  - `artifact_index_hash:bytes32`
  - `sbom_hash:bytes32`
- `iter`:
  - `package_name:tstr`
  - `package_version:tstr`
  - `source:tstr`
  - `check:enum("SOURCE_POLICY","LOCK_PIN","ARTIFACT_HASH")`
  - `result:enum("PASS","FAIL")`
- `run_end`:
  - `status:enum("PASS","FAIL")`
  - `mismatch_summary:map{hash_mismatches:uint64, policy_violations:uint64, missing_artifacts:uint64}`

### Deterministic iter completeness
- For each package in sorted lock tuple order, always emit all three checks in fixed order `SOURCE_POLICY`, `LOCK_PIN`, `ARTIFACT_HASH`.
- `LOCK_PIN` definition: validate that the tuple has an integrity hash (`integrity_hash:bytes32`) compliant with v1 lock requirements; absence, malformed hash, or all-zero 32-byte hash yields `FAIL`.
- `ARTIFACT_HASH` definition:
  - `PASS` if artifact exists in index/store and computed SHA-256 equals expected hash,
  - `FAIL` if artifact exists but digest mismatches, or artifact is missing.

### Metric schema
- `packages_total:uint64`
- `hash_mismatches:uint64`
- `policy_violations:uint64`

### Comparability guarantee
- Full-output comparability (including `dependencies_lock_hash`) requires bytewise-identical `lockfile_hash`, `policy_bundle_hash`, `artifact_index_hash`, `toolchain_hash`, `runtime_env_hash`, and `sbom_hash`.
- Validation-only comparability (excluding derived commitment fields) requires bytewise-identical `lockfile_hash`, `policy_bundle_hash`, and `artifact_index_hash`.

---
## 8) Validation
### VII.A Lint rules (mandatory)
- Reject unknown fields in `Policy`, `ArtifactIndex`, and `UpgradeProposal`.
- Reject duplicate lock tuples by `(name, version, source)`.
- Reject multiple lock tuples with the same `(name, source)` combination.
- Reject unsorted/duplicate `allowed_sources` and `allowed_upgrade_scopes`.
- Reject duplicate `UpgradeProposal.changes` by `(name, from_version, to_version, source)`.
- Reject multiple `UpgradeProposal.changes` entries with the same `(name, source)` combination.
- Reject duplicate `ArtifactRecord` entries by `(name, version, source)`.
- Reject `requirements.txt` inline comments on requirement lines and reject `--index-url` directives not on standalone lines.
- Reject `requirements.txt` line continuations (trailing `\\`).
- Reject `requirements.txt` directives `--extra-index-url` and `--find-links`.
- Reject `requirements.txt` editable installs (`-e`) and include directives (`-r`).
- Reject `requirements.txt` environment markers (`;` outside quoted strings).
- Reject any direct URL dependencies in v1.

### VII.B Operator test vectors (mandatory)
- Valid lockfile + valid index (pass).
- Forbidden source (fail).
- Hash mismatch (fail).
- Missing artifact (fail).
- Allowed patch upgrade (allow).
- Disallowed downgrade (critical).
- Disallowed major upgrade under patch/minor-only policy (critical).

### VII.C Golden traces (mandatory)
- Golden trace sets for canonical lockfiles, including `run_header` commitments and deterministic `run_end` summaries.

---
## 9) Refactor & Equivalence
### VIII.A Equivalence levels
- `E0` applies to lock verdict, dependencies lock hash, and deterministic trace commitment fields.

### VIII.B Allowed refactor categories
- Internal parser/verifier optimization preserving all normative outputs and ordering.

### VIII.C Equivalence test procedure (mandatory)
- Exact comparison of `lock_verdict` and commitment hashes over baseline lockfiles.
- For trace equivalence, exact compare of `run_header`, `iter`, and `run_end` for same input set.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- `verification_cursor:uint64` (next tuple index to process in sorted lock tuple array; initial value `0`)
- `partial_hash_mismatches:array<HashMismatch>` (sorted)
- `partial_policy_violations:array<Violation>` (sorted)
- `lockfile_hash:bytes32`
- `policy_bundle_hash:bytes32`
- `artifact_index_hash:bytes32`
- `sbom_hash:bytes32`
- `toolchain_hash:bytes32`
- `runtime_env_hash:bytes32`

### Serialization
- Canonical CBOR.

### Restore semantics
- Restore requires re-supplying the same `lockfile_blob`; parsing MUST reproduce identical sorted tuples and `lockfile_hash`.
- On restore, recompute `lockfile_hash` from supplied lockfile and compare to checkpoint `lockfile_hash`; mismatch MUST abort with `LOCKFILE_MISMATCH`.
- Because `lockfile_hash` matches and parsing is deterministic, the sorted tuple list is identical to the original list and resumption order is preserved.
- Restore requires re-supplying `policy_blob`, `artifact_index_blob`, and `sbom_hash`.
- Recompute and compare `policy_bundle_hash` and `artifact_index_hash` against checkpoint values; mismatches MUST abort with `POLICY_BUNDLE_MISMATCH` or `ARTIFACT_INDEX_MISMATCH`.
- Supplied `sbom_hash` MUST equal checkpoint `sbom_hash`; mismatch MUST abort with `SBOM_HASH_MISMATCH`.
- Restore requires re-supplying `toolchain_hash` and `runtime_env_hash`.
- Supplied `toolchain_hash` and `runtime_env_hash` MUST equal checkpoint values; mismatches MUST abort with `TOOLCHAIN_HASH_MISMATCH` or `RUNTIME_ENV_HASH_MISMATCH`.
- Checkpointing MUST occur only at tuple boundaries after all checks for a tuple are complete.
- Restore resumes from `verification_cursor` in the same sorted tuple order.
- Restored run MUST produce byte-identical final reports and verdict as uninterrupted execution.

FILE: layer1-foundation/Determinism-Profiles.md
===============================================
# UML_OS Determinism Profiles Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Replay.DeterminismProfiles_v1`  
**Purpose (1 sentence):** Define normative determinism profiles (`BITWISE`, `TOLERANCE`) with machine-checkable runtime constraints and replay comparison rules.  
**Spec Version:** `UML_OS.Replay.DeterminismProfiles_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Reproducibility profile governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Replay.DeterminismProfiles_v1`
- **Purpose (1 sentence):** Determinism profile specification.

### 0.A Objective Semantics
- This contract performs deterministic validation/comparison only; no optimization objective applies.
- Objective type: N/A.
- Primary comparison rule: exact profile conformance plus profile-defined replay comparison.
- Invalid objective policy: profile mismatch is deterministic failure.

### 0.B Reproducibility Contract
- Replayable given `(determinism_profile_id, determinism_profile_hash, backend_binary_hash, driver_runtime_fingerprint_hash, trace_a_hash, trace_b_hash)`.

### 0.C Numeric Policy
- This section also defines deterministic equivalence-level semantics used by replay comparison.
- `BITWISE` profile uses strict bitwise equality for compared values.
- `TOLERANCE` profile uses explicit per-field tolerance policies.
- Equivalence levels (normative):
  - `E0`: byte-identical outputs (`verdict`, hash fields, and all machine-readable report fields not governed by `E1` tolerance comparison).
  - `E1`: numerically equivalent under declared tolerance map (`abs_tol`, `rel_tol`, `nan_policy`).

### 0.D Ordering and Tie-Break Policy
- Reduction ordering behavior must be declared in `profile_rules`.
- If the profile allows multiple valid orderings, the concrete ordering used MUST be captured in trace metadata.
- If the profile fixes ordering, trace capture is optional and treated as redundant metadata.

### 0.E Parallel, Concurrency, and Reduction Policy
- Profile declares collective algorithm, chunk ordering, and atomic policy.

### 0.F Environment and Dependency Policy
- `determinism_profile_hash` is required in replay token and certificate payload.

### 0.G Operator Manifest
- `UML_OS.Replay.ValidateDeterminismProfile_v1`
- `UML_OS.Replay.CompareByProfile_v1`
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- Profile registry path: `contracts/determinism_profiles.cbor`.

### 0.I Outputs and Metric Schema
- Outputs: `(profile_report, comparison_report)`.
- Metrics:
  - `profile_violations`: count of runtime/profile rule violations in `ValidateDeterminismProfile_v1`.
  - `e0_mismatch_count`: count of exact mismatches under `BITWISE`.
  - `e1_out_of_band_count`: count of value comparisons exceeding declared `abs_tol/rel_tol` under `TOLERANCE`.

### 0.J Spec Lifecycle Governance
- Profile semantics changes are MAJOR.

### 0.K Failure and Error Semantics
- Emit deterministic `REPLAY_DIVERGENCE` on comparison failure.
- If `profile_id` is not found by `CompareByProfile_v1`, emit deterministic `REPLAY_DIVERGENCE` and abort comparison.

### 0.L Input/Data Provenance
- Profile definitions are hash-addressed.

---
## 2) System Model
### I.A Persistent State
- determinism profile registry.

### I.B Inputs and Hyperparameters
- profile id, trace pair, backend/runtime metadata.
- `runtime_metadata` MUST conform exactly to `DriverRuntimeFingerprint` schema in Â§II.H (missing/extra fields are violations).

### I.C Constraints and Feasible Set
- valid iff runtime metadata satisfies selected profile.
- traces MUST conform to the external trace-format contract (`UML_OS.Trace.Format_v1`) and support deterministic field-path traversal.
- `UML_OS.Trace.Format_v1` MUST provide trace metadata fields `collective_algorithm_id`, `collective_chunking_policy`, and `rank_order_policy`; without these fields, profile-conformant comparison is not defined.

### I.D Transient Variables
- comparison diagnostics.

### I.E Invariants and Assertions
- one deterministic verdict per `(profile, trace_a_hash, trace_b_hash)`.

### II.F Profile Definitions and Rules Schema (Normative)
- `determinism_profile_id`: enum(`BITWISE`, `TOLERANCE`).
- `profile_rules` canonical CBOR schema (tagged union by `determinism_profile_id`):
  - profile-rules closure rule: only fields listed below are permitted (no extras).
  - common fields:
    - `profile_id:string`
      - MUST equal top-level `determinism_profile_id` used for hash input.
    - `rules_version:uint32` (MUST be `1` for this contract version)
    - `backend_binary_hash:bytes32`
    - `driver_runtime_equivalence_set:array<bytes32>` (sorted unique set of acceptable `driver_runtime_fingerprint_hash` values).
    - `collective_algorithm_id:string`
    - `collective_chunking_policy:string`
    - `rank_order_policy:string`
  - `BITWISE` required fields:
    - `deterministic_kernels_required:bool` (MUST be true)
    - `allow_nondeterministic_atomics:bool` (MUST be false)
    - `accumulation_policy:enum("FIXED_DTYPE_FIXED_ORDER","FLOAT32_SEQ","FLOAT64_SEQ")` (must be fixed by profile; deviation is mismatch)
    - `runtime_flags:map<string,string>` (exact key/value runtime flags)
    - `deterministic_primitive_allowlist_hash:bytes32`
  - `TOLERANCE` required fields:
    - `tolerance_map:map<string,ToleranceRule>` (keys are exact dot-separated field/key paths; duplicate keys are forbidden)
    - `default_compare_policy:enum("E0")` (fields not listed in `tolerance_map` use strict equality)
    - `missing_field_policy:enum("MISMATCH","IGNORE")`
    - `shape_mismatch_policy:enum("MISMATCH")`
- `ToleranceRule` schema:
  - `{abs_tol:float64, rel_tol:float64, nan_policy:enum("FORBID","EQUAL_IF_BOTH_NAN")}`.
- `ToleranceRule` constraints:
  - `abs_tol` and `rel_tol` MUST be non-negative finite float64 values; negative or non-finite values invalidate profile.
- `deterministic_primitive_allowlist_hash` computation:
  - `SHA-256(CBOR_CANONICAL(primitive_allowlist))`, where `primitive_allowlist` is a sorted unique array of primitive-id strings.
  - primitive-id strings MUST use exact backend canonical names from backend documentation/build metadata (no alias expansion).
- `driver_runtime_equivalence_set` note:
  - if empty, no runtime fingerprint can satisfy the profile; validation deterministically fails with `FINGERPRINT_NOT_ALLOWED`.

### II.G Profile Hash and Comparator Rules (Normative)
- `determinism_profile_hash = SHA-256(CBOR_CANONICAL([determinism_profile_id, profile_rules]))`.
- deterministic traversal order (normative):
  - maps/dictionaries: visit keys in ascending UTF-8 bytewise lexicographic order,
  - arrays: visit elements in increasing index order,
  - nested structures: traverse depth-first,
  - array element path form: `parent_path.i` (dot plus decimal index).
- `TOLERANCE` numeric comparison:
  - given expected `a`, observed `b`:
    - if both are `+inf`, match; if both are `-inf`, match; differing infinity sign is mismatch,
    - mismatch if either is NaN and `nan_policy="FORBID"`,
    - match if both are NaN and `nan_policy="EQUAL_IF_BOTH_NAN"`,
    - mismatch if exactly one is NaN,
    - `+0.0` and `-0.0` are considered equal under `TOLERANCE`,
    - otherwise match iff `|a-b| <= max(abs_tol, rel_tol * max(|a|, |b|))`.
    - note: if `rel_tol * max(|a|,|b|)` overflows to infinity, comparison for that field effectively passes whenever `|a-b|` is finite.
- Structural comparison rules:
  - missing fields:
    - a field/key is missing if present in one trace and absent in the other (symmetric definition),
    - if `missing_field_policy="MISMATCH"` then mismatch,
    - if `missing_field_policy="IGNORE"` then field/key is excluded from comparison.
  - mismatched shapes/types always mismatch under `shape_mismatch_policy="MISMATCH"`.
  - for shape mismatches (including array length mismatch), mismatch `path` MUST identify the parent field where shape mismatch occurs.
  - nested structures compare recursively by field/key path.
  - tolerance-map path matching is exact string equality against the compared field/key path; no wildcard or prefix matching is permitted.
  - for nested dynamic-key maps, each key is treated as a field; missing-key handling uses `missing_field_policy` at that nesting level.
  - for non-floating scalar types (int/bool/string/bytes), comparison is strict equality (`E0`) even under `TOLERANCE`.
  - `default_compare_policy` applies per leaf value: any leaf path without an exact `tolerance_map` key match uses `E0`.
  - implementations MAY report unused `tolerance_map` keys as diagnostics; such diagnostics MUST NOT affect verdict.

### II.H Machine-Checkable Runtime Capture (Normative)
- `DriverRuntimeFingerprint` canonical CBOR map schema (authoritative):
  - `gpu_model:string`
  - `gpu_sm_count:uint32` (number of streaming multiprocessors)
  - `driver_version:string`
  - `cuda_version:string`
  - `cudnn_version:string`
  - `cublas_version:string`
  - `nccl_version:string`
  - `os_kernel_version:string`
  - `compiler_id:string`
  - `compiler_flags_hash:bytes32`
  - `backend_adapter_version:string`
  - `backend_build_id:string`
  - `primitive_allowlist_used_hash:bytes32` (hash of primitive allowlist actually enforced at runtime)
  - `deterministic_kernels_enabled:bool` (runtime deterministic-kernel mode)
  - `nondeterministic_atomics_used:bool` (runtime observed/allowed nondeterministic atomics usage)
  - `runtime_flags:map<string,string>` (effective runtime flags used during execution)
  - `accumulation_policy:enum("FIXED_DTYPE_FIXED_ORDER","FLOAT32_SEQ","FLOAT64_SEQ")` (effective accumulation policy used during execution)
- `driver_runtime_fingerprint_hash = SHA-256(CBOR_CANONICAL(driver_runtime_fingerprint_map))`.
- `compiler_flags_hash` computation:
  - `compiler_flags_hash = SHA-256(CBOR_CANONICAL(sorted_unique_compiler_flags_array))`.
  - `sorted_unique_compiler_flags_array` is sourced from the canonical backend build record of compiler invocations for the shipped backend binary.
  - each element is a UTF-8 string representing one compiler CLI token exactly as recorded (for example `-O2`, `-DNAME=VALUE`);
  - array normalization is limited to byte-exact UTF-8 preservation, bytewise sort, and duplicate removal; no additional Unicode normalization is applied.
- Canonical map-key ordering is inherited from `docs/layer1-foundation/Canonical-CBOR-Profile.md`.
- `primitive_allowlist_used_hash` is checked for `BITWISE` profiles; for `TOLERANCE` profiles it is ignored.

---
## 3) Initialization
1. Load profile registry.
2. Validate selected profile id and `profile_rules` schema.
3. Validate runtime metadata against selected profile constraints.

---
## 4) Operator Manifest
- `UML_OS.Replay.ValidateDeterminismProfile_v1`
- `UML_OS.Replay.CompareByProfile_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Replay.ValidateDeterminismProfile_v1`  
**Category:** Replay  
**Signature:** `(profile_id, runtime_metadata, backend_binary_hash -> profile_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates runtime/backend conformance to selected profile, including:
- profile existence by `profile_id`,
- `profile_rules.rules_version == 1` (unsupported versions are invalid),
- exact `runtime_metadata` conformance to Â§II.H schema (including no extra fields and no missing required fields),
- recomputed `driver_runtime_fingerprint_hash` membership in `driver_runtime_equivalence_set`,
- provided `backend_binary_hash == profile_rules.backend_binary_hash`,
- for `BITWISE`, exact equality of `runtime_metadata.runtime_flags` and `profile_rules.runtime_flags`,
- for `BITWISE`, exact equality of `runtime_metadata.accumulation_policy` and `profile_rules.accumulation_policy`,
- for `BITWISE`, exact equality of `runtime_metadata.primitive_allowlist_used_hash` and `profile_rules.deterministic_primitive_allowlist_hash`,
- for `BITWISE`, `runtime_metadata.deterministic_kernels_enabled == true`,
- for `BITWISE`, `runtime_metadata.nondeterministic_atomics_used == false`.  
**`profile_report` minimum schema (canonical CBOR map):**
- `is_valid:bool`
- `profile_id:string`
- `determinism_profile_hash?:bytes32` (present iff profile is found and loaded)
- `driver_runtime_fingerprint_hash?:bytes32` (present iff runtime metadata can be parsed well enough to compute fingerprint hash)
- `violations:array<{path:string, code:enum("PROFILE_NOT_FOUND","PROFILE_RULE_VIOLATION","FINGERPRINT_NOT_ALLOWED","INVALID_TOLERANCE_RULE","RUNTIME_METADATA_SCHEMA_ERROR","BACKEND_BINARY_MISMATCH","RUNTIME_FLAGS_MISMATCH","ACCUMULATION_POLICY_MISMATCH","PRIMITIVE_ALLOWLIST_MISMATCH","DETERMINISTIC_KERNELS_MISMATCH","ATOMICS_POLICY_MISMATCH","UNSUPPORTED_RULES_VERSION")}>` (sorted by `(path, code)` bytewise ascending)
- violation `path` semantics:
  - `path` is dot-separated into `runtime_metadata` for field-specific violations,
  - `path=""` (empty string) for global violations not tied to one metadata field (for example `PROFILE_NOT_FOUND`).
  - if multiple violations share identical `(path, code)`, relative order is implementation-defined but MUST be deterministic for identical inputs.

**Operator:** `UML_OS.Replay.CompareByProfile_v1`  
**Category:** Replay  
**Signature:** `(trace_a, trace_b, profile_id -> comparison_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** compares traces under profile-specific `E0/E1` rules.  
If `profile_id` is missing from registry, emit `REPLAY_DIVERGENCE` and abort.
If selected `profile_rules.rules_version != 1`, emit `REPLAY_DIVERGENCE` and abort.
Trace metadata MUST include `collective_algorithm_id`, `collective_chunking_policy`, and `rank_order_policy`; values MUST match selected `profile_rules` bytewise. Missing or mismatching fields are recorded with `reason_code="PROFILE_RULE_VIOLATION"`.
**`comparison_report` minimum schema (canonical CBOR map):**
- `verdict:enum("MATCH","MISMATCH")`
- `profile_id:string`
- `determinism_profile_hash:bytes32`
- `e0_mismatch_count:uint64`
- `e1_out_of_band_count:uint64`
- `mismatches:array<{check_id:string, path:string, reason_code:enum("E0_MISMATCH","E1_OUT_OF_BAND","MISSING_FIELD","SHAPE_MISMATCH","NAN_FORBIDDEN","TYPE_MISMATCH","PROFILE_RULE_VIOLATION")}>` (sorted by `(check_id, path, reason_code)` bytewise ascending)
- path convention:
  - `path` is dot-separated field/key path (for example `step_0.layer1.weight`).
- check-id convention:
  - `check_id` uniquely identifies a comparison point in deterministic traversal (for example `step_0/loss`, `step_3/layer1.weight`).
  - generation MUST be deterministic from traversal position/path (for example derived from path plus traversal index), and reproducible for identical inputs and traversal order.
  - path delimiter safety: this contract assumes trace keys do not contain `.`; if they may, escaping rules MUST be defined by `UML_OS.Trace.Format_v1`.

---
## 6) Procedure
```text
1. ValidateDeterminismProfile_v1
2. CompareByProfile_v1
3. Return profile_report + comparison_report
```

---
## 7) Trace & Metrics
### Logging rule
- profile checks and replay comparisons emit deterministic records.

### Trace schema
- `run_header`: `{profile_id:string, determinism_profile_hash:bytes32}`
- `iter`: `{check_id:string, status:enum("MATCH","MISMATCH"), path:string?}`
- `run_end`: `{comparison_status:enum("MATCH","MISMATCH")}`
- `iter.path`, when present, follows the same dot-separated convention as report `path`.

### Metric schema
- `profile_violations`, `e0_mismatch_count`, `e1_out_of_band_count`

### Comparability guarantee
- Comparable iff `determinism_profile_id` and `determinism_profile_hash` are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- selected profile must declare runtime constraints and comparator policy.
- `profile_rules` and `ToleranceRule` schemas must validate.
- `runtime_metadata` must validate exactly against Â§II.H schema (no missing/extra fields).
- `profile_rules.rules_version` must equal `1`; otherwise emit `UNSUPPORTED_RULES_VERSION`.
- runtime check: `driver_runtime_fingerprint_hash` must match recomputed fingerprint hash and be allowed by `driver_runtime_equivalence_set`.
- runtime check: provided `backend_binary_hash` must equal `profile_rules.backend_binary_hash`.
- runtime check (`BITWISE`): `runtime_metadata.runtime_flags` must equal `profile_rules.runtime_flags`.
- runtime check (`BITWISE`): `runtime_metadata.accumulation_policy` must equal `profile_rules.accumulation_policy`.
- runtime check (`BITWISE`): `runtime_metadata.primitive_allowlist_used_hash` must equal `profile_rules.deterministic_primitive_allowlist_hash`.
- runtime check (`BITWISE`): `runtime_metadata.deterministic_kernels_enabled` must be `true`.
- runtime check (`BITWISE`): `runtime_metadata.nondeterministic_atomics_used` must be `false`.

#### VII.B Operator test vectors (mandatory)
- profile pass/fail fixtures and mixed hardware scenarios.

#### VII.C Golden traces (mandatory)
- golden profile-conformance traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- `E0` required for `verdict`, hash fields, and deterministic machine-readable report fields.
- `E1` allowed only for value-level numeric comparisons under `TOLERANCE`.

#### VIII.B Allowed refactor categories
- comparator implementation refactors preserving outputs.

#### VIII.C Equivalence test procedure (mandatory)
- exact compare for all `E0` fields; tolerance compare for `E1` fields.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- `profile_id:string`
- `determinism_profile_hash:bytes32`
- `trace_a_hash:bytes32`
- `trace_b_hash:bytes32`
- `comparator_cursor:{check_index:uint64, path:string}`.

### Cursor semantics
- `check_index` is the 0-based index of next comparison check.
- `path` is the exact path of the next comparison point in deterministic traversal order.
- `(check_index, path)` combination MUST uniquely identify the next comparison point.
- if `check_index >= total_comparison_points` on restore, comparison is treated as complete and final verdict/report are returned immediately.

### Serialization
- deterministic canonical CBOR.

### Restore semantics
- resumed comparison from `comparator_cursor` MUST yield the same final verdict and report as full rerun.
- `trace_a` and `trace_b` are assumed content-addressed artifacts retrievable by `trace_a_hash`/`trace_b_hash` from external storage (out of scope of this contract).

FILE: layer1-foundation/Digest-Catalog.md
=========================================
# UML_OS Digest Catalog Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Registry.DigestCatalog_v1`  
**Purpose (1 sentence):** Define an authoritative catalog mapping digest labels to full bytes32 values and deterministic resolution rules.  
**Spec Version:** `UML_OS.Registry.DigestCatalog_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Digest governance and consistency control.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Registry.DigestCatalog_v1`
- **Purpose (1 sentence):** Canonical digest label-to-bytes32 mapping.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: exact digest lookup and equality.
- Invalid objective policy: unresolved label is fatal.
### 0.B Reproducibility Contract
- Replayable given `(catalog_version, catalog_hash)`.
- `catalog_version` is a positive integer schema-version value carried inside the catalog object (`catalog_version >= 1`).
### 0.C Numeric Policy
- Digests are fixed-length `bytes32`.
### 0.D Ordering and Tie-Break Policy
- Records sorted lexicographically by `digest_label`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Lookup is pure read-only.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE`.
### 0.G Operator Manifest
- `UML_OS.Registry.ResolveDigestRef_v1`
- `UML_OS.Registry.ValidateDigestCatalog_v1`
- `UML_OS.Error.Emit_v1`
  - Note: `UML_OS.Error.Emit_v1` is a shared runtime error operator defined in the core error contract (`docs/layer1-foundation/Error-Codes.md`), not redefined in this document.
### 0.H Namespacing and Packaging
- Canonical location: `contracts/digest_catalog.cbor`.
### 0.I Outputs and Metric Schema
- `ResolveDigestRef_v1` output: `(resolved_digest)`.
- `ValidateDigestCatalog_v1` output: `(validation_report)`.
### 0.J Spec Lifecycle Governance
- Label removal is MAJOR.
### 0.K Failure and Error Semantics
- Abort on unresolved or duplicate labels.
### 0.L Input/Data Provenance
- Catalog is content-addressed and immutable.

---
## 2) System Model
### I.A Persistent State
- `digest_catalog`.
### I.B Inputs and Hyperparameters
- `digest_ref` and catalog blob.
- `catalog_version:uint32` (required field of catalog object; versioned by this contract, not inferred externally; must be `>= 1`).
### I.C Constraints and Feasible Set
- Valid iff labels unique, digests are bytes32, and `catalog_version:uint32` is present.
- `digest_label` MUST match `^[a-z0-9_\\-\\.]{1,128}$` and MUST NOT match `^[0-9a-f]{64}$` (reserved for inline digest form).
- Label uniqueness uses exact bytewise UTF-8 comparison (case-sensitive, no trimming/normalization).
### I.D Transient Variables
- resolution diagnostics.
### I.E Invariants and Assertions
- no duplicate labels.
- no additional fields in entry records.

### II.F Digest Catalog Schema (Normative)
- Catalog object schema:
  - `catalog_version:uint32`
  - `entries:array<entry_record>`
- `entry_record` serialization is canonical CBOR map with exactly the fields below (no extras, no omissions):
  - `digest_label:string`
  - `digest_value:bytes32`
  - `algorithm:string` (must be `sha256`)
  - `domain_tag:string` (domain metadata for governance/audit; does not alter `ResolveDigestRef_v1` lookup semantics).
- Additional fields are forbidden in both catalog object and entry records.
- Canonical CBOR in this document means `CBOR_CANONICAL` as defined by `docs/layer1-foundation/Canonical-CBOR-Profile.md` (single authoritative encoding profile for commitment paths).

### II.H Catalog Commitment (Normative)
- `entries_sorted` are sorted by `digest_label` ascending (bytewise UTF-8, case-sensitive).
- `catalog_version` is encoded as CBOR unsigned integer (`uint32` domain constraint).
- `catalog_hash = SHA-256(CBOR_CANONICAL(["digest_catalog_v1", catalog_version, entries_sorted]))`.
- Any document using `sha256:<label>` references is valid only against the committed `catalog_hash`.

### II.G Resolution Rule (Normative)
- `digest_ref` supports two forms:
  - inline: `sha256:<hex64>` where `<hex64>` is exactly 64 hex chars and resolves directly to bytes32,
  - catalog label: `sha256:<label>` where `<label>` must exist in catalog and resolve to bytes32.
- Disambiguation rule:
  - if tail matches `^[0-9a-fA-F]{64}$`, treat as inline bytes32 digest,
  - otherwise treat as catalog label and perform lookup.
- Inline digest tail MAY be uppercase or lowercase; implementations MUST normalize inline hex tails to lowercase before bytes parsing and validation.
- Signature/hash computations must use resolved bytes32 digest bytes, never label string bytes.

---
## 3) Initialization
1. Load digest catalog.
2. Validate schema and uniqueness.
3. Build lookup index.
4. Compute and store `catalog_hash` using Â§II.H exactly:
   - `catalog_hash = SHA-256(CBOR_CANONICAL(["digest_catalog_v1", catalog_version, entries_sorted]))`,
   - where `entries_sorted` is the catalog `entries` array sorted by `digest_label` ascending (bytewise UTF-8, case-sensitive).

---
## 4) Operator Manifest
- `UML_OS.Registry.ResolveDigestRef_v1`
- `UML_OS.Registry.ValidateDigestCatalog_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Registry.ResolveDigestRef_v1`  
**Category:** Governance  
**Signature:** `(digest_ref, digest_catalog -> digest_value)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** resolves digest labels to bytes32 values.

**Operator:** `UML_OS.Registry.ValidateDigestCatalog_v1`  
**Category:** Governance  
**Signature:** `(digest_catalog -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates schema, uniqueness, label constraints, and commitment computability.
**validation_report (minimum schema):**
```yaml
validation_report:
  is_valid: bool
  errors: [string]         # deterministic order
  catalog_hash: bytes32    # present when is_valid=true
```

---
## 6) Procedure
```text
1. ResolveDigestRef_v1 using initialized validated catalog index.
2. Return digest_value
```

---
## 7) Trace & Metrics
### Logging rule
- digest reference resolutions emit deterministic events.
### Trace schema
- `run_header`: catalog_hash
- `iter`: digest_ref, status
- `run_end`: resolved_digest
### Trace status enum
- `status` MUST be one of:
  - `resolved`
  - `missing`
### Metric schema
- `resolved_count`, `missing_count`
### Comparability guarantee
- Comparable iff catalog hash is identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- no duplicate labels.
- all labels MUST satisfy format constraints in Â§I.C.
- cross-document label resolution checks (ensuring every `sha256:<label>` reference resolves in catalog) are enforced by spec-lint tooling, not catalog-internal schema validation.
#### VII.B Operator test vectors (mandatory)
- valid/missing/duplicate label cases.
#### VII.C Golden traces (mandatory)
- golden resolution traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for digest resolution outputs.
#### VIII.B Allowed refactor categories
- indexing optimizations preserving output.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare of resolved bytes32.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- catalog hash only (catalog is immutable and lookup is stateless in this contract).
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- identical resolution on resume.

FILE: layer1-foundation/Environment-Manifest.md
===============================================
# UML_OS Environment Manifest Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Environment.Manifest_v1`  
**Purpose (1 sentence):** Define canonical environment/runtime fingerprint schema and hashing used by replay tokens, checkpoints, and certificates.  
**Spec Version:** `UML_OS.Environment.Manifest_v1` | 2026-02-20 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Deterministic environment identity and compatibility gating.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Environment.Manifest_v1`
- **Purpose (1 sentence):** Canonical environment identity contract.

### 0.A Objective Semantics
- This contract performs deterministic capture/validation only; no optimization objective applies.
- Primary comparison rule: exact hash equality and fieldwise compatibility checks.

### 0.B Reproducibility Contract
- Replayable given `(env_manifest_hash)` with content-addressable retrieval of the committed manifest bytes.
- Required normative dependencies for deterministic replay:
  - `docs/layer1-foundation/Canonical-CBOR-Profile.md`
  - `docs/layer1-foundation/Determinism-Profiles.md`
  - `docs/layer1-foundation/Error-Codes.md`
- Dependency availability rule:
  - if a required dependency document is missing, unreadable, or its content does not match the version/sections referenced by this contract, treat as fatal configuration error and abort with `CONTRACT_VIOLATION`.
  - dependency governance assumption: referenced documents MUST be maintained as a coherent suite with this contract.

### 0.C Numeric Policy
- This section also defines equivalence-level semantics for compatibility and manifest commitments.
- All fields are exact typed values.
- `E0` (normative): byte-identical canonical manifest bytes, `env_manifest_hash`, and compatibility verdict/report fields.

### 0.D Ordering and Tie-Break Policy
- Canonical CBOR encoding is mandatory.
- Canonical CBOR is defined by RFC 8949 deterministic encoding rules and `docs/layer1-foundation/Canonical-CBOR-Profile.md`.

### 0.E Parallel, Concurrency, and Reduction Policy
- Runtime capture may be parallelized.
- Final manifest map and hash MUST be deterministic.

### 0.F Environment and Dependency Policy
- Determinism level for manifest commitment: `BITWISE`.

### 0.G Operator Manifest
- `UML_OS.Environment.BuildManifest_v1`
- `UML_OS.Environment.ComputeManifestHash_v1`
- `UML_OS.Environment.ValidateCompatibility_v1`
- `UML_OS.Error.Emit_v1` (defined in `docs/layer1-foundation/Error-Codes.md`)

### 0.H Namespacing and Packaging
- Namespace: `UML_OS.Environment.*`
- Canonical manifest artifact path: `contracts/environment_manifest.cbor`

### 0.I Outputs and Metric Schema
- Outputs: `(env_manifest, env_manifest_hash, compatibility_report)`.
- `BuildManifest_v1` outputs `env_manifest`.
- `ComputeManifestHash_v1` outputs `env_manifest_hash`.
- `ValidateCompatibility_v1` outputs `compatibility_report`.

### 0.J Spec Lifecycle Governance
- Required field changes are MAJOR.

### 0.K Failure and Error Semantics
- If a required capture source is unavailable or a required field cannot be computed, emit deterministic `CONTRACT_VIOLATION` and abort.
- If a required command source executes with non-zero exit status or emits no output when output is required, emit `CONTRACT_VIOLATION` and abort.
- `CONTRACT_VIOLATION` emission semantics are governed by `docs/layer1-foundation/Error-Codes.md`.

### 0.L Input/Data Provenance
- Capture sources MUST be recorded deterministically via the normalized manifest fields and constituent hashes.

### 0.Z EQC Mandatory Declarations Addendum
- No stochastic operators in this contract version.
- Determinism level: `BITWISE` for canonical manifest bytes and `env_manifest_hash`.
- Numeric edge policy:
  - This contract does not define floating stochastic computation paths; numeric handling is exact typed capture and canonical encoding per declared rules.

---
## 2) System Model
### I.A Persistent State
- Environment manifest registry keyed by `env_manifest_hash`.

### I.B Inputs and Hyperparameters
- `BuildManifest_v1` takes no explicit inputs: it deterministically captures host/runtime facts from normative sources.
- `ValidateCompatibility_v1` takes `(candidate_manifest, required_manifest?)`.
- `required_manifest` MUST conform to the same schema as section 2.6 (complete required manifest, no extra fields).
- Backend adapter definition: the component that interfaces with the compute/runtime backend and exposes deterministic metadata APIs used by this contract.

### I.C Constraints and Feasible Set
- Valid iff all required fields exist, satisfy schema/type constraints, and per-field normalization rules.
- Capture MUST observe a consistent snapshot of sources; if snapshot consistency cannot be guaranteed, capture aborts with `CONTRACT_VIOLATION`.
- For multi-file artifact hashing, all file contents MUST be read from one consistent snapshot view; if mutation is detected during capture, abort with `CONTRACT_VIOLATION`.
- Multi-file mutation detection algorithm (normative):
  1. resolve symlinks to final regular-file targets and record per-target `(mtime,size)`,
  2. read all resolved target files and compute per-file `sha256(content)`,
  3. re-resolve symlinks to current targets; if any current resolved path differs from the path recorded in step 1, abort with `CONTRACT_VIOLATION`; otherwise re-check `(mtime,size)` for all current targets,
  4. if any metadata changed, abort with `CONTRACT_VIOLATION`,
  5. if metadata unchanged, re-read each current target file and recompute sha256; if any hash differs from step 2, abort with `CONTRACT_VIOLATION`.
  - note: if a symlink target is replaced by another file with identical metadata and identical content, this change is undetectable by this algorithm and accepted as a practical determinism trade-off.

### I.D Transient Variables
- Capture diagnostics and validation diagnostics.

### I.E Invariants and Assertions
- Same normalized runtime facts always produce identical canonical CBOR bytes and `env_manifest_hash`.

### 2.6 Canonical Environment Manifest Schema (Normative)
- Top-level map MUST contain exactly these fields (no extras):
  - `schema_version:string` (MUST equal `UML_OS.Environment.Manifest_v1`)
  - `os_name:string`
  - `os_version:string`
  - `kernel_version:string`
  - `hardware_arch:string`
  - `python_version:string`
  - `backend_adapter_version:string`
  - `backend_binary_hash:bytes32`
  - `driver_runtime_fingerprint_hash:bytes32`
  - `determinism_profile_hash:bytes32`
  - `toolchain_hash:bytes32`
  - `env_vars_fingerprint_hash:bytes32`
- Manifest map MUST be encoded using canonical CBOR key ordering (bytewise key order) per RFC 8949 deterministic encoding.

### 2.7 Field Capture and Normalization Rules (Normative)
- Command execution for OS/kernel/arch capture MUST use `LC_ALL=C`.
- Regex dialect:
  - all regular expressions in this contract use ECMAScript syntax.
- Executable-path definition:
  - a command path is executable iff it resolves to a regular file that the current process can execute.
- `uname` command path resolution algorithm (deterministic):
  1. if `UNAME_CMD` is set:
     - it MUST be an absolute path and executable;
     - otherwise capture failure (`CONTRACT_VIOLATION`);
     - use `UNAME_CMD`.
  2. else if `/bin/uname` is executable, use it.
  3. else if `/usr/bin/uname` is executable, use it.
  4. else capture failure (`CONTRACT_VIOLATION`).
- `os_name`:
  - source: `<resolved_uname_path> -s`
  - normalization: UTF-8, trim outer whitespace, lowercase ASCII.
- `kernel_version`:
  - source: `<resolved_uname_path> -r`
  - normalization: UTF-8, trim outer whitespace.
- `hardware_arch`:
  - source: `<resolved_uname_path> -m`
  - normalization: UTF-8, trim outer whitespace, lowercase ASCII.
  - architecture aliases are not remapped; normalized raw output is authoritative.
- `os_version`:
  - source priority:
    1. `/etc/os-release` `VERSION_ID`
    2. fallback `<resolved_uname_path> -v`
  - normalization: UTF-8, trim outer whitespace.
  - a source is considered failed if read fails or normalized value is empty.
  - both sources MUST be evaluated within the same capture snapshot window.
  - mutation detection for fallback chain:
    - if source 1 is read from `/etc/os-release`, resolve symlink to final regular-file target and record target metadata snapshot `(mtime,size)` plus sha256(content),
    - immediately before source 2 fallback, re-resolve target and re-check `(mtime,size)`; if changed, treat as mutation and abort,
    - if unchanged metadata, re-read resolved target and recompute hash; if hash differs, treat as mutation and abort.
  - if all sources fail, abort with `CONTRACT_VIOLATION`.
  - note: `/bin/uname -v` may include build metadata/timestamps; this is accepted as exact runtime identity in this version.
  - race-window note: execute fallback command immediately after metadata/hash re-check to minimize race exposure.
- `python_version`:
  - source: `platform.python_version()`
  - normalization algorithm:
    1. read raw version string `v`,
    2. apply regex `^([0-9]+)\\.([0-9]+)(?:\\.([0-9]+))?`,
    3. if group3 present, normalized value is `group1.group2.group3`,
    4. else normalized value is `group1.group2.0`,
    5. if regex does not match, abort.
  - captures the interpreter executing this contract.
- `backend_adapter_version`:
  - source: deterministic backend adapter API `adapter.get_version()`.
  - `adapter.get_version()` MUST return a UTF-8 string.
  - `adapter.get_version()` MUST be deterministic for identical backend installation/state.
  - normalization: UTF-8, trim outer whitespace.
  - empty normalized value is invalid and MUST abort with `CONTRACT_VIOLATION`.
- Normalization failures (invalid UTF-8, invalid format) are capture failures and MUST abort with `CONTRACT_VIOLATION`.

### 2.8 Constituent Hash Definitions (Normative)
- Hash algorithm for all fields below: SHA-256.
- `backend_binary_hash`:
  - backend adapter MUST expose deterministic API `adapter.get_canonical_artifact_set()` returning `(root_path, relative_paths[])`.
  - `adapter.get_canonical_artifact_set()` MUST be deterministic for identical backend installation/state.
  - `root_path` MUST be an absolute path; if relative, abort with `CONTRACT_VIOLATION`.
  - `root_path` MUST exist and be a directory; otherwise abort with `CONTRACT_VIOLATION`.
  - implementation MUST resolve `root_path` to canonical absolute path (`realpath`) before resolving artifacts; if canonical resolution fails (for example due to broken symlink path components), abort with `CONTRACT_VIOLATION`.
  - `root_path` is used for file resolution only and is not included in hash input.
  - `relative_paths[]` MUST be unique and sorted bytewise.
  - if `relative_paths[]` is empty, abort with `CONTRACT_VIOLATION`.
  - returned `relative_paths[]` set MUST be stable for identical backend installation/state.
  - implementation MUST normalize and validate adapter-returned paths before use under the rules below.
  - each `relative_path` MUST be UTF-8, trimmed, normalized to `/` separators, and relative to `root_path` (no absolute path, no `..` traversal, no duplicate separators).
  - `relative_path` MUST NOT start with `./` or contain `./` as a distinct path component.
  - after normalization, any remaining `..` path component is forbidden; if present, abort with `CONTRACT_VIOLATION`.
  - if normalized `relative_path` is empty, abort with `CONTRACT_VIOLATION`.
  - `relative_path` MUST NOT end with `/`.
  - paths MUST resolve to regular files; symlinks MUST be resolved to final regular-file targets before hashing.
  - unresolved/broken symlink, directory target, or any non-regular-file target is fatal and aborts.
  - if artifact set contains one file, hash raw bytes of that file.
  - if artifact set contains multiple files, hash canonical CBOR array of `(relative_path, file_sha256)` pairs sorted by `relative_path` bytewise.
- `driver_runtime_fingerprint_hash`:
  - input: canonical CBOR map for `DriverRuntimeFingerprint` from `docs/layer1-foundation/Determinism-Profiles.md` section II.H.
  - if dependency document is unavailable or invalid, abort with `CONTRACT_VIOLATION`.
- `determinism_profile_hash`:
  - input: selected profile commitment from `docs/layer1-foundation/Determinism-Profiles.md` section II.G.
  - if dependency document is unavailable or invalid, abort with `CONTRACT_VIOLATION`.
  - profile/fingerprint selection source is runtime environment configuration; selection MUST be deterministic and reproducible for identical configuration.
- `toolchain_hash`:
  - input: canonical CBOR map:
    - `c_compiler_id:string|null`
    - `c_compiler_version:string|null`
    - `cxx_compiler_id:string|null`
    - `cxx_compiler_version:string|null`
    - `linker_id:string|null`
    - `linker_version:string|null`
    - `build_system_id:string|null`
    - `build_system_version:string|null`
  - all keys MUST be present; map hashed via canonical CBOR.
  - capture sources and normalization:
    - tool path resolution is deterministic per tool:
      - C compiler: if `CC` is set, it MUST be absolute and executable; otherwise abort. If unset, use `/usr/bin/cc` only if executable, else treat as absent.
      - C++ compiler: if `CXX` is set, it MUST be absolute and executable; otherwise abort. If unset, use `/usr/bin/c++` only if executable, else treat as absent.
      - Linker: if `LD` is set, it MUST be absolute and executable; otherwise abort. If unset, use `/usr/bin/ld` only if executable, else treat as absent.
      - Build system: if `CMAKE_COMMAND` is set, it MUST be absolute and executable; otherwise abort. If unset, use `/usr/bin/cmake` only if executable, else treat as absent.
    - if tool is absent/unreadable, corresponding id/version pair MUST be set to `null` (runtime-only environments supported).
    - `c_compiler_id`, `c_compiler_version`: from resolved C compiler `--version` first matching line among first 5 lines when available.
      - parse rules (in order):
        1. if matches `^clang version ([0-9]+\\.[0-9]+\\.[0-9]+)`, set id=`clang`, version=group1,
        1a. if matches `^Apple clang version ([0-9]+\\.[0-9]+(\\.[0-9]+)?)`, set id=`apple-clang`, version=`group1` padded to three segments by appending `.0` for missing segment,
        2. else if matches `^([A-Za-z0-9_+.-]+).*?([0-9]+\\.[0-9]+\\.[0-9]+)`, set id=group1, version=group2,
        3. else if matches `^([A-Za-z0-9_+.-]+).*?([0-9]+\\.[0-9]+)`, set id=group1, version=`group2.0`,
        4. else abort.
    - `cxx_compiler_id`, `cxx_compiler_version`: from resolved C++ compiler `--version` first matching line among first 5 lines using same parse rules as C compiler.
    - `linker_id`, `linker_version`: from resolved linker `--version` first matching line among first 5 lines when available.
      - parse rules (in order):
        1. if matches `^(LLD|lld) ([0-9]+\\.[0-9]+\\.[0-9]+)`, set id=`lld`, version=group2,
        2. else if matches `^GNU ld .*?([0-9]+\\.[0-9]+(\\.[0-9]+)?)`, set id=`gnu-ld`, version=group1,
        3. else if matches `^([A-Za-z0-9_+.-]+).*?([0-9]+\\.[0-9]+\\.[0-9]+)`, set id=group1, version=group2,
        3a. else if matches `^([A-Za-z0-9_+.-]+).*?([0-9]+\\.[0-9]+)`, set id=group1, version=`group2.0`,
        4. else abort.
    - `build_system_id`, `build_system_version`: from resolved build-system tool `--version` first matching line among first 5 lines when available.
      - parse rules (in order):
        1. if matches `^cmake version ([0-9]+\\.[0-9]+\\.[0-9]+)`, set id=`cmake`, version=group1,
        2. else if matches `^cmake version ([0-9]+\\.[0-9]+)`, set id=`cmake`, version=`group1.0`,
        3. else abort.
  - all parsed strings MUST be UTF-8, trimmed, and lowercase ASCII for ids; versions preserve normalized dotted/semver token.
  - version-normalization note:
    - version width normalization is rule-specific (some capture rules preserve two-part versions, others pad to three parts);
    - cross-tool version strings are not globally normalized to one width in this contract version.
  - compiler-id canonicalization post-process:
    - if parsed id contains `gcc` (case-insensitive), canonical id=`gcc`,
    - if parsed id contains `g++` (case-insensitive), canonical id=`gcc`,
    - if parsed id contains `clang` and not `apple clang`, canonical id=`clang`,
    - apple clang remains `apple-clang`.
  - build-system scope note: this version captures CMake only; other build systems are represented as `null` unless surfaced via `CMAKE_COMMAND`.
  - parse failure for an available tool is fatal and aborts with `CONTRACT_VIOLATION`.
- `env_vars_fingerprint_hash`:
  - input variable-name allowlist (exact names, fixed order after bytewise sort):
    - `PYTHONHASHSEED`
    - `CUDA_VISIBLE_DEVICES`
    - `CUBLAS_WORKSPACE_CONFIG`
    - `OMP_NUM_THREADS`
    - `MKL_NUM_THREADS`
    - `OPENBLAS_NUM_THREADS`
    - `NUMEXPR_NUM_THREADS`
    - `NCCL_ALGO`
    - `NCCL_PROTO`
    - `TF_DETERMINISTIC_OPS`
  - canonical value map MUST contain all allowlisted keys exactly once: `{var_name: value_or_null}`.
  - unset vars MUST be encoded as CBOR `null` (`0xf6`).
  - set vars MUST be valid UTF-8 text; invalid UTF-8 values are fatal capture failures.
  - if an environment-variable value exceeds `1048576` bytes (1 MiB), abort with `CONTRACT_VIOLATION`.
  - hash input is canonical CBOR of that map.
  - this allowlist is the canonical set for `UML_OS.Environment.Manifest_v1`; extensions require a MAJOR version change.
- Constituent hash failure rule:
  - any failure during constituent hash computation (read error, parse error, algorithm failure) is fatal and aborts with `CONTRACT_VIOLATION`.

---
## 3) Initialization
1. Capture required runtime facts from normative sources.
2. Normalize fields per section 2.7.
3. Compute constituent hashes per section 2.8.
4. Assemble schema-valid manifest map.
5. Compute `env_manifest_hash`.

---
## 4) Operator Manifest
- `UML_OS.Environment.BuildManifest_v1`
- `UML_OS.Environment.ComputeManifestHash_v1`
- `UML_OS.Environment.ValidateCompatibility_v1`
- `UML_OS.Error.Emit_v1`
- External operator reference note: `UML_OS.Error.Emit_v1` is defined in `docs/layer1-foundation/Error-Codes.md`.

---
## 5) Operator Definitions
**Operator:** `UML_OS.Environment.BuildManifest_v1`  
**Category:** Environment  
**Signature:** `(() -> env_manifest)`  
**Purity class:** IO  
**Determinism:** deterministic given unchanged runtime facts and capture sources  
**Definition:** Captures required runtime facts, applies normalization, computes constituent hashes, emits schema-valid manifest.

**Operator:** `UML_OS.Environment.ComputeManifestHash_v1`  
**Category:** Environment  
**Signature:** `(env_manifest -> env_manifest_hash)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Computes `SHA-256(CBOR_CANONICAL(env_manifest))`.

**Operator:** `UML_OS.Environment.ValidateCompatibility_v1`  
**Category:** Environment  
**Signature:** `(candidate_manifest, required_manifest? -> compatibility_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Validates compatibility using complete-manifest semantics:
- `required_manifest`, when provided, is the full required schema (section 2.6),
- if `required_manifest` is absent, compatibility is not evaluated and report status is `NOT_CHECKED`,
- compatibility holds iff every required field exists in `candidate_manifest` and equals the corresponding required value,
- extra fields in `candidate_manifest` are ignored for compatibility but violate schema-lint if candidate is validated as canonical manifest,
- `missing_fields` = count of required fields absent in candidate,
- `compatibility_failures` = number of unequal required fields and MUST equal `len(mismatches)`.
- CBOR equality semantics: field equality uses byte-identical canonical CBOR values (`null` is only equal to `null`).
- precondition: if `required_manifest` is provided it MUST be schema-valid per section 2.6; otherwise abort with `CONTRACT_VIOLATION`.

**`compatibility_report` minimum schema (canonical CBOR map):**
- `is_compatible:bool`
- `candidate_hash:bytes32`
- `required_hash?:bytes32` (present iff `required_manifest` is provided)
- `mismatches:array<{path:string, candidate_value:string, required_value:string}>` sorted by `path` bytewise
  - canonical value-to-string rendering:
    - `bytes32` -> lowercase hex (64 chars, no `0x`),
    - `null` -> literal `__NULL__`,
    - text string -> exact UTF-8 string.
- `missing_fields:uint64`
- `compatibility_failures:uint64`
- `compatibility_status:enum("COMPATIBLE","INCOMPATIBLE","NOT_CHECKED")`
- `is_compatible` is true iff `missing_fields==0` and `compatibility_failures==0` and `compatibility_status=="COMPATIBLE"`.

---
## 6) Procedure
```text
1. BuildManifest_v1
2. ComputeManifestHash_v1
3. ValidateCompatibility_v1 (against required baseline, if provided)
4. Return env_manifest + env_manifest_hash + compatibility_report
```

---
## 7) Trace & Metrics
### 6.1 Logging Rule
- Environment capture/validation emits deterministic records.
- Trace emission mapping:
  - `BuildManifest_v1`: emits capture `iter` events and run-level capture status.
  - `ValidateCompatibility_v1`: emits compatibility `iter` events and final compatibility status.
- On field capture/normalization/hash failure, emit `iter` with `status=\"ERROR\"` for the affected top-level field path before abort.

### 6.2 Trace Schema
- `run_header`: `{schema_version:string}`
- `iter`: `{field_path:string, status:enum("CAPTURED","MISSING","MISMATCH","ERROR")}`
- `run_end`: `{env_manifest_hash:bytes32, compatibility_status:enum("COMPATIBLE","INCOMPATIBLE","NOT_CHECKED")}`
- validation event mapping:
  - missing required field in candidate -> `iter(status=\"MISSING\")`,
  - present but unequal -> `iter(status=\"MISMATCH\")`,
  - malformed manifest or validation fault -> `iter(status=\"ERROR\")` then abort,
  - matching fields may omit `iter` event.
- iter ordering rule:
  - `iter` events MUST follow ascending bytewise order of manifest field keys (same order as canonical CBOR map keys).

### 6.3 Metric Schema
- `missing_fields` produced by `BuildManifest_v1` and `ValidateCompatibility_v1`; MUST be emitted when detected, including error-before-abort cases.
- `compatibility_failures` produced by `ValidateCompatibility_v1`.

### 6.4 Comparability Guarantee
- Comparable iff `schema_version` matches and canonical CBOR profile is identical.

---
## 8) Validation
### 7.1 Lint Rules (mandatory)
- Manifest map contains exactly required fields (no extras, no missing).
- `schema_version` equals `UML_OS.Environment.Manifest_v1`.
- All hash fields are `bytes32` encoded as CBOR byte strings (major type 2) of exactly 32 bytes.
- Canonical CBOR encoding used for all commitments.

### 7.2 Operator Test Vectors (mandatory)
- Fixed capture inputs/snapshots produce fixed `env_manifest_hash`.
- Compatibility fixtures for match/mismatch cases.

### 7.3 Golden Traces (mandatory)
- Golden capture and compatibility traces with fixed hashes.

---
## 9) Refactor & Equivalence
### 8.1 Equivalence Levels
- `E0` required for manifest bytes, `env_manifest_hash`, and compatibility verdict/report.

### 8.2 Allowed Refactor Categories
- Capture implementation changes that preserve normalized field values and final manifest bytes/hash.

### 8.3 Equivalence Test Procedure (mandatory)
- Canonical-byte compare of manifest maps.
- Exact compare of `env_manifest_hash` and `compatibility_report`.

---
## 10) Checkpoint/Restore
### 9.1 Checkpoint Contents
- `env_manifest_hash:bytes32`
- `schema_version:string`

### 9.2 Serialization
- Deterministic canonical CBOR.

### 9.3 Restore Semantics
- Restore retrieves manifest by `env_manifest_hash` from content-addressable storage.
- Restored run MUST match committed `env_manifest_hash`; otherwise abort deterministically.
- Content-addressable storage mechanism is out of scope, but exact original manifest bytes MUST be retrievable by hash.

---
## 11) EQC Alignment Notes
- This document preserves EQC block structure with domain-specific mappings:
  - Block V observability semantics are represented in section `6) Trace & Metrics`.
  - Block VI parallel/nondeterminism semantics are represented in section `0.E` and relevant deterministic ordering rules.
  - Block IX checkpoint/restore semantics are represented in section `9) Checkpoint/Restore`.

FILE: layer1-foundation/Error-Codes.md
======================================
# UML_OS Error Code Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Error.CodeRegistry_v1`  
**Purpose (1 sentence):** Define a deterministic unified error taxonomy and emission contract across all UML_OS operators.  
**Spec Version:** `UML_OS.Error.CodeRegistry_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Error semantics and interoperability.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Error.CodeRegistry_v1`
- **Purpose (1 sentence):** Unified deterministic error registry.
- **Spec Version:** `UML_OS.Error.CodeRegistry_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Error taxonomy governance.
### 0.A Objective Semantics
- This contract is a static taxonomy/validation contract (not an optimization objective).
- Primary comparison rule: exact `code_id` + `numeric_code` identity and deterministic schema validation.
### 0.B Reproducibility Contract
- Replayable given `(error_registry_version, failure_context_hash)`.
### 0.C Numeric Policy
- Error fields are typed; numeric values deterministic and explicit.
### 0.D Ordering and Tie-Break Policy
- Error code ordering by lexical code id.
### 0.E Parallel, Concurrency, and Reduction Policy
- Concurrent failures are all emitted as independent records.
- Any summary/aggregation views MUST order records deterministically by `(t, failure_operator, code_id)` and MUST NOT discard emitted records.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for emitted error records.
### 0.G Operator Manifest
- `UML_OS.Error.Emit_v1`
- `UML_OS.Error.ValidateRecord_v1`
- `UML_OS.Error.SerializeRecord_v1`
### 0.H Namespacing and Packaging
- Error codes are global and unique.
### 0.I Outputs and Metric Schema
- Outputs: `(error_record, serialized_error)`.
- Metrics: `error_code_frequency`, `first_failure_t`.
- Completion status: `failed` (or `success` for validation-only runs).
### 0.J Spec Lifecycle Governance
- New code additions are MINOR; semantic changes/removals are MAJOR.
### 0.K Failure and Error Semantics
- Abort-only or structured depending on caller policy; record always deterministic.
### 0.L Input/Data Provenance
- Error records include replay token and operator provenance.

---
### 0.Z EQC Mandatory Declarations Addendum
- Not applicable in this document beyond deterministic record emission/validation declared above; stochastic and numeric-kernel clauses are inherited from producing operators.


## 2) System Model
### I.A Persistent State
- error code registry.
### I.B Inputs and Hyperparameters
- failure context and policy.
### I.C Constraints and Feasible Set
- registry uniqueness and schema validity constraints.
### I.D Transient Variables
- formatted error record.
### I.E Invariants and Assertions
- every emitted code exists in registry.

### II.F Error Registry (Authoritative)
| code_id | numeric_code | category | severity | retryable | deterministic_fields_required | message_template | remediation | version_introduced |
|---|---:|---|---|---|---|---|---|---|
| `CONTRACT_VIOLATION` | 1801 | runtime | FATAL | false | `t,failure_operator,replay_token` | `Contract violation in {failure_operator}` | Validate manifest/operator contracts | v1 |
| `INVALID_STAGE_TYPE` | 1802 | runtime | ERROR | false | `t,stage_id,replay_token` | `Invalid pipeline stage type` | Fix manifest pipeline stage type | v1 |
| `BATCH_SIZE_INCONSISTENT` | 1101 | data | ERROR | false | `t,dataset_key,replay_token` | `global_batch_size % world_size != 0` | Fix manifest batch/world_size | v1 |
| `INVALID_DATASET_KEY` | 1102 | data | ERROR | false | `t,dataset_key,replay_token` | `Dataset key not found in manifest` | Register dataset and fix key | v1 |
| `CARDINALITY_MISMATCH` | 1103 | data | FATAL | false | `t,dataset_key,registered_hash` | `Dataset cardinality does not match registered metadata` | Re-register immutable dataset metadata | v1 |
| `GLOBAL_POSITION_EXCEEDS_CARDINALITY` | 1104 | data | ERROR | false | `t,dataset_key,global_position,cardinality` | `Global position exceeds dataset cardinality` | Reset cursor or fix cardinality metadata | v1 |
| `API_SIGNATURE_MISMATCH` | 1001 | config | ERROR | false | `t,interface_id,schema_hash` | `API signature mismatch` | Regenerate bindings from interface contract | v1 |
| `API_SHAPE_MISMATCH` | 1002 | config | ERROR | false | `t,interface_id,payload_hash` | `API payload shape mismatch` | Fix request/response schema or caller payload | v1 |
| `API_TYPE_MISMATCH` | 1003 | config | ERROR | false | `t,interface_id,field_path` | `API payload type mismatch` | Align caller and schema scalar/object types | v1 |
| `PRIVACY_BUDGET_EXCEEDED` | 1401 | dp | FATAL | false | `t,failure_operator,cumulative_epsilon,target_epsilon` | `DP budget exceeded` | Increase noise/reduce steps | v1 |
| `INVALID_DP_CONFIG` | 1402 | dp | ERROR | false | `t,accountant,clipping_strategy` | `Invalid differential privacy configuration` | Fix DP hyperparameters and mode compatibility | v1 |
| `ACCOUNTANT_OVERFLOW` | 1403 | dp | FATAL | false | `t,accountant_type,state_hash` | `Privacy accountant overflow` | Switch to stable accountant grid or lower horizon | v1 |
| `ACCOUNTANT_DIVERGENCE` | 1404 | dp | FATAL | false | `t,accountant_type,state_hash` | `Privacy accountant diverged` | Use validated accountant settings | v1 |
| `NAN_IN_SIGMA` | 1405 | dp | FATAL | false | `t,sigma_map_hash` | `Sigma schedule contains NaN/Inf` | Clamp/validate scheduler outputs | v1 |
| `INVALID_GRADIENT` | 1406 | dp | ERROR | false | `t,grad_hash` | `Gradient tensor invalid for DP path` | Validate backward output and clipping inputs | v1 |
| `RNG_CONSUMPTION_VIOLATION` | 1407 | dp | FATAL | false | `t,failure_operator,rng_offset_before,rng_offset_after` | `RNG consumption contract violated` | Fix operator RNG declaration/usage | v1 |
| `ALIGNMENT_VIOLATION` | 1301 | tmmu | FATAL | false | `t,arena,logical_slot` | `Memory alignment violation` | Increase alignment or remap slot | v1 |
| `TMMU_ALLOCATION_FAILURE` | 1302 | tmmu | FATAL | false | `t,arena,peak_required_bytes` | `TMMU allocation failed` | Increase arena capacity or reduce footprint | v1 |
| `ALLOCATION_OVERFLOW` | 1303 | tmmu | FATAL | false | `t,arena,offset,size` | `Allocation offset overflow` | Reduce allocation size or split arenas | v1 |
| `ARENA_TOO_SMALL` | 1304 | tmmu | ERROR | false | `t,arena,capacity,required` | `Arena capacity insufficient` | Increase capacity or enable recomputation | v1 |
| `LIVENESS_CYCLE` | 1305 | tmmu | ERROR | false | `t,ir_hash,node_id` | `Liveness analysis cycle detected` | Fix IR DAG and liveness metadata | v1 |
| `INVALID_IR_SHAPES` | 1306 | tmmu | ERROR | false | `t,ir_hash,node_id` | `Invalid static shapes for allocation` | Provide complete static shape metadata | v1 |
| `ADDRESS_COLLISION` | 1307 | tmmu | FATAL | false | `t,arena,logical_slot` | `Virtual address collision` | Regenerate plan with valid injective mapping | v1 |
| `BACKEND_CONTRACT_VIOLATION` | 1601 | backend | FATAL | false | `t,backend_binary_hash,driver_runtime_fingerprint_hash,failure_operator` | `Backend failed determinism contract` | Use certified driver build | v1 |
| `INVALID_IR` | 1201 | model | ERROR | false | `t,ir_hash,node_id` | `Invalid IR structure` | Validate/repair IR before execution | v1 |
| `CYCLE_DETECTED` | 1202 | model | ERROR | false | `t,ir_hash,node_id` | `Cycle detected in IR DAG` | Fix graph topology | v1 |
| `SHAPE_MISMATCH` | 1203 | model | ERROR | false | `t,node_id,shape_in,shape_expected` | `Tensor shape mismatch during dispatch` | Fix model IR shapes or adapter mapping | v1 |
| `PRIMITIVE_UNSUPPORTED` | 1602 | backend | ERROR | false | `t,node_id,instr,backend_binary_hash` | `Backend primitive unsupported` | Implement primitive or choose compatible backend | v1 |
| `DISTRIBUTED_COMMUNICATION_FAILURE` | 1803 | distributed | FATAL | true | `t,world_size,collective_id` | `Deterministic collective failed or timed out` | Retry with stable network or fallback topology | v1 |
| `COUNTER_OVERFLOW` | 1804 | runtime | FATAL | false | `t,failure_operator,counter_name,counter_value` | `Monotone uint64 counter overflow detected` | Reduce run horizon or rotate run/checkpoint before overflow | v1 |
| `ATTESTATION_FAILURE` | 1701 | security | FATAL | false | `t,quote_hash,policy_bundle_hash` | `Attestation verification failed` | Rotate trust roots/quotes and re-attest | v1 |
| `INVALID_OBJECTIVE` | 1204 | model | FATAL | false | `t,failure_operator,objective_value` | `Objective invalid (NaN/Inf/out-of-contract)` | Fix loss/objective numeric path and policy guards | v1 |
| `REPLAY_DIVERGENCE` | 1901 | replay | FATAL | false | `t,field_path,replay_token` | `Replay divergence detected` | Re-run with captured profile and inspect first divergence event | v1 |
| `TRACE_CAP_EXCEEDED_MANDATORY` | 1501 | trace | FATAL | false | `t,run_id,trace_policy_hash` | `Trace cap exceeded for mandatory record kinds` | Raise trace caps or reduce optional sampling load | v1 |
| `WAL_CORRUPTION` | 1502 | trace | FATAL | false | `t,run_id,wal_seq,record_hash` | `WAL chain corrupted or non-contiguous` | Rebuild WAL from durable snapshot or rollback run | v1 |
| `BASELINE_MISSING` | 1503 | trace | ERROR | false | `t,window_id,baseline_ref` | `Monitoring baseline artifact/window missing or invalid` | Register/fix baseline artifact and retry deterministic drift evaluation | v1 |

Numeric range reservation:
- 1000-1099 config/schema
- 1100-1199 data/sampler
- 1200-1299 modelir/executor/objective
- 1300-1399 tmmu/memory
- 1400-1499 differential privacy
- 1500-1599 trace/checkpoint
- 1600-1699 backend
- 1700-1799 security
- 1800-1899 distributed/runtime
- 1900-1999 replay/determinism

Lint invariant:
- Build/test must fail if any referenced `code_id` in any spec is absent from this registry.

Derivation rules (normative):
- `subsystem` in `ErrorRecord` is derived from registry `category` for `code_id` with exact bytewise equality.
- `privacy_class` default is `INTERNAL` for all registry codes unless overridden below:
  - `ATTESTATION_FAILURE` -> `CONFIDENTIAL`
  - `PRIVACY_BUDGET_EXCEEDED` -> `CONFIDENTIAL`
  - `ACCOUNTANT_OVERFLOW` -> `CONFIDENTIAL`
  - `ACCOUNTANT_DIVERGENCE` -> `CONFIDENTIAL`
  - `TRACE_CAP_EXCEEDED_MANDATORY` -> `INTERNAL`
- `deterministic_fields_required` keys must be present exactly by key name either as top-level `ErrorRecord` fields or as keys in `diagnostics`.
- Canonical field name is `failure_operator`; `operator_id` is forbidden in new records and accepted only as deprecated input alias for backward-compat validation.

### II.G ErrorRecord Schema (Normative)
- Required fields:
  - `code_id:string`
  - `numeric_code:uint32`
  - `severity:enum("FATAL","ERROR","WARN")`
  - `subsystem:enum("config","data","model","tmmu","dp","trace","backend","security","distributed","runtime","replay")`
  - `t:uint64`
  - `rank:uint32`
  - `failure_operator:string`
  - `replay_token:bytes32`
  - `message:string`
  - `retryable:bool`
  - `privacy_class:enum("PUBLIC","INTERNAL","CONFIDENTIAL")`
- Optional fields:
  - `diagnostics:map<string, scalar|string|bytes>` with deterministic key ordering and size cap.

---
## 3) Initialization
1. Load registry.
2. Validate uniqueness and payload schemas.
3. Initialize counters.

---
## 4) Operator Manifest
- `UML_OS.Error.Emit_v1`
- `UML_OS.Error.ValidateRecord_v1`
- `UML_OS.Error.SerializeRecord_v1`

---
## 5) Operator Definitions

Template conformance note (III.A): each operator definition in this section is interpreted with the full EQC operator template fields. When a field is not repeated inline, the section-level defaults are: explicit typed signatures, deterministic ordering/tie handling, declared numerical policy inheritance, deterministic failure semantics (0.K), explicit dependencies, and VII.B test-vector coverage.

**Operator:** `UML_OS.Error.Emit_v1`  
**Category:** Error  
**Signature:** `(code, context -> error_record)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** emits standardized failure record.

**Operator:** `UML_OS.Error.ValidateRecord_v1`  
**Category:** Error  
**Signature:** `(error_record -> ok)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** checks required fields and payload schema, then enforces per-`code_id` deterministic field requirements from registry.
**Validation requirements:**
- `code_id` MUST exist in registry and `numeric_code`/`severity`/`retryable` MUST match registry.
- `subsystem` MUST equal derived subsystem from registry `category`.
- `privacy_class` MUST equal derived privacy class from derivation rules above.
- For each key in `deterministic_fields_required` for `code_id`, key MUST exist either:
  - as top-level field of `ErrorRecord`, or
  - in `diagnostics` under exactly the same key name.
- Deprecated alias handling: if `diagnostics.operator_id` is present and `failure_operator` missing for backward compatibility inputs, validator MAY map alias only for legacy ingest then MUST emit canonical `failure_operator` on serialization.

**Operator:** `UML_OS.Error.SerializeRecord_v1`  
**Category:** Error  
**Signature:** `(error_record -> bytes)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** canonical encoding for trace/certificate inclusion.

---
## 6) Procedure
```text
1. Emit_v1(code, context)
2. ValidateRecord_v1 (global schema + per-code required fields)
3. SerializeRecord_v1
4. Return record + bytes
```

---
## 7) Trace & Metrics
### Logging rule
All failures must log one canonical record.
### Trace schema
- `run_header`: registry_version
- `iter`: error_code, operator, t, replay_token
- `run_end`: failure summary
### Metric schema
- `error_code_frequency`, `first_failure_t`
### Comparability guarantee
Comparable iff registry and serialization rules are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
Ensures code uniqueness, schema completeness, deterministic serialization.
#### VII.B Operator test vectors (mandatory)
Known contexts map to exact error records.
#### VII.C Golden traces (mandatory)
Golden serialized error bytes for canonical contexts.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for emitted record and serialization.
#### VIII.B Allowed refactor categories
- internal formatting optimizations preserving outputs.
#### VIII.C Equivalence test procedure (mandatory)
Exact record and byte-level comparison.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- registry snapshot and counters.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- identical future error records for same contexts.

FILE: layer1-foundation/Normativity-Legend.md
=============================================
# UML_OS Normativity Legend
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Governance.NormativityLegend_v1`  
**Purpose (1 sentence):** Define normative interpretation tags used across UML_OS contracts.  
**Spec Version:** `UML_OS.Governance.NormativityLegend_v1` | 2026-02-21 | Authors: Olejar Damir  
**Domain / Problem Class:** Contract interpretation and governance clarity.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Governance.NormativityLegend_v1`
- **Purpose (1 sentence):** Canonical normativity legend.
### 0.A Objective Semantics
- Remove interpretation ambiguity between enforceable protocol rules and explanatory text.
### 0.B Reproducibility Contract
- Replayable given `(legend_version, tagged_sections)`.
### 0.C Numeric Policy
- N/A.
### 0.D Ordering and Tie-Break Policy
- N/A.
### 0.E Parallel, Concurrency, and Reduction Policy
- N/A.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for interpretation of tags.
### 0.G Operator Manifest
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- This legend applies across all contracts under `docs/`.
### 0.I Outputs and Metric Schema
- Outputs: `(normativity_interpretation_report)`.
### 0.J Spec Lifecycle Governance
- Tag definitions are MAJOR-governed.
### 0.K Failure and Error Semantics
- Mis-tagged required sections are deterministic lint failures.
### 0.L Input/Data Provenance
- Inputs are contract sections and heading metadata.

### 0.Z EQC Mandatory Declarations Addendum
- `stochastic_used: false`
- `seed_space: N/A`
- `prng_family: N/A`
- `rng_ownership: N/A`
- `numeric_kernel: N/A`
- `tolerances: N/A`
- `determinism_level: BITWISE`
- `error_trace: inherited from docs/layer1-foundation/Error-Codes.md`

---
## 2) Normativity Tags (Normative)
- `Normative`:
  - Enforceable requirements with conformance impact.
  - Violations are deterministic failures for compliant implementations.
- `Informative`:
  - Explanatory guidance and examples.
  - Does not modify conformance requirements.
- `Template-only`:
  - Structural EQC completeness content with no runtime/protocol semantics.
  - Must not be interpreted as execution behavior requirements.

---
## 3) Required Usage Rule
- Every contract SHOULD mark section headings with one of:
  - `(Normative)`
  - `(Informative)`
  - `(Template-only)`
- If a section is untagged, interpretation defaults to:
  - sections `0.*`, `II.*`, `4)`, `5)`, `6)`: `Normative`
  - examples/tutorial walkthroughs: `Informative`
  - structural compliance placeholders: `Template-only`

## 6) Procedure
```text
1. Read target contract section.
2. Resolve explicit tag if present.
3. If absent, apply default mapping rule from Section 3.
4. Emit deterministic interpretation record for lint/audit tooling.
```

FILE: layer1-foundation/Operator-Registry-Schema.md
===================================================
# UML_OS Operator Registry Schema Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Registry.OperatorRegistrySchema_v1`  
**Purpose (1 sentence):** Define the authoritative machine-readable schema for `contracts/operator_registry.cbor` and its deterministic validation rules.  
**Spec Version:** `UML_OS.Registry.OperatorRegistrySchema_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Interface governance and contract integrity.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Registry.OperatorRegistrySchema_v1`
- **Purpose (1 sentence):** Canonical operator registry schema and validation.
### 0.A Objective Semantics
- This is a schema/registry integrity contract (not an optimization objective).
- Primary comparison rule: deterministic schema validity and digest equality.
- Invalid objective policy: schema violations are deterministic failures.
### 0.B Reproducibility Contract
- Replayable given `(registry_schema_version, canonical_cbor_bytes, digest_catalog_blob, error_codes_blob, capability_catalog_blob, schema_catalog_blob, expected_catalog_hashes)`.
- Hash/token paths use `SHA-256(CBOR_CANONICAL(...))`.
 - `CBOR_CANONICAL` is normative as defined in `docs/layer1-foundation/Canonical-CBOR-Profile.md`.
### 0.C Numeric Policy
- Integer fields are unsigned fixed ranges.
- Resolved digest values are `bytes32`; `digest_ref` fields are textual references resolved deterministically to `bytes32`.
### 0.D Ordering and Tie-Break Policy
- Registry records sorted by `(operator_id, version_num)` where:
  - `operator_id` comparison is bytewise UTF-8 lexicographic, case-sensitive, locale-independent.
  - `version_num = parse_uint(version[1:])` from `version` format `^v[0-9]+$`, compared numerically (not lexicographically).
### 0.E Parallel, Concurrency, and Reduction Policy
- Validation can be parallelized but merged in deterministic key order.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for validation reports and computed hashes.
### 0.G Operator Manifest
- `UML_OS.Registry.ValidateOperatorRegistry_v1`
- `UML_OS.Registry.ComputeRegistryHash_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Registry file path: `contracts/operator_registry.cbor`.
- Registry file MUST be stored in canonical CBOR form as defined by `CBOR_CANONICAL` (not only logically decodable to canonical form).
### 0.I Outputs and Metric Schema
- Outputs: `(validation_report, operator_registry_root_hash)`.
- Metrics: `operators_count`, `schema_errors`.
- `operator_registry_root_hash` output encoding: raw `bytes32` (hex/base64 are presentation-only views).
- `validation_report` is emitted as a canonical CBOR map and includes the metrics fields.
### 0.J Spec Lifecycle Governance
- Required field changes are MAJOR.
### 0.K Failure and Error Semantics
- Abort-only with deterministic failure record.
- Validation failures MUST map to deterministic `code_id` values as defined in Â§5 `validation_report` schema.
- These `code_id` values MUST map to authoritative error catalog entries in `docs/layer1-foundation/Error-Codes.md`.
### 0.L Input/Data Provenance
- Input registry blob must be content-addressed and immutable.
- All input catalog blobs (`digest_catalog_blob`, `error_codes_blob`, `capability_catalog_blob`, `schema_catalog_blob`) MUST be canonical CBOR.

---
## 2) System Model
### I.A Persistent State
- `registry_schema`.
### I.B Inputs and Hyperparameters
- `operator_registry_blob`.
- `digest_catalog_blob` (canonical CBOR; schema per `docs/layer1-foundation/Digest-Catalog.md`)
- `error_codes_blob` (canonical CBOR; schema per `docs/layer1-foundation/Error-Codes.md`)
- `capability_catalog_blob` (canonical CBOR; schema per `docs/layer2-specs/Security-Compliance-Profile.md`)
- `schema_catalog_blob` (canonical CBOR; schema-artifact index catalog)
- `expected_catalog_hashes:map<string,bytes32>` (canonical CBOR map with keys `digest_catalog`, `error_codes_catalog`, `capability_catalog`, `schema_catalog`; empty map means no expected-hash comparison)
  - unknown keys in `expected_catalog_hashes` MUST be ignored and MUST NOT affect validation results.
### I.C Constraints and Feasible Set
- Valid iff all required keys/types/enum values pass.
### I.D Transient Variables
- decoded records and diagnostics.
### I.E Invariants and Assertions
- unique `(operator_id, version)` keys.

### II.E DigestRef and Canonical Text Rules (Normative)
- `digest_ref` textual grammar:
  - inline digest: `sha256:<hex64>`
  - catalog label: `sha256:<label>`
- Disambiguation:
  - if `<tail>` matches `^[0-9a-fA-F]{64}$`, treat as inline digest and normalize to lowercase before parsing.
  - otherwise treat as catalog label and resolve using the provided `digest_catalog_blob` (whose schema is defined in `docs/layer1-foundation/Digest-Catalog.md`).
- Resolution output:
  - resolved digest is always `bytes32`.
  - resolution cycles are invalid and MUST fail deterministically with `DIGEST_RESOLUTION_FAILURE`.
- Text constraints (all string fields in operator records):
  - strings MUST be valid UTF-8.
  - fields requiring NFC validity (including `operator_id`, `version`, `method`, `required_capabilities[*]`, `owner_team`, `replacement_operator_id`) MUST already be NFC-normalized; non-NFC values MUST be rejected deterministically during validation.
  - comparisons are bytewise UTF-8, case-sensitive, locale-independent.
  - `operator_id`, `version`, `method`, and `required_capabilities[*]` MUST match `^[A-Za-z0-9_\\-\\.]{1,128}$`.

### II.F Canonical Operator Record Schema (Normative)
- Top-level registry object schema:
  - `registry_schema_version:uint32`
  - `operator_records:array<operator_record>`
  - for this contract version, `registry_schema_version` MUST equal `1`.
  - `operator_records` MUST be stored in-file already sorted by `0.D` ordering (unique canonical file representation for content addressing).
- `side_effect_enum` allowed values:
  - `ADVANCES_RNG`, `ADVANCES_CURSOR`, `MUTATES_ACCOUNTANT`, `MUTATES_MODEL_STATE`, `PERFORMS_IO`, `NETWORK_COMM`, `ALLOCATES_MEMORY`.
- Required fields per operator record:
  - `operator_id:string`
  - `version:string` (normalized format `v<nonnegative-integer>`, regex `^v[0-9]+$`)
  - `method:string`
  - `surface:enum("SYSCALL","SERVICE")`
  - `request_schema_digest:digest_ref`
  - `response_schema_digest:digest_ref`
  - `signature_digest:bytes32`
  - `side_effects:array<side_effect_enum>` (sorted, unique by bytewise UTF-8 enum-id string order; allowed values listed above)
  - `allowed_error_codes:array<error_code_id>` where `error_code_id:string` and value MUST exist in the provided `error_codes_blob` (whose schema is defined in `docs/layer1-foundation/Error-Codes.md`) (sorted, unique by bytewise UTF-8 code-id order)
  - `purity_class:enum("PURE","STATEFUL","IO")`
  - `required_capabilities:array<string>` (sorted, unique by bytewise UTF-8 lexicographic order; each capability id matches `^CAP_[A-Z0-9_]{1,64}$`)
  - `idempotent:bool`
  - `rng_usage:enum("NONE","PHILOX4x32_10")`
  - `determinism_class:enum("DETERMINISTIC","STOCHASTIC","MIXED")`
- Optional fields:
  - `owner_team:string`
  - `deprecated:bool`
  - `replacement_operator_id:string`
- Optional field constraints:
  - `owner_team`, when present, MUST match `^[A-Za-z0-9_\\-\\.]{1,128}$`.
  - if `deprecated=true`, `replacement_operator_id` SHOULD be present.
  - if `replacement_operator_id` is present, it MUST resolve to an existing `operator_id` in the same registry.
  - `replacement_operator_id`, when present, MUST match `^[A-Za-z0-9_\\-\\.]{1,128}$`.
- Enum CBOR representation rule (all enum-typed fields in this section):
  - enum values MUST be encoded as UTF-8 text strings equal to their symbol ids.
- Capability validation rule:
  - each `required_capabilities` entry MUST exist in the provided `capability_catalog_blob` (whose schema is defined in `docs/layer2-specs/Security-Compliance-Profile.md`).
- Method/surface compatibility rules:
  - if `surface="SYSCALL"`, `method` MUST be one of `CALL|INTERNAL`.
  - if `surface="SERVICE"`, `method` MUST be one of `HTTP|GRPC|CALL`.
- Optional-field encoding rule:
  - missing optional fields MUST be omitted from canonical CBOR (no implicit defaults and no implicit null insertion).
- Purity/determinism compatibility rule:
  - `purity_class="PURE"` with `determinism_class="STOCHASTIC"` is invalid unless `rng_usage != "NONE"`.
- Unknown-field policy:
  - operator records MUST NOT contain fields outside required+optional sets above.
  - top-level registry object MUST NOT contain unknown fields.
  - presence of unknown fields MUST emit `UNKNOWN_FIELD`.
- Canonical CBOR enforcement:
  - indefinite-length arrays/maps/strings are forbidden.
  - map keys must follow canonical sorting rules from `Canonical-CBOR-Profile.md`.

### II.G Registry Hash (Normative)
- Canonical operator list is `operator_records` in the ordering defined by `0.D`.
- `operator_registry_root_hash = SHA-256(CBOR_CANONICAL(["operator_registry_v1", registry_schema_version, operator_records]))`.
- `registry_hash` is an exact alias of `operator_registry_root_hash` for backward compatibility.
- Version/tag consistency check:
  - the numeric suffix in domain tag `operator_registry_vN` used for hash preimage MUST equal top-level `registry_schema_version`.

### II.H SignatureDigest Rule (Normative, Global)
- Signature digest computation is defined only here and consumed by all interface/mapping/backend docs.
- Preimage:
  - `signature_digest = SHA-256(CBOR_CANONICAL(["sig_v1", operator_id, version, method, request_schema_digest_resolved, response_schema_digest_resolved, sorted(side_effects), sorted(allowed_error_codes)]))`.
- Sorting semantics for preimage arrays:
  - `sorted(side_effects)` and `sorted(allowed_error_codes)` use the same bytewise UTF-8 lexicographic order defined in `0.D`.
- `request_schema_digest_resolved` and `response_schema_digest_resolved` are resolved bytes32 values after `digest_ref` resolution.
- If any `digest_ref` fails resolution, validation MUST fail deterministically with `DIGEST_RESOLUTION_FAILURE`; no placeholder or partial signature digest is permitted.
- `signature_digest` correctness check is mandatory:
  - each operator recordâ€™s stored `signature_digest` MUST equal the recomputed preimage hash from this section.
- Referenced-schema existence check:
  - resolved request/response schema digests MUST resolve to known schema artifacts in the provided `schema_catalog_blob`; unresolved references MUST emit `DIGEST_RESOLUTION_FAILURE`.
- Any mismatch with this rule during validation MUST emit a deterministic code from Â§5 (`DIGEST_RESOLUTION_FAILURE` or `SIGNATURE_MISMATCH`, as applicable).

### II.I Operator Registry Root Commitment (Normative)
- Authoritative commitment is `operator_registry_root_hash` from `II.G`.
- `operator_registry_root_hash` is the required value bound as `operator_contracts_root_hash` in execution certificates and checkpoint headers.
- Version-evolution rule:
  - MAJOR schema/version change MUST update domain tag prefix in `II.G` (for example `operator_registry_v2`).
- External catalog pinning rule:
  - validation MUST compute catalog hashes from provided catalog blobs and include them in `validation_report`.
- `digest_catalog_hash`, `error_codes_catalog_hash`, `capability_catalog_hash`, and `schema_catalog_hash` are computed as `SHA-256` of the corresponding canonical CBOR input blob bytes.
  - caller-side trust verification compares reported catalog hashes against expected trusted hashes.
  - validator MUST compare computed hashes against `expected_catalog_hashes` when the corresponding expected key is present, and MUST emit `CATALOG_HASH_MISMATCH` on mismatch.

---
## 3) Initialization
1. Load `contracts/operator_registry.cbor`.
2. Decode canonical CBOR.
3. If CBOR decoding fails or canonical-form checks fail, emit deterministic `MALFORMED_CBOR` and abort.
4. Initialize validation diagnostics.

---
## 4) Operator Manifest
- `UML_OS.Registry.ValidateOperatorRegistry_v1`
- `UML_OS.Registry.ComputeRegistryHash_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Registry.ValidateOperatorRegistry_v1`  
**Category:** Governance  
**Signature:** `(registry_blob, digest_catalog_blob, error_codes_blob, capability_catalog_blob, schema_catalog_blob, expected_catalog_hashes -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates required fields, enum values, key uniqueness, sorted list invariants, method/surface compatibility, digest_ref resolution, per-record signature_digest correctness, existence of `allowed_error_codes` in error catalog, existence of `required_capabilities` in capability catalog, validity of `replacement_operator_id` references, schema version/tag consistency, and existence of resolved request/response schema digests in schema catalog.
**validation_report minimum schema (canonical CBOR map):**
  - `is_valid:bool`
  - `root_hash?:bytes32` (present when valid)
  - `operators_count:uint64`
  - `schema_errors:uint64`
  - `digest_catalog_hash:bytes32`
  - `error_codes_catalog_hash:bytes32`
  - `capability_catalog_hash:bytes32`
  - `schema_catalog_hash:bytes32`
  - `errors:array<{code_id:enum("MALFORMED_CBOR","MISSING_REQUIRED_FIELD","UNKNOWN_FIELD","INVALID_FIELD_TYPE","DIGEST_RESOLUTION_FAILURE","SIGNATURE_MISMATCH","INVALID_ENUM_VALUE","INVALID_SORT_ORDER","DUPLICATE_VALUE","INVALID_METHOD_FOR_SURFACE","INVALID_PURITY_DETERMINISM_COMBINATION","UNKNOWN_CAPABILITY","UNKNOWN_ERROR_CODE","INVALID_OPERATOR_REFERENCE","SCHEMA_VERSION_MISMATCH","CATALOG_HASH_MISMATCH","CATALOG_PARSE_ERROR"), path:string}>`
  - `path` format is RFC 6901 JSON Pointer over a virtual root object with keys:
    - `/registry` for registry object paths (e.g., `/registry/operator_records/3/method`)
    - `/digest_catalog`, `/error_codes_catalog`, `/capability_catalog`, `/schema_catalog` for catalog-level failures
  - deeper catalog paths are allowed (for example `/digest_catalog/entries/5`) using catalog-local schema structure.
  - `CATALOG_HASH_MISMATCH` path MUST be the corresponding catalog root path (`/digest_catalog`, `/error_codes_catalog`, `/capability_catalog`, or `/schema_catalog`).
  - error ordering is deterministic by bytewise UTF-8 lexicographic `(path, code_id)`.

**Operator:** `UML_OS.Registry.ComputeRegistryHash_v1`  
**Category:** Governance  
**Signature:** `(validated_registry -> operator_registry_root_hash)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** computes `operator_registry_root_hash = SHA-256(CBOR_CANONICAL(["operator_registry_v1", registry_schema_version, operator_records]))` using canonical serialization profile `CanonicalSerialization_v1` from `docs/layer1-foundation/Canonical-CBOR-Profile.md`, where `operator_records` are ordered by `(operator_id, version_num)` and `version_num = parse_uint(version[1:])`.

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

---
## 6) Procedure
```text
1. ValidateOperatorRegistry_v1 (with explicit catalog blobs and expected_catalog_hashes; derive/pin catalog hashes)
2. ComputeRegistryHash_v1
3. Return report + operator_registry_root_hash
```

---
## 7) Trace & Metrics
### Logging rule
- Validation emits deterministic registry diagnostics.
### Trace schema
- `run_header`: `registry_schema_version:uint32`
- `iter`: array of pairs `[operator_id:string, status:enum(valid|invalid)]` in registry order
- `run_end`: `operator_registry_root_hash:bytes32`
### Trace encoding (normative)
- trace output MUST be canonical CBOR map with fixed keys:
  - `{ "run_header": uint, "iter": [ [tstr, tstr], ... ], "run_end": bytes }`
### Trace status enum
- `status` MUST be one of: `valid`, `invalid`.
### Metric schema
- `operators_count`, `schema_errors`
### Comparability guarantee
- Comparable iff schema version and canonical hash rule are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- all required fields present and typed.
- digest_ref resolution must succeed for all digest_ref fields.
- optional fields must be omitted when absent (no implicit default/null materialization).
- `signature_digest` must match recomputation for every record.
- `side_effects`, `allowed_error_codes`, `required_capabilities` must be present even when empty (encoded as empty arrays).
- empty `side_effects` array is the only valid representation of â€œno side effectsâ€ (no `NONE` enum token).
- sorted arrays must also be duplicate-free; duplicates MUST emit `DUPLICATE_VALUE`.
- method/surface mismatch MUST emit `INVALID_METHOD_FOR_SURFACE`.
- purity/determinism incompatibility MUST emit `INVALID_PURITY_DETERMINISM_COMBINATION`.
- unknown capability MUST emit `UNKNOWN_CAPABILITY`.
- unknown allowed error code MUST emit `UNKNOWN_ERROR_CODE`.
- missing/invalid replacement operator reference MUST emit `INVALID_OPERATOR_REFERENCE`.
- registry version vs hash-tag suffix mismatch MUST emit `SCHEMA_VERSION_MISMATCH` at path `/registry/registry_schema_version`.
- expected-vs-derived catalog hash mismatch MUST emit `CATALOG_HASH_MISMATCH` at the corresponding catalog root path.
- if any catalog blob fails canonical-CBOR decoding/parsing, validator MUST emit `CATALOG_PARSE_ERROR` at the corresponding catalog root path.
#### VII.B Operator test vectors (mandatory)
- valid/invalid registry fixtures.
#### VII.C Golden traces (mandatory)
- golden registry hash snapshots.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for validation report and registry hash.
#### VIII.B Allowed refactor categories
- parser/runtime implementation changes preserving outputs.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare of report and registry hash.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- `last_validated_registry_hash:bytes32` (present only if validation completed successfully).
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- Validation is a pure function; checkpoints store final results only.
- Intermediate resume is not supported; interrupted validation MUST be rerun from the beginning.

---
## 11) Strict-Ingest-by-Default Policy (Normative)
- All ingest paths (SDKs, services, CI tooling, registry publishers) MUST run strict validation mode by default:
  - reject unknown fields,
  - reject non-canonical ordering,
  - reject duplicate entries in sorted arrays,
  - reject digest/signature mismatches.
- Compatibility shims MAY exist only behind explicit opt-in flags and MUST emit warnings with migration deadlines.

FILE: layer1-foundation/Redaction-Policy.md
===========================================
# UML_OS Redaction Policy Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Security.RedactionPolicy_v1`
**Purpose (1 sentence):** Define deterministic field-level redaction rules that preserve verifiability while preventing sensitive leakage.
**Spec Version:** `UML_OS.Security.RedactionPolicy_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Deterministic privacy-preserving telemetry transformation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Security.RedactionPolicy_v1`
- **Purpose:** Deterministic redaction contract for trace and governance records.

### 0.A Objective Semantics
- This contract performs deterministic policy validation and deterministic record transformation.
- Primary objective: eliminate raw sensitive payload exposure while preserving replay/audit comparability.

### 0.B Reproducibility Contract
- Replayable given `(record_blob, schema_version, redaction_mode, redaction_policy_hash, redaction_key_id, preimage_format_id)`.
- `record_blob` MUST be canonical CBOR encoded.
- Canonical CBOR profile is RFC 8949 Section 4.2.1 (Core Deterministic Encoding Requirements), with additional constraints:
  - Floating-point values MUST be encoded as IEEE 754 binary64.
  - Map keys MUST be sorted by bytewise lexicographic order of canonical key encodings.
- Policy object is loaded by `redaction_policy_hash`.

### 0.C Numeric Policy
- This section also defines deterministic transform-selection policy.
- Effective transform decision is deterministic:
  1. If `field_transform_map` has path entry, use that transform.
  2. Else if classification is `CONFIDENTIAL`, use input `redaction_mode`.
  3. Else use `NONE`.
- `BUCKET_V1` is allowed only for numeric fields.
- For `CONFIDENTIAL` fields, effective transform MUST be `HMAC_SHA256_V1` or `BUCKET_V1`; `NONE` is invalid.

### 0.D Ordering and Tie-Break Policy
- Canonical field path is a CBOR array path (`FieldPath`) of UTF-8 string keys and non-negative uint array indices.
- Canonical traversal order is bytewise lexicographic order of canonical CBOR bytes of `FieldPath`.
- All audit/path sorting MUST use this same ordering.

### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel redaction is allowed only if final output is reassembled by canonical path ordering.
- Deterministic merge: gather `(path, value, audit_entry)` triples, then sort by canonical path bytes before emit.

### 0.F Environment and Dependency Policy
- HMAC implementation version and key policy are committed by `redaction_policy_hash`.
- `redaction_key_id` must map to stable key bits for replay windows.

### 0.G Operator Manifest
- `UML_OS.Security.RedactRecord_v1`
- `UML_OS.Security.ComputeRedactionPolicyHash_v1`
- `UML_OS.Security.ValidateRedactionCoverage_v1`
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- `UML_OS.Security.*` namespace.

### 0.I Outputs and Metric Schema
- Outputs: `(redacted_record, redaction_audit)`.
- `redacted_record` MUST be encoded as canonical CBOR using the same profile defined in Section 0.B.
- Validation output schema:
  - `coverage_report = { valid: bool, errors: array<tstr> }` (canonical CBOR map).
- `redaction_audit` schema:
  - `record_id:tstr` (extracted from original input at top-level path `["record_id"]` before redaction; if absent or non-text, use `""`)
  - `policy_hash:bytes32`
  - `redaction_key_id:tstr`
  - `redacted_fields:array<AuditEntry>` sorted by canonical path order
  - `redacted_field_count:uint64`
  - `forbidden_raw_field_count:uint64`
- `AuditEntry`:
  - `path:FieldPath`
  - `transform:enum("NONE","HMAC_SHA256_V1","BUCKET_V1")`
  - `classification:enum("PUBLIC","INTERNAL","CONFIDENTIAL")`
- `forbidden_raw_field_count` = count of redactable fields found untransformed in output; MUST be `0` on success.
- A field is redactable iff its effective transform (Section 0.C) is not `NONE`.

### 0.J Spec Lifecycle Governance
- Any change in field-path representation, transform semantics, preimage format, or bucketization is MAJOR.

### 0.K Failure and Error Semantics
- On fatal error, `RedactRecord_v1` MUST NOT return outputs.
- It MUST emit deterministic `CONTRACT_VIOLATION` via `UML_OS.Error.Emit_v1` with reason code.
- Fatal reasons include:
  - `POLICY_NOT_FOUND`
  - `KEY_NOT_FOUND`
  - `KEY_EXPIRED`
  - `SCHEMA_MISMATCH`
  - `MANDATORY_FIELD_MISSING`
  - `MANDATORY_FIELD_REDACTED`
  - `INVALID_BUCKET_RULES`
  - `INVALID_PATH_IN_POLICY`
  - `TRANSFORM_TYPE_MISMATCH`
  - `KEY_NOT_AUTHORIZED`
  - `BUCKET_VALUE_NAN`
  - `NULL_VALUE_FOR_BUCKET`
  - `INVALID_PREIMAGE_FORMAT`
  - `INVALID_REDACTION_MODE`
  - `SCHEMA_NOT_FOUND`
  - `INVALID_CBOR`
  - `INVALID_TRANSFORM_VALUE`
  - `INVALID_VALUE_TYPE`

### 0.L Input/Data Provenance
- Source schema hash and schema version are mandatory redaction inputs.

---
### 0.Z EQC Mandatory Declarations Addendum
- No stochastic operators in v1.
- Determinism level: `BITWISE` for `redacted_record` and `redaction_audit`.
- NaN/Inf policy for bucketization values:
  - NaN => abort (`BUCKET_VALUE_NAN`).
  - Â±Inf => clamp to boundary bucket as defined below.

## 2) System Model
### I.A Persistent State
- `redaction_policy_registry`
- key metadata registry with `not_before` / `not_after` validity window (both integer Unix epoch seconds, UTC)
- schema registry keyed by `schema_version`

### I.B Inputs and Hyperparameters
- `record_blob` (canonical CBOR map/object)
- `schema_version:tstr` (CBOR text string)
- `redaction_mode:enum("NONE","HMAC_SHA256_V1","BUCKET_V1")`
- `redaction_key_id:tstr`
- `redaction_policy_hash:bytes32`

### I.C Constraints and Feasible Set
- Policy paths must exist in schema.
- All map keys in records subject to this policy MUST be CBOR text strings.
- Mandatory verification fields must exist in record and remain unredacted.
- Composite and leaf handling must follow Section II.G.

### I.D Transient Variables
- canonical field paths
- canonical preimages
- transformed values
- coverage diagnostics

### I.E Invariants and Assertions
- No raw confidential payload in successful output.
- Mandatory verification fields present and unredacted.

### II.F Policy and Classification Schema (Normative)
Classifications:
- `PUBLIC`
- `INTERNAL`
- `CONFIDENTIAL`

Policy object (loaded by `redaction_policy_hash`) must contain:
- `policy_rules:map` (reserved in v1; implementations MUST ignore entries for forward compatibility)
- `field_classification_map:map<FieldPath, classification>`
- `field_transform_map:map<FieldPath, transform>` (optional overrides)
- `preimage_format_id:tstr` (v1 requires `redaction_v1`)
- `key_policy:map` with:
  - `allowed_key_ids:array<tstr>`
  - v1 implementations MUST ignore unknown `key_policy` fields for forward compatibility.
- `bucket_rules:map<FieldPath, array<float64>>`

### II.G Canonical Redaction Rules (Normative)
Transforms:
- `NONE`
- `HMAC_SHA256_V1`
- `BUCKET_V1`

Leaf/composite rules:
- Leaf = primitive schema type (`null`, `bool`, `number`, `string`, `bytes`).
- Composite = map/array.
- Default behavior: traverse composites recursively to leaves.
- If a composite path has explicit transform override/classification requiring transform, transform the whole composite value as one unit and skip descendants.

Field path (`FieldPath`):
- CBOR array with string keys and uint indices only.
- Map keys in paths are always strings.

Canonical field value:
- `field_value_canonical` is canonical CBOR bytes of value.
- For composite transformed as whole, use canonical CBOR of entire composite.
- For floats, encode as CBOR float64.
- Canonical CBOR reference: RFC 8949 deterministic encoding + project Canonical-CBOR profile.

HMAC preimage:
- `CBOR_CANONICAL(["redaction_v1", schema_version, field_path, field_value_canonical])`.
- HMAC output MUST be encoded in output record as CBOR byte string length 32.

Bucketization (`BUCKET_V1`):
- `bucket_rules[path] = [b0, b1, ..., bn]`, finite binary64, strictly increasing, `n>=1`.
- At least two boundaries required.
- Selection for numeric `x`:
  - Interpret `x` as the exact mathematical real number represented by canonical CBOR value encoding (independent of whether source numeric is integer or float).
  - Comparisons are exact real-number comparisons (no tolerance, no implementation-defined rounding).
  - if `x < b0` => bucket `0`.
  - for `i=0..n-2`: if `b_i <= x < b_{i+1}` => bucket `i`.
  - if `x >= b_n` => bucket `n-1`.
- Boundary comparisons are exact.
- NaN is invalid (abort with `BUCKET_VALUE_NAN`).
- Null is invalid for `BUCKET_V1` (abort with `NULL_VALUE_FOR_BUCKET`).
- Output representation: `"bucket_<index>"`, where `<index>` is decimal integer without leading zeros.
- Policy conflict rule: reject any ancestor/descendant overlap among effective transforms.
  - Let effective transform be resolved per Section 0.C.
  - For any two distinct paths `p` and `q` where one is a proper prefix of the other, it is invalid if both effective transforms are not `NONE`.
  - Such policy/configuration MUST be rejected.

### II.H Mandatory Unredacted Verification Fields
These fields are mandatory at top-level paths and must remain unredacted:
- `["record_id"]`
- `["replay_token"]`
- `["record_hash"]`
- `["trace_final_hash"]`
- `["policy_bundle_hash"]`
- `["authz_decision_hash"]`
- `["policy_gate_hash"]`
- `["checkpoint_hash"]`
- `["execution_certificate_hash"]`

### II.I Policy Hash Definition
- `redaction_policy_hash = SHA-256(CBOR_CANONICAL(["redaction_policy_v1", policy_rules, field_classification_map, field_transform_map, preimage_format_id, key_policy, bucket_rules]))`.

---
## 3) Initialization
1. Load schema from schema registry by `schema_version`.
2. Load policy by `redaction_policy_hash`.
3. Load key metadata by `redaction_key_id`; verify time window using Unix epoch seconds (UTC) integer comparison.
4. Verify `preimage_format_id == "redaction_v1"`; else abort with `INVALID_PREIMAGE_FORMAT`.
5. Verify `redaction_key_id` is in `key_policy.allowed_key_ids`; else abort with `KEY_NOT_AUTHORIZED`.
6. Run `ValidateRedactionCoverage_v1`; abort on failure.

---
## 4) Operator Manifest
- `UML_OS.Security.RedactRecord_v1`
- `UML_OS.Security.ComputeRedactionPolicyHash_v1`
- `UML_OS.Security.ValidateRedactionCoverage_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
External operator reference: `UML_OS.Error.Emit_v1` is defined in `docs/layer1-foundation/Error-Codes.md`.

**Operator:** `UML_OS.Security.RedactRecord_v1`
- **Category:** Security
- **Signature:** `(record_blob, schema_version, redaction_mode, redaction_key_id, redaction_policy_hash -> redacted_record, redaction_audit)`
- **Purity class:** IO
- **Determinism:** deterministic
- **Definition:**
  - Validates `redaction_mode` is one of `NONE | HMAC_SHA256_V1 | BUCKET_V1`; else abort with `INVALID_REDACTION_MODE`.
  - Resolves schema by `schema_version`; if missing, abort with `SCHEMA_NOT_FOUND`.
  - Decodes canonical CBOR record; if malformed or non-canonical, abort with `INVALID_CBOR`.
  - Traverses canonical paths and applies deterministic transform decision logic from 0.C.
  - For effective transform `BUCKET_V1`, runtime value at path MUST be numeric (CBOR int or float); otherwise abort with `INVALID_VALUE_TYPE`.
  - Missing optional fields are skipped and not audited in v1.
  - Missing mandatory fields cause abort.
  - Output record preserves exact input path presence/absence; only transformed field values differ.

**Operator:** `UML_OS.Security.ComputeRedactionPolicyHash_v1`
- **Category:** Security
- **Signature:** `(policy_rules, field_classification_map, field_transform_map, preimage_format_id, key_policy, bucket_rules -> redaction_policy_hash)`
- **Purity class:** PURE
- **Determinism:** deterministic
- **Definition:** Computes hash exactly per Section II.I.

**Operator:** `UML_OS.Security.ValidateRedactionCoverage_v1`
- **Category:** Security
- **Signature:** `(record_schema, redaction_policy_hash -> coverage_report)`
- **Purity class:** PURE
- **Determinism:** deterministic
- **Definition:**
  - Validates all policy-map keys are well-formed `FieldPath` values (CBOR array elements must be string key or uint index).
  - Validates all `field_transform_map` values are in allowed transform enum: `NONE | HMAC_SHA256_V1 | BUCKET_V1`.
  - Validates all policy paths exist in schema.
  - Validates transform-type compatibility (`BUCKET_V1` numeric only).
  - Validates mandatory fields non-redactable and present in schema.
  - Validates no mandatory field has transformed ancestor path (no proper-prefix path with effective transform != `NONE`).
  - Validates bucket boundaries finite/strictly increasing/min-length.
  - Validates each `CONFIDENTIAL` field effective transform is `HMAC_SHA256_V1` or `BUCKET_V1` (not `NONE`).
  - Validates bucket-rules completeness:
    - every effective `BUCKET_V1` field has corresponding `bucket_rules` entry,
    - every `bucket_rules` entry corresponds to effective `BUCKET_V1`.
  - Validates effective-transform ancestor/descendant conflict rule (no proper-prefix pair with both effective transforms != `NONE`).
  - All `errors` entries MUST be fatal reason codes defined in Section 0.K.
  - If multiple errors are detected, `errors` MUST be sorted lexicographically by code string.
  - Returns `coverage_report = { valid: bool, errors: array<tstr> }`; on success `valid=true` and `errors=[]`.

---
## 6) Procedure
1. Resolve schema by `schema_version` and policy by `redaction_policy_hash`; if schema missing, abort with `SCHEMA_NOT_FOUND`.
2. Validate key presence, validity window, and key authorization (`redaction_key_id in key_policy.allowed_key_ids`).
3. Validate `preimage_format_id == "redaction_v1"`.
4. Run `ValidateRedactionCoverage_v1`.
5. If `coverage_report.valid == false`, abort with first error in lexicographically sorted `coverage_report.errors`.
6. Transform record deterministically in canonical path order (or parallel with deterministic merge).
7. Assert mandatory fields present and unredacted.
8. Emit canonical `redaction_audit`.
9. Return `redacted_record`.

---
## 7) Trace & Metrics
### Logging rule
- Redaction decisions emit deterministic audit records without raw confidential payload values.

### Trace schema
- `run_header`: `redaction_mode`, `redaction_key_id`, `redaction_policy_hash`
- `iter`: `record_id`, `field_path:FieldPath` (canonical CBOR array path encoding), `transform`, `status`
- `run_end`: `coverage_status`, `redacted_field_count`, `forbidden_raw_field_count`

### Metric schema
- `redacted_field_count`
- `forbidden_raw_field_count`

### Comparability guarantee
- Comparable iff `redaction_policy_hash`, `redaction_mode`, `redaction_key_id`, `preimage_format_id`, and canonicalization policy are identical.

---
## 8) Validation
### VII.A Lint rules (mandatory)
- No undeclared transforms.
- No raw confidential fields in outputs.
- Field-path format and canonical traversal order compliance.
- Mandatory verification fields must be top-level and non-redactable.
- Reject policy paths absent from schema.
- Reject invalid bucket rules (non-finite, non-increasing, length < 2).
- Reject effective-transform prefix conflicts (no ancestor/descendant path pair may both have effective transforms != `NONE`).

### VII.B Operator test vectors (mandatory)
- HMAC preimage vectors.
- Bucket vectors including equality-to-boundary and out-of-range cases.
- Missing/expired-key failures.

### VII.C Golden traces (mandatory)
- Golden success traces and deterministic failure traces (with error reason codes).

---
## 9) Refactor & Equivalence
### VIII.A Equivalence levels
- `E0` for transformed outputs and audit hashes.

### VIII.B Allowed refactor categories
- Runtime optimizations preserving byte-identical outputs.

### VIII.C Equivalence test procedure (mandatory)
- Exact compare of `redacted_record` and `redaction_audit` hashes.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- `redaction_policy_hash`
- `redaction_key_id`
- `stream_cursor:uint64` (last fully processed record index in batch stream; single-record mode uses `0`)

### Serialization
- Canonical CBOR.

### Restore semantics
- Restore requires same policy hash and key id availability/immutability within replay window.
- For identical inputs and cursor state, restored run must produce identical outputs.

FILE: layer2-specs/AuthZ-Capability-Matrix.md
=============================================
# UML_OS Authorization Capability Matrix Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Security.AuthZCapabilityMatrix_v1`  
**Purpose (1 sentence):** Define deterministic operator-to-capability authorization requirements and policy evaluation outputs.  
**Spec Version:** `UML_OS.Security.AuthZCapabilityMatrix_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** RBAC/capability enforcement and auditability.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Security.AuthZCapabilityMatrix_v1`
- **Purpose (1 sentence):** Deterministic operator capability gating.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic authorization verdict correctness.
- Invalid objective policy: missing capability mapping is fatal.
### 0.B Reproducibility Contract
- Replayable given `(tenant_id, principal_id, operator_id, authz_policy_hash, capability_matrix_hash)`.
### 0.C Numeric Policy
- N/A except deterministic hashing and enum handling.
### 0.D Ordering and Tie-Break Policy
- Capabilities sorted lexicographically before verdict hash.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel checks allowed; final verdict is deterministic.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE`.
### 0.G Operator Manifest
- `UML_OS.Security.ResolveRequiredCapabilities_v1`
- `UML_OS.Security.EvaluateAuthorization_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Canonical matrix source: `contracts/operator_registry.cbor`.
### 0.I Outputs and Metric Schema
- Outputs: `(authz_verdict, authz_query_hash, authz_decision_hash, authz_report)`.
### 0.J Spec Lifecycle Governance
- Capability changes for existing operator versions are MAJOR.
### 0.K Failure and Error Semantics
- Denied authorization emits deterministic failure with `authz_decision_hash`.
### 0.L Input/Data Provenance
- Operator capability mapping must be hash-bound to registry hash.

---
## 2) System Model
### I.A Persistent State
- capability matrix and role-policy bindings.
### I.B Inputs and Hyperparameters
- `tenant_id`, `principal_id`, `operator_id`, `authz_policy_hash`, `capability_matrix_hash`.
### I.C Constraints and Feasible Set
- valid iff operator is mapped and policy binding exists.
### I.D Transient Variables
- resolved capability set and diagnostics.
### I.E Invariants and Assertions
- one deterministic verdict per authorization query.

### II.F Capability Resolution Rule (Normative)
- `principal_id` format is canonical tenant-scoped UTF-8 text: `tenant_id "/" principal_local_id`.
- Delimiter constraint: `tenant_id` MUST NOT contain `"/"`; parsing is a single split on the first slash.
- Component constraints (normative):
  - `tenant_id` and `principal_local_id` MUST each be valid UTF-8 strings,
  - total encoded byte length of `tenant_id + "/" + principal_local_id` MUST be `<= 1024`.
- `principal_id` comparisons are bytewise and case-sensitive.
- `capability_matrix` MUST include immutable `matrix_version:string`; updates publish a new matrix object and `capability_matrix_hash`.
- Capability matrix canonical structure (normative):
  - canonical CBOR map: `operator_id:string -> required_capabilities:array<string>`,
  - each `required_capabilities` array is lexicographically sorted and duplicate-free.
  - `capability_matrix_hash = SHA-256(CBOR_CANONICAL(capability_matrix_map))`.
- Capability names MUST be fully-qualified and versioned (example: `storage.write.v1`).
- `required_capabilities` is read from canonical operator registry for `operator_id`.
- Missing `operator_id` mapping is deterministic failure.
- Authorization model is default-deny: any missing principal binding or missing required capability yields `DENY`.
- `authz_policy_hash` definition (normative): `SHA-256(CBOR_CANONICAL(authz_policy_document))`, where `authz_policy_document` is the canonical authorization policy mapping used for capability grants/denials.
  - `authz_policy_document` canonical schema (normative):
    - CBOR map: `principal_id:string -> granted_capabilities:array<string>`,
    - map keys (`principal_id`) sorted lexicographically,
    - each `granted_capabilities` array sorted lexicographically and duplicate-free.

### II.G Deterministic Verdict Hash (Normative)
- `authz_query_hash = SHA-256(CBOR_CANONICAL([tenant_id, principal_id, operator_id, sorted(required_capabilities), authz_policy_hash, capability_matrix_hash]))`.
- `granted_capabilities_hash = SHA-256(CBOR_CANONICAL(sorted(granted_capabilities)))`.
- `granted_capabilities` is the deterministic policy-evaluation output set for `(tenant_id, principal_id)` under `authz_policy_hash`, sorted lexicographically before hashing.
- `granted_capabilities` MUST NOT contain duplicate capability names (duplicate presence is deterministic failure).
- `verdict_enum` is a required enum from:
  - `ALLOW`
  - `DENY`
- `decision_reason_code` is a required enum from:
  - `ALLOW`
  - `DENY_MISSING_CAPABILITY`
  - `DENY_POLICY`
  - `DENY_PRINCIPAL_NOT_BOUND`
  - `DENY_OPERATOR_UNREGISTERED`
  - `DENY_TENANT_SCOPE`
  - `DENY_TENANT_SCOPE` semantics: authorization subject is outside allowed tenant namespace/scope for the requested operation.
- `authz_decision_hash = SHA-256(CBOR_CANONICAL([authz_query_hash, verdict_enum, granted_capabilities_hash, decision_reason_code]))`.
- Execution certificates MUST bind `authz_decision_hash` (not only query hash).

---
## 3) Initialization
1. Load capability matrix from registry.
2. Load tenant/principal policy bindings.
3. Validate matrix hash consistency.

---
## 4) Operator Manifest
- `UML_OS.Security.ResolveRequiredCapabilities_v1`
- `UML_OS.Security.EvaluateAuthorization_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Security.ResolveRequiredCapabilities_v1`  
**Category:** Security  
**Signature:** `(operator_id, registry -> required_capabilities)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** resolves sorted unique required capabilities for operator.

**Operator:** `UML_OS.Security.EvaluateAuthorization_v1`  
**Category:** Security  
**Signature:** `(tenant_id, principal_id, operator_id, policy -> authz_verdict, authz_query_hash, authz_decision_hash, report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** evaluates capability grants and emits deterministic query/decision hashes.

---
## 6) Procedure
```text
1. ResolveRequiredCapabilities_v1(operator_id, operator_registry)
2. EvaluateAuthorization_v1(tenant_id, principal_id, operator_id, authz_policy)
3. Return verdict + authz_query_hash + authz_decision_hash + report
```

---
## 7) Trace & Metrics
### Logging rule
- every authorization decision emits deterministic trace event.
### Trace schema
- `run_header`: tenant_id, authz_policy_hash, capability_matrix_hash
- `iter`: principal_id, operator_id, verdict, authz_query_hash, authz_decision_hash
- `run_end`: denied_count
### Metric schema
- `allowed_count`, `denied_count`
### Comparability guarantee
- Comparable iff policy hash and capability matrix hash match.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- all callable operators have required_capabilities.
#### VII.B Operator test vectors (mandatory)
- allowed/denied capability fixtures per tenant.
#### VII.C Golden traces (mandatory)
- golden authorization decision traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for verdict, query hash, decision hash, and report.
#### VIII.B Allowed refactor categories
- policy engine refactors preserving outputs.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare of verdict/authz hash.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- policy snapshot hash and decision cursor.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- resumed authorization yields identical outcomes.

FILE: layer2-specs/Checkpoint-Schema.md
=======================================
# UML_OS Checkpoint Schema Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Checkpoint.SchemaContract_v1`  
**Purpose (1 sentence):** Define deterministic checkpoint structure, compatibility rules, and restore guarantees across UML_OS subsystems.  
**Spec Version:** `UML_OS.Checkpoint.SchemaContract_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** State persistence and restore compatibility.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Checkpoint.SchemaContract_v1`
- **Purpose (1 sentence):** Canonical checkpoint contract.
- **Spec Version:** `UML_OS.Checkpoint.SchemaContract_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Deterministic persistence.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize restore divergence and compatibility errors.
### 0.B Reproducibility Contract
- Replayable given `(checkpoint_hash, checkpoint_header_hash, schema_version, replay_token)`.
### 0.C Numeric Policy
- Binary blobs and scalar metadata are typed and deterministic.
### 0.D Ordering and Tie-Break Policy
- Canonical field order for serialization.
### 0.E Parallel, Concurrency, and Reduction Policy
- Checkpoint writes are atomic and serialized deterministically.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for checkpoint metadata and hashes.
### 0.G Operator Manifest
- `UML_OS.Checkpoint.ValidateSchema_v1`
- `UML_OS.Checkpoint.Serialize_v1`
- `UML_OS.Checkpoint.Restore_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Fully-qualified checkpoint fields by subsystem.
### 0.I Outputs and Metric Schema
- Outputs: `(checkpoint_blob, restore_report)`.
- Metrics: `checkpoint_size_bytes`, `restore_time_ms`, `compatibility_level`.
- Completion status: `success | failed`.
### 0.J Spec Lifecycle Governance
- Breaking field changes require MAJOR bump.
### 0.K Failure and Error Semantics
- Abort on incompatible schema or hash mismatch.
### 0.L Input/Data Provenance
- Checkpoint records source run hash and manifest hash.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.


## 2) System Model
### I.A Persistent State
- checkpoint schema registry.
### I.B Inputs and Hyperparameters
- subsystem states and schema version.
### I.C Constraints and Feasible Set
- Valid if required fields and hashes match.
### I.D Transient Variables
- serialization buffers and restore diagnostics.
### I.E Invariants and Assertions
- round-trip serialize/restore invariance.

### II.F Checkpoint Record Layout (Concrete)
- Required fields:
  - `tenant_id:string`
  - `run_id:string`
  - `spec_version:string`
  - `checkpoint_schema_version:string`
  - `replay_token:bytes32`
  - `t:uint64`
  - `manifest_hash:bytes32`
  - `ir_hash:bytes32`
  - `trace_snapshot_hash:bytes32`
  - `sampler_config_hash:bytes32`
  - `tmmu_plan_hash:bytes32`
  - `backend_binary_hash:bytes32`
  - `checkpoint_merkle_root:bytes32`
  - `policy_bundle_hash:bytes32`
  - `determinism_profile_hash:bytes32`
  - `lockfile_hash:bytes32`
  - `toolchain_hash:bytes32`
  - `dependencies_lock_hash:bytes32`
  - `operator_contracts_root_hash:bytes32`
  - `runtime_env_hash:bytes32`
  - `code_commit_hash:bytes32`
- `lineage_root_hash:bytes32` (snapshot-at-checkpoint value; MUST match certificate lineage commitment for the finalized run branch that includes this checkpoint)
  - lineage consistency rule: `lineage_root_hash` MUST equal the deterministic lineage root recomputed from checkpoint-scoped lineage objects/artifacts referenced by this checkpoint snapshot.
  - `dp_enabled:bool`
  - `tensors_root_hash:bytes32` (empty-set rule: if no tensor shards, root is `SHA-256(CBOR_CANONICAL([]))` per hash identities below)
  - `optimizer_state_root_hash:bytes32` (empty-set rule: if no optimizer shards, root is `SHA-256(CBOR_CANONICAL([]))` per hash identities below)
  - `rng_state_hash:bytes32`
  - `data_cursors_hash:bytes32`
  - `dp_accountant_state_hash?:bytes32`
  - `weights_manifest_hash?:bytes32`
  - `optimizer_manifest_hash?:bytes32`
  - `dp_accountant_manifest_hash?:bytes32`
  - `checkpoint_header_hash:bytes32`
  - `checkpoint_manifest_hash:bytes32`
  - `checkpoint_hash:bytes32`
  - `checkpoint_hash_prev?:bytes32`
- Hash identities (normative):
  - `checkpoint_header_cbor` is the canonical CBOR map of checkpoint header fields excluding `checkpoint_header_hash` itself.
  - `checkpoint_header_hash = SHA-256(checkpoint_header_cbor)`
  - `checkpoint_manifest_cbor` is a canonical CBOR map with keys:
    - `manifest_version:string`
    - `checkpoint_merkle_root:bytes32`
    - `shards:array<{path:string, sha256:bytes32, size_bytes:uint64}>` sorted by `path`
      - `path` normalization rule (normative): POSIX-style relative path only, forward slashes (`/`), no `.` or `..` segments, no repeated separators, and no leading slash.
    - `weights_manifest_hash?:bytes32`
    - `optimizer_manifest_hash?:bytes32`
    - `dp_accountant_manifest_hash?:bytes32`
    - `dataset_snapshot_id?:string`
    - `artifact_index_hash?:bytes32`
  - `checkpoint_manifest_hash = SHA-256(checkpoint_manifest_cbor)` where manifest commits all shard digests and `checkpoint_merkle_root`
  - `weights_manifest_hash = SHA-256(CBOR_CANONICAL(weights_manifest_cbor))`
  - `optimizer_manifest_hash = SHA-256(CBOR_CANONICAL(optimizer_manifest_cbor))`
  - `dp_accountant_manifest_hash = SHA-256(CBOR_CANONICAL(dp_accountant_manifest_cbor))`
  - `rng_state_hash = SHA-256(CBOR_CANONICAL(rng_state_cbor))`
  - `rng_state_cbor` canonical schema (normative):
    - `["rng_state_v1", key_u32_0, key_u32_1, ctr_u32_0, ctr_u32_1, ctr_u32_2, ctr_u32_3]`
    - where key is Philox key `[u32;2]` and counter is `[u32;4]` in little-endian logical word order.
  - `data_cursors_hash = SHA-256(CBOR_CANONICAL(data_cursors_cbor))`
  - `tensors_root_hash` and `optimizer_state_root_hash` derivation (normative):
    - shard-leaf encoding shared with checkpoint Merkle leaves:
      - `leaf_i = SHA-256(CBOR_CANONICAL(["ckpt_shard_v1", shard_path_i, shard_sha256_i, shard_size_i]))`,
    - `tensors_root_hash = SHA-256(CBOR_CANONICAL(["tensors_root_v1", tensor_leaves_sorted]))` where `tensor_leaves_sorted` contains leaves for shards with normalized path prefix `tensors/`, sorted by `shard_path`,
    - `optimizer_state_root_hash = SHA-256(CBOR_CANONICAL(["optimizer_root_v1", optimizer_leaves_sorted]))` where `optimizer_leaves_sorted` contains leaves for shards with normalized path prefix `optimizer/`, sorted by `shard_path`,
    - empty-set rule: if the filtered shard set is empty, root is `SHA-256(CBOR_CANONICAL([]))`.
  - `checkpoint_hash = checkpoint_manifest_hash`
  - `dependencies_lock_hash = SHA-256(CBOR_CANONICAL(["deps_lock_v1", lockfile_hash, toolchain_hash, runtime_env_hash]))`
  - `operator_contracts_root_hash = operator_registry_root_hash` from `docs/layer1-foundation/Operator-Registry-Schema.md`.
- `checkpoint_merkle_root` construction over shard payloads:
    - `leaf_i = SHA-256(CBOR_CANONICAL(["ckpt_shard_v1", shard_path_i, shard_sha256_i, shard_size_i]))` with shards ordered by `shard_path`,
    - `parent = SHA-256(CBOR_CANONICAL(["ckpt_merkle_node_v1", left, right]))`,
    - odd-leaf rule duplicates the last leaf.
    - empty-shard rule: if there are zero shards, `checkpoint_merkle_root = SHA-256(CBOR_CANONICAL([]))`.
    - for streaming writes, root is computed only after all shard hashes are finalized; placeholder roots are invalid.
- Canonical absence encoding: optional fields are omitted (key absent), never encoded as `null`.
- Evolution rule: additive optional fields allowed in MINOR; required-field changes require MAJOR.
- Migration controls:
  - `migration_supported_from: array<string>`
  - `migration_operator: string`
  - `migration_invariants: array<string>`

### II.G Sharded/Streaming Container Format
- Container layout:
  - `checkpoint_manifest.cbor` (authoritative metadata + shard index)
  - `tensors/rank=<r>/shard=<k>.bin`
  - `optimizer/rank=<r>/state.bin` (optional)
  - `dp/accountant_state.cbor`
  - `rng/state.cbor`
  - `data/cursors.cbor`
  - `tmmu/plan.cbor`
  - `trace/link.cbor`
  - `artifacts/artifact_index.cbor`
- Integrity:
  - `checkpoint_manifest.cbor` includes per-shard hash list and Merkle root.
  - Full checkpoint hash is `checkpoint_manifest_hash`.
  - Binding rule:
    - `weights_manifest_hash` must hash to a manifest whose content-addressed entries jointly hash to `tensors_root_hash`.
    - `optimizer_manifest_hash` must hash to a manifest whose entries jointly hash to `optimizer_state_root_hash`.
    - `dp_accountant_manifest_hash` must hash to canonical accountant blobs that hash to `dp_accountant_state_hash` (when DP enabled).
- Atomicity protocol:
  - Local FS: write to temp path, `fsync(file)`, `rename(temp, final)`, `fsync(directory)`.
  - Object stores: write immutable checkpoint objects by content hash; finalize via conditional pointer publish (create-if-absent generation precondition).
  - crash-consistency guarantee: either previous checkpoint remains valid or new checkpoint pointer is fully published; partial writes are invalid.
- Restore semantics:
  - supports full restore and deterministic partial restore by shard subset when declared by policy.

### II.H Partial Restore Matrix (Normative)
- Training restore requires: model params, optimizer state, RNG states, data cursors, TMMU plan.
- If `dp_enabled=true` in checkpoint header and committed manifest/config, DP accountant state is additionally required; if `dp_enabled=false`, DP accountant fields must be absent (not null).
- Eval/infer partial restore may use: model params + minimal runtime config.
- Any partial restore must emit `restore_profile_id` and trace record.
- Restore precondition: manifest DP enablement MUST match checkpoint `dp_enabled`; mismatch is deterministic failure.
- Restore precondition: checkpoint `operator_contracts_root_hash` MUST match current runtime `operator_contracts_root_hash`; otherwise abort or execute declared deterministic registry migration path before restore.
- Restore precondition: recomputed `tmmu_plan_hash` from current IR/execution order MUST equal checkpoint `tmmu_plan_hash`; mismatch is deterministic failure (no implicit memory-plan adaptation).

### II.I Trace-Link Integrity (Normative)
- Checkpoint header must store:
  - `trace_snapshot_hash`
  - `checkpoint_hash_prev` (if checkpoint chaining enabled)
- In linear hash-chain mode, `trace_final_hash == trace_snapshot_hash` at checkpoint boundary.
- `trace/link.cbor` binds checkpoint to trace hash chain for tamper-evident replay.
- checkpoint manifest must include `dataset_snapshot_id` and `artifact_index_hash`.
- Canonical contract rule: the checkpoint header in this file is the authoritative shape and must match `docs/layer1-foundation/Data-Structures.md` `CheckpointHeader`.
- Restore identity rule: restore must abort deterministically on any mismatch in `{tenant_id, run_id, replay_token, trace_snapshot_hash, checkpoint_hash, manifest_hash, ir_hash, sampler_config_hash, tmmu_plan_hash, backend_binary_hash, determinism_profile_hash, policy_bundle_hash}`.

### II.J Run Commit Protocol (Normative)
- Commit is atomic via immutable-object writes plus a single commit-pointer object:
  1. write immutable content-addressed trace/checkpoint/lineage/certificate objects,
  2. compute and validate `trace_final_hash`, `checkpoint_hash`, `lineage_root_hash`, `certificate_hash`,
  3. publish `runs/<tenant_id>/<run_id>/COMMITTED` via conditional create-if-absent,
  4. pointer payload binds `{trace_final_hash, checkpoint_hash, lineage_root_hash, certificate_hash, wal_terminal_hash}`.
- Recovery rule after crash:
  - if COMMITTED pointer exists, validate referenced objects and finalize,
  - if pointer missing, treat run as uncommitted and recover deterministically from WAL.

### II.K Migration Certificate (Normative)
- Every schema migration must emit a signed migration certificate:
  - `from_schema_version`, `to_schema_version`,
  - `source_hash`, `target_hash`,
  - `migration_operator`, `migration_policy_hash`.
- Hash semantics:
  - `source_hash` = content hash of source object before migration,
  - `target_hash` = content hash of migrated output object after migration.
- Migration output must hash identically across conforming implementations.

---
## 3) Initialization
1. Load checkpoint schema.
2. Validate subsystem state snapshots.
3. Initialize canonical serializer.

---
## 4) Operator Manifest
- `UML_OS.Checkpoint.ValidateSchema_v1`
- `UML_OS.Checkpoint.Serialize_v1`
- `UML_OS.Checkpoint.Restore_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

Template conformance note (III.A): each operator definition in this section is interpreted with the full EQC operator template fields. When a field is not repeated inline, the section-level defaults are: explicit typed signatures, deterministic ordering/tie handling, declared numerical policy inheritance, deterministic failure semantics (0.K), explicit dependencies, and VII.B test-vector coverage.

**Operator:** `UML_OS.Checkpoint.ValidateSchema_v1`  
**Category:** IO  
**Signature:** `(state, schema -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates checkpoint field presence/types.

**Operator:** `UML_OS.Checkpoint.Serialize_v1`  
**Category:** IO  
**Signature:** `(validated_state -> checkpoint_blob)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** canonical deterministic serialization with hash attachment.

**Operator:** `UML_OS.Checkpoint.Restore_v1`  
**Category:** IO  
**Signature:** `(checkpoint_blob -> restored_state, report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** validates hash/schema and reconstructs subsystem state.
If `checkpoint_schema_version` is older and listed in `migration_supported_from`, restore MUST apply deterministic `migration_operator` before state reconstruction.

**Operator:** `UML_OS.Checkpoint.Migrate_v1`
**Category:** IO
**Signature:** `(old_checkpoint, from_version, to_version -> new_checkpoint)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** performs deterministic format migration while preserving logical checkpoint semantics and emitting migration certificate inputs.

---
## 6) Procedure
```text
1. ValidateSchema_v1
2. Serialize_v1
3. Restore_v1 (verification mode)
4. Return checkpoint_blob + restore_report
```

---
## 7) Trace & Metrics
### Logging rule
Checkpoint writes/restores emit deterministic records.
### Trace schema
- `run_header`: schema_version, source_hash
- `iter`: step, status
- `run_end`: checkpoint_hash, restore_status
### Metric schema
- `checkpoint_size_bytes`, `restore_time_ms`, `compatibility_level`
### Comparability guarantee
Comparable iff schema version and hash rules are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
Passes deterministic ordering, schema completeness, round-trip invariance.
#### VII.B Operator test vectors (mandatory)
Checkpoint fixtures for valid/incompatible/corrupt cases.
#### VII.C Golden traces (mandatory)
Golden checkpoint hashes for baseline states.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for blob/hash and restored state.
#### VIII.B Allowed refactor categories
- serializer optimization preserving canonical bytes.
#### VIII.C Equivalence test procedure (mandatory)
Exact blob/hash compare + state equivalence.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- kernel, data, model, tmmu, dp states + metadata hashes.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- restored run must produce identical subsequent deterministic traces.

FILE: layer2-specs/Config-Schema.md
===================================
# UML_OS Config Schema Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Config.SchemaValidator_v1`  
**Purpose (1 sentence):** Define and validate the canonical manifest/config schema used by all UML_OS components.  
**Spec Version:** `UML_OS.Config.SchemaValidator_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Deterministic configuration validation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Config.SchemaValidator_v1`
- **Purpose (1 sentence):** Canonical manifest schema enforcement.
- **Spec Version:** `UML_OS.Config.SchemaValidator_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Config schema validation.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize schema violations.
### 0.B Reproducibility Contract
- Replayable given `(schema_version, manifest_hash)`.
### 0.C Numeric Policy
- Type/constraint checks deterministic; float constraints in binary64.
### 0.D Ordering and Tie-Break Policy
- Field validation order is canonical by schema key path.
### 0.E Parallel, Concurrency, and Reduction Policy
- Validation is deterministic single-pass.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for validation output.
### 0.G Operator Manifest
- `UML_OS.Config.ValidateRequiredFields_v1`
- `UML_OS.Config.ValidateTypes_v1`
- `UML_OS.Config.ValidateRanges_v1`
- `UML_OS.Config.NormalizeDefaults_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Fully-qualified config operators required.
### 0.I Outputs and Metric Schema
- Outputs: `(normalized_manifest, validation_report)`.
- Metrics: `missing_fields`, `type_errors`, `range_errors`.
- Completion status: `success | failed`.
### 0.J Spec Lifecycle Governance
- Breaking schema changes require MAJOR bump.
### 0.K Failure and Error Semantics
- Abort-only on invalid manifest.
### 0.L Input/Data Provenance
- Input manifest hash and source path recorded.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.


## 2) System Model
### I.A Persistent State
- schema registry.
### I.B Inputs and Hyperparameters
- raw manifest and schema version.
### I.C Constraints and Feasible Set
- Valid if all required/type/range checks pass.
### I.D Transient Variables
- validation diagnostics.
### I.E Invariants and Assertions
- normalized manifest is canonical and deterministic.

### II.F Authoritative Manifest Schema (Concrete)
- Canonical serialization: `CBOR_CANONICAL` as defined in `docs/layer1-foundation/Canonical-CBOR-Profile.md`.
- `manifest_hash = SHA-256(canonical_manifest_cbor)`.
- `schema_mode: enum("AUTHORITATIVE","MODULAR")` (default `AUTHORITATIVE`).
- Required top-level fields:
  - `spec_version:string`
  - `tenant_id:string`
  - `seed:uint64`
  - `global_batch_size:uint64 (>=1)`
  - `datasets:object`
  - `environment:object`
  - `pipeline_stages:array<object>`
  - `model:object`
  - `security:object`
  - `optimizer:object`
  - `policy_bundle:object`
  - policy note: `policy.rules` (runtime stage/action control) is distinct from `policy_bundle` (security/authz/monitor commitment hashes); both may coexist.
- Optional top-level fields:
  - `task_type:enum(multiclass|binary|regression)`
  - `alpha:float64` (default `1.0`)
  - `execution_mode:enum(local|managed|confidential|regulated)` (default `managed`)
  - `fingerprint_frequency:uint64` (default `0`)
  - `grad_clip_norm:float64`
  - `checkpoint_frequency:uint64` (default `0`)
  - `job_priority:uint64` (recommended range `1..10`)
  - `policy:object` with optional `rules:array<object>` for runtime stage decisions
  - `data:object` with optional:
    - `sampler_block_size:uint64` (default `1048576`)
    - `drop_last:bool` (default `false`)
  - `custom_operators:array<object>`
  - `parallelism:object` with optional:
    - `strategy:string`
    - `world_size_override:uint64`
    - `sharding_config:object`
  - `manifest_inheritance:object` with optional:
    - `parent_manifest_path:string`
  - `hardware_affinity:object` with optional:
    - `gpu_ids:array<uint64>`
    - `cpu_cores:array<uint64>`
  - `profile:enum(research|enterprise|regulated)`
  - `backend:object` with optional/required subfields:
    - `name:string`
  - `resource_requests:object` with optional:
    - `cpus:uint64`
    - `gpus:uint64`
    - `memory_gb:float64`
  - `memory_arena_config:object` (optional deterministic TMMU arena configuration)
  - `quota:object` with optional:
    - `memory_bytes_budget:uint64`
    - `gpu_time_ms_budget:uint64`
    - `cpu_time_ms_budget:uint64`
    - `io_bytes_budget:uint64`
  - `rbac:object` with optional:
    - `principals:array<object>`
    - `permissions:map`
  - `storage:object` with optional:
    - `backend:string`
    - `endpoint:string`
    - `bucket:string`
    - `credentials_secret:string`
  - `monitoring_export:object` with optional:
    - `prometheus_endpoint:string`
    - `log_sink:string`
  - `rbac_source:enum(local|ldap|oidc)` (default `local`)
  - `daemon_mode:enum(standalone|cluster)` (default `standalone`)
  - `distributed:object` with optional:
    - `timeout_seconds:uint64` (default `300`)
  - `fine_tune:object`
  - `evaluation:object`
  - `compute_dtype:enum(float32|float64)` (default `float32`)
  - `trace:object` with optional:
    - `schema_version:string`
    - `max_bytes_per_step:uint64`
    - `sample_policy:string`
- Required `security.differential_privacy` fields when enabled:
  - `enabled:bool`, `accountant:string`, `target_epsilon:float64`, `target_delta:float64`, `noise_multiplier:float64`.
- Required `pipeline_stages[i]` fields:
  - `step_id:string`, `type:enum(train|eval|infer|augment)`, `depends_on:array<string>`.
- Pipeline-stage validation rules (normative):
  - `step_id` values MUST be unique within the manifest.
  - every `depends_on` entry MUST reference an existing `step_id`.
  - forward-order requirement: each dependency MUST reference a stage declared earlier in the array; otherwise validation fails with deterministic `CONTRACT_VIOLATION`.
- Unknown keys policy:
  - In `AUTHORITATIVE` mode: unknown key paths are fatal (`CONTRACT_VIOLATION`).
  - In `MODULAR` mode: unknown keys allowed only under registered extension roots and only when ownership/version checks in II.G pass.
- Required cross-doc fields:
  - `data.sampler_block_size:uint64` (default `1048576`)
  - `compute_dtype:enum(float32,float64)` (default `float32`)
  - `backend.name:string`
  - `trace.schema_version:string`
  - `policy_bundle.policy_bundle_hash:bytes32`
  - `policy_bundle.security_policy_hash:bytes32`
  - `policy_bundle.authz_policy_hash:bytes32`
  - `policy_bundle.monitor_policy_hash:bytes32`
  - `policy_bundle.dp_policy_hash?:bytes32`
  - `policy_bundle.redaction_policy_hash?:bytes32`
  - `environment.env_manifest_hash:bytes32` (as defined in `docs/layer1-foundation/Environment-Manifest.md`; alias `runtime_env_hash` must resolve identically)

### II.F.2 Kernel Manifest Alignment (Normative)
- To preserve cross-file consistency with `docs/layer2-specs/UML_OS-Kernel-v3.22-OS.md` section `0.Q`, the following top-level manifest fields are recognized by this schema (required/optional as noted):
  - required: `spec_version`, `tenant_id`, `seed`, `execution_mode`, `datasets`, `pipeline_stages`, `model`, `security`, `optimizer`, `environment`, `policy_bundle`.
  - optional: `task_type`, `alpha`, `fingerprint_frequency`, `grad_clip_norm`, `checkpoint_frequency`, `job_priority`, `policy.rules`, `data`, `custom_operators`, `parallelism`, `manifest_inheritance`, `hardware_affinity`, `profile`, `backend`, `resource_requests`, `memory_arena_config`, `quota`, `rbac`, `storage`, `monitoring_export`, `rbac_source`, `daemon_mode`, `distributed`, `fine_tune`, `evaluation`, `compute_dtype`, `trace`.
  - `policy.rules` and `policy_bundle` serve different purposes and MAY coexist: policy rules drive runtime stage/action decisions; `policy_bundle` carries cryptographic policy commitments.
- `environment` object alignment:
  - required field: `env_manifest_hash:bytes32`,
  - optional fields: `requirements_hash:string`, `container_image:string`.

### II.F.1 Policy Bundle Commitment (Normative)
- `policy_bundle_hash = SHA-256(CBOR_CANONICAL(["policy_bundle_v1", security_policy_hash, authz_policy_hash, monitor_policy_hash, dp_policy_hash?, redaction_policy_hash?]))`.
- `policy_hash` references in other contracts are aliases of `policy_bundle_hash` and must resolve to the same bytes32 value.
- Presence rule:
  - if `policy_bundle_hash` is present and individual component hashes are also present, they MUST match the `policy_bundle_v1` decomposition exactly;
  - if only `policy_bundle_hash` is present, verifiers treat it as an opaque commitment identifier.

### II.G Extension Registry (Normative)
| ext_id | root_prefix | owner_org | signing_key_id | version_range | conflict_policy |
|---|---|---|---|---|---|
| `core_data` | `data.*` | `UML_OS.Core` | `core-signing-ed25519` | `>=1.0,<2.0` | `FAIL` |
| `core_backend` | `backend.*` | `UML_OS.Core` | `core-signing-ed25519` | `>=1.0,<2.0` | `FAIL` |
| `core_tmmu` | `tmmu.*` | `UML_OS.Core` | `core-signing-ed25519` | `>=1.0,<2.0` | `FAIL` |
| `core_trace` | `trace.*` | `UML_OS.Core` | `core-signing-ed25519` | `>=1.0,<2.0` | `FAIL` |
| `core_security` | `security.*` | `UML_OS.Core` | `core-signing-ed25519` | `>=1.0,<2.0` | `FAIL` |

Normative checks in `MODULAR` mode:
- `schema_extensions[ext_id].owner == manifest.extensions[ext_id].owner`
- `manifest.extensions[ext_id].version` must satisfy `version_range`
- two extensions cannot claim overlapping `root_prefix` (`FAIL`)
- overlap refinement rule:
  - nested prefixes are allowed only when owners are identical; longer (more specific) prefix takes precedence.
  - equal-length overlaps with different owners are fatal (`FAIL`).
- `version_range` is interpreted using SemVer 2.0.0 comparison rules (deterministic parser; prerelease ordering per SemVer spec).
- extension signature validation must use `signing_key_id` resolved from trust-store metadata with validity-window and revocation checks at manifest creation time.

### II.G.1 Extension Registration (Normative)
- Extensions are loaded from a deterministic extension registry snapshot and validated at manifest-check time.
- Runtime mutation of extension registry is out-of-scope for this contract version; registry updates must publish a new signed snapshot hash.

### II.H Field Access Rule (Normative)
- Define `MANIFEST_FIELD_ACCESS_SET`: exact set of manifest key paths referenced by kernel, executor, sampler, DP, checkpoint, trace, backend adapter, and deployment operators.
- CI must compute `MANIFEST_FIELD_ACCESS_SET` from static extraction and compare against schema-declared paths.
- Build fails with `CONTRACT_VIOLATION` if any referenced path is undeclared.
- To support dynamic access paths, each operator contract MUST declare manifest field inputs explicitly in its operator signature/contract metadata; runtime validation enforces declared-access subset relation.

### II.I Canonical Defaults Table (Normative)
| field_path | default |
|---|---|
| `data.sampler_block_size` | `1048576` |
| `data.drop_last` | `false` |
| `trace.schema_version` | `UML_OS.Trace.SidecarSchema_v1` |
| `trace.max_bytes_per_step` | `1048576` |
| `trace.sample_policy` | `HASH_GATED` |
| `security.differential_privacy.accountant_granularity` | `PER_STEP` |
| `backend.determinism_profile_id` | `gpu_determinism_v1` |
| `tracking.store_uri` | `cas://tracking/default` |
| `tracking.retention_days` | `90` |
| `security.trust_mode` | `SOFTWARE_ONLY` |

### II.J Deterministic Migration Framework (Normative)
- Manifest schema versions must declare:
  - `schema_version`,
  - `migration_supported_from`,
  - `migration_operator` (for manifests: `UML_OS.Config.ManifestMigrate_v1`).
- Migration output must be deterministic and hash-identical across conforming implementations.
- Each migration run must emit a migration certificate binding:
  - `source_manifest_hash -> target_manifest_hash`,
  - `from_version`, `to_version`, and `migration_policy_hash`.

---
## 3) Initialization
1. Load schema.
2. Parse raw manifest.
3. Initialize diagnostics.

---
## 4) Operator Manifest
- `UML_OS.Config.ValidateRequiredFields_v1`
- `UML_OS.Config.ValidateTypes_v1`
- `UML_OS.Config.ValidateRanges_v1`
- `UML_OS.Config.NormalizeDefaults_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

Template conformance note (III.A): each operator definition in this section is interpreted with the full EQC operator template fields. When a field is not repeated inline, the section-level defaults are: explicit typed signatures, deterministic ordering/tie handling, declared numerical policy inheritance, deterministic failure semantics (0.K), explicit dependencies, and VII.B test-vector coverage.

**Operator:** `UML_OS.Config.ValidateRequiredFields_v1`  
**Category:** IO  
**Signature:** `(manifest, schema -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** checks required keys and nested objects, including pipeline structural constraints:
  - unique `pipeline_stages[].step_id`,
  - every `depends_on` reference exists,
  - each dependency references an earlier stage index.

**Operator:** `UML_OS.Config.ValidateTypes_v1`  
**Category:** IO  
**Signature:** `(manifest, schema -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** checks scalar/object/list types.

**Operator:** `UML_OS.Config.ValidateRanges_v1`  
**Category:** IO  
**Signature:** `(manifest, schema -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** checks numeric ranges/enums.

**Operator:** `UML_OS.Config.NormalizeDefaults_v1`  
**Category:** IO  
**Signature:** `(manifest, schema -> normalized_manifest)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** fills defaults and produces canonical ordering.

**Operator:** `UML_OS.Config.ManifestMigrate_v1`
**Category:** IO
**Signature:** `(manifest, from_version, to_version -> migrated_manifest)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** migrates manifest schema deterministically between declared compatible versions while preserving logical semantics.

---
## 6) Procedure
```text
1. ValidateRequiredFields_v1
2. ValidateTypes_v1
3. ValidateRanges_v1
4. NormalizeDefaults_v1
5. Return normalized manifest + report
```

---
## 7) Trace & Metrics
### Logging rule
Validation emits deterministic field-level diagnostics.
### Trace schema
- `run_header`: schema_version, manifest_hash
- `iter`: field_path, check, result
- `run_end`: status
### Metric schema
- `missing_fields`, `type_errors`, `range_errors`
### Comparability guarantee
Comparable iff schema version and canonicalization rules are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
Passes deterministic field ordering and completeness checks.
#### VII.B Operator test vectors (mandatory)
Includes valid/invalid manifest fixtures.
#### VII.C Golden traces (mandatory)
Golden normalized-manifest hashes and diagnostics.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for normalized manifest and report.
#### VIII.B Allowed refactor categories
- parser/validator optimization preserving outputs.
#### VIII.C Equivalence test procedure (mandatory)
Exact diff on normalized manifest/report.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- schema and partial diagnostics.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- resume yields identical validation output.

---
## 11) Product Profile Packaging Addendum (Normative)
- In addition to `execution_mode`, deployments MUST support profile packaging IDs:
  - `core`, `enterprise`, `regulated`.
- Profile packaging intent:
  - `core`: minimal, week-one adoption path (single-node default, one backend adapter, one artifact-store adapter, default trace policy).
  - `enterprise`: production operations profile with deployment/runbook and full gate policy.
  - `regulated`: enterprise profile + security/compliance and audit-proof requirements.
- Runtime-mode mapping note:
  - `enterprise` packaging commonly targets `execution_mode=managed`.
- Profile bundle identity:
  - `profile_bundle_hash = SHA-256(CBOR_CANONICAL(profile_bundle))`.
- Promotion requirement:
  - profile transitions (`core -> enterprise -> regulated`) require successful conformance and evidence gates defined in layer3/layer4 contracts.

FILE: layer2-specs/Data-Lineage.md
==================================
# UML_OS Data Lineage Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Data.Lineage_v1`  
**Purpose (1 sentence):** Define deterministic dataset snapshot lineage and transform-chain provenance for replayable training/evaluation runs.  
**Spec Version:** `UML_OS.Data.Lineage_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Data provenance and versioning.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Data.Lineage_v1`
- **Purpose (1 sentence):** Deterministic dataset snapshot provenance.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize unverifiable data lineage.
### 0.B Reproducibility Contract
- Replayable given `(dataset_snapshot_id, data_access_plan_hash, transform_chain_hash)`.
### 0.C Numeric Policy
- Hashes/IDs exact.
### 0.D Ordering and Tie-Break Policy
- Transform chain ordering fixed by declared transform_seq.
### 0.E Parallel, Concurrency, and Reduction Policy
- Multi-source merges resolved deterministically by sorted source ID.
### 0.F Environment and Dependency Policy
- Data import and transforms must be content-addressed and immutable.
### 0.G Operator Manifest
- `UML_OS.Data.BuildSnapshot_v1`
- `UML_OS.Data.ComputeLineageHash_v1`
- `UML_OS.Data.ValidateSnapshot_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Data.*` namespace.
### 0.I Outputs and Metric Schema
- Outputs: `(dataset_snapshot_id, data_access_plan_hash, lineage_report)`
- Metrics: `source_count`, `transform_count`, `snapshot_size_bytes`
### 0.J Spec Lifecycle Governance
- snapshot ID and lineage hash semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- abort on snapshot hash mismatch or missing lineage refs.
### 0.L Input/Data Provenance
- lineage includes source hashes and transform chain hash.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- snapshot catalog and lineage graph.
### I.B Inputs and Hyperparameters
- `tenant_id`, `run_id`, source refs, split configs, transform specs, `sampler_config_hash`.
### I.C Constraints and Feasible Set
- snapshot immutable after publish.
### I.D Transient Variables
- hashing buffers and lineage diagnostics.
### I.E Invariants and Assertions
- every snapshot ID is content-addressed and deterministic.

### II.F Snapshot Identifier (Normative)
- Stable content identity:
  - `dataset_root_hash` is computed over dataset files as:
    - enumerate files under dataset root with normalized POSIX-style relative paths (forward slashes, no `.`/`..`, no repeated separators, no leading slash) sorted lexicographically,
    - `file_hash_i = SHA-256(file_bytes_i)`,
    - `leaf_i = SHA-256(CBOR_CANONICAL(["dataset_leaf_v1", relative_path_i, file_hash_i]))`,
    - Merkle parent `node = SHA-256(CBOR_CANONICAL(["dataset_node_v1", left, right]))` with odd-leaf duplication,
    - root is `dataset_root_hash`.
  - `split_hashes = SHA-256(CBOR_CANONICAL(["split_defs_v1", split_defs_sorted]))` where `split_defs_sorted` is split config sorted by split name.
  - split-name uniqueness rule: `split_name` values MUST be unique within `split_defs`; duplicates are deterministic validation failure.
  - split derivation algorithm (normative):
    - start from dataset canonical deterministic order:
      - for multi-file datasets, file order is normalized POSIX relative path order (lexicographic ascending),
      - within each file, record order is the physical storage order of that file format (for example line order for text files, native record order for binary containers),
    - if `split_seed` is present, apply deterministic seeded permutation before assignment:
      - for each sample at canonical position `sample_index`, compute
        `shuffle_key = SHA-256(CBOR_CANONICAL([split_seed, sample_index]))`,
      - sort samples lexicographically by `shuffle_key` (tie-break by `sample_index`),
      - use that sorted order as the shuffled dataset order,
    - assign sequential ranges by split fractions in split order:
      - for each split except the last, `split_count_i = floor(split_fraction_i * total_samples)`,
      - any remaining samples after these assignments are assigned to the final split.
    - after computing split counts, validation rule: split fractions must satisfy `abs(sum(split_fraction_i) - 1.0) <= EPS_EQ`; otherwise deterministic validation failure.
  - canonical split entry encoding: `{"split_name":string,"split_fraction":float64,"split_seed?:uint64}` encoded as canonical CBOR map.
  - `dataset_snapshot_id = SHA-256(CBOR_CANONICAL([tenant_id, dataset_root_hash, split_hashes, transform_chain_hash, dataset_version_or_tag]))`
- Run/access-plan identity:
  - `world_size_policy = "rank_contiguous_shard_v1"` (must match `docs/layer2-specs/Data-NextBatch.md`).
  - `epoch_seed_rule = "epoch_seed_rule_v2"` (must match `docs/layer2-specs/Data-NextBatch.md`).
  - `data_access_plan_hash = SHA-256(CBOR_CANONICAL([kernel_replay_token, manifest_hash, dataset_key, sampler_config_hash, world_size_policy, epoch_seed_rule]))`
- `dataset_snapshot_id` and `data_access_plan_hash` are distinct and MUST NOT be conflated.
- Both `dataset_snapshot_id` and `data_access_plan_hash` MUST be emitted in trace and bound in execution certificate payload.
- Cross-tenant rule: all lineage objects are namespaced by `(tenant_id, object_id)`; cross-tenant references must hard-fail deterministically.
- CAS retention metadata is mandatory:
  - `retention_class âˆˆ {golden, certified_release, experimental, ephemeral}`,
  - `pin_root_refs` (certificate/model-release roots),
  - `gc_eligible_after_utc`.
- GC invariant: lineage objects reachable from active certificate/release roots are not collectible.
- default retention rule: if unspecified, `retention_class = experimental`.
- Commit binding: finalized lineage objects must participate in the atomic run commit protocol and be referenced by `lineage_root_hash` in the execution certificate.

### II.G Lineage Commitments (Normative)
- `transform_chain_hash = SHA-256(CBOR_CANONICAL(["transform_chain_v1", transforms_sorted_by_seq]))`.
- Transform ordering rule: each transform entry MUST include `seq:uint64`; `transforms_sorted_by_seq` sorts ascending by `seq` (ties are deterministic failure).
- `object_type` domain (normative): one of `{ "dataset", "transform", "split", "artifact", "policy", "checkpoint" }`.
- `object_id` domain (normative): content-addressed identifier of the lineage object payload in its namespace.
- `lineage_object_hash = SHA-256(CBOR_CANONICAL(["lineage_object_v1", object_type, object_id, payload]))`.
  - `payload` is the canonical CBOR serialization of the lineage object's committed content.
- `lineage_root_hash` uses deterministic Merkle construction:
  - leaf list: sorted by `(object_type, object_id)` ascending,
  - leaf hash: `leaf_i = SHA-256(CBOR_CANONICAL(["lineage_leaf_v1", object_type_i, object_id_i, lineage_object_hash_i]))`,
  - parent hash: `node = SHA-256(CBOR_CANONICAL(["lineage_node_v1", left, right]))`,
  - odd-leaf rule: duplicate last leaf.

---
## 3) Initialization
1. Load source references.
2. Validate transform chain.
3. Initialize snapshot build context.

---
## 4) Operator Manifest
- `UML_OS.Data.BuildSnapshot_v1`
- `UML_OS.Data.ComputeLineageHash_v1`
- `UML_OS.Data.ValidateSnapshot_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Data.ValidateSnapshot_v1`  
**Category:** Data  
**Signature:** `(source_refs, transform_chain, split_defs, access_plan_inputs -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates source immutability, split-def consistency, transform-chain integrity, and namespace constraints before snapshot build.

**Operator:** `UML_OS.Data.ComputeLineageHash_v1`  
**Category:** Data  
**Signature:** `(tenant_id, source_refs, transform_chain, split_defs -> transform_chain_hash, split_hashes, lineage_root_hash)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** computes canonical lineage commitments (`transform_chain_hash`, `split_hashes`, and `lineage_root_hash`) from sorted canonical inputs.

**Operator:** `UML_OS.Data.BuildSnapshot_v1`  
**Category:** Data  
**Signature:** `(source_refs, transform_chain, split_defs, access_plan_inputs -> dataset_snapshot_id, data_access_plan_hash)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** materializes immutable snapshot and canonical lineage metadata.

---
## 6) Procedure
```text
1. ValidateSnapshot_v1(inputs)
2. ComputeLineageHash_v1
3. BuildSnapshot_v1
4. Return dataset_snapshot_id + data_access_plan_hash + lineage_report
```

---
## 7) Trace & Metrics
### Logging rule
- snapshot creation emits deterministic lineage records.
### Trace schema
- `run_header`: source_hashes, transform_chain_hash
- `iter`: step, hash, status
- `run_end`: dataset_snapshot_id
### Metric schema
- `source_count`, `transform_count`
### Comparability guarantee
- comparable iff source hashes, transforms, and split configs are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- immutable snapshots, deterministic hash serialization.
#### VII.B Operator test vectors (mandatory)
- source/transform permutations, split hash validations.
#### VII.C Golden traces (mandatory)
- golden snapshot IDs for canonical datasets.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for snapshot ID and lineage hashes.
#### VIII.B Allowed refactor categories
- storage layout changes preserving snapshot ID semantics.
#### VIII.C Equivalence test procedure (mandatory)
- exact snapshot ID compare.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- active snapshot build cursor and lineage partial hashes.
### Serialization
- deterministic CBOR.
### Restore semantics
- resumed snapshot build yields identical snapshot ID.

FILE: layer2-specs/Data-NextBatch.md
====================================
# Universal Machine Learning Operating System â€” Data NextBatch
**EQC Compliance:** This specification follows EquationCode (EQC) v1.1 merged single-file format (Option A): 10 top-level sections, global semantics first, operator-owned math, control-flow-only procedure, deterministic contracts, and replayable stochasticity.

**Algorithm:** `UML_OS.Data.NextBatch_v2`  
**Purpose (1 sentence):** Deliver fully deterministic, memory-efficient, world_size-independent global batch sampling with block-shuffled epoch permutations for training and strict sequential access for evaluation/inference, scalable to 100 B+ sample datasets with O(1) per-sample index resolution after O(num_blocks) preprocessing.  
**Spec Version:** `UML_OS.Data.NextBatch_v2` | 2026-02-18 | Authors: Olejar Damir (with EQC team improvements)  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Deterministic data loading and shuffling for reproducible large-scale distributed ML training and evaluation.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** `UML_OS.Data.NextBatch_v2`
- **Purpose (1 sentence):** Memory-efficient deterministic global sampling with epoch-wise seeded shuffling that is independent of world_size and rank.
- **Spec Version:** `UML_OS.Data.NextBatch_v2` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Scalable deterministic data iteration for any dataset cardinality.

### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Not an optimization operator.
- Primary guarantee: identical global virtual sequence for any (world_size, rank) pair given identical manifest/seed/dataset_cardinality.
- Comparison rule: exact index equality (uint64).

### 0.B Reproducibility Contract
- Seed space: `seed âˆˆ {0..2^64-1}` derived deterministically.
- PRNG family: `Philox4x32-10`
- Randomness locality: only inside `SeededBlockPermute_v1` and `SeededIntraBlockMap_v1`
- Replay guarantee: fully replayable given `(kernel_replay_token, manifest_hash, dataset_key, epoch, global_position, world_size, rank, sampler_block_size)`
- Replay token contribution: `data_replay_t = SHA-256(CBOR_CANONICAL(["nextbatch_v2", kernel_replay_token, dataset_key, uint64(epoch), uint64(global_position), uint32(world_size), uint32(rank)]))`
- Contract-critical hash primitive: `SHA-256(CBOR_CANONICAL(...))`.

### 0.C Numeric Policy
- All indices, cardinalities, positions: uint64 (no wrap-around overflow; explicit bounds checks)
- Block arithmetic: exact integer division/modulo
- No floating-point in core path
- Constants: `DEFAULT_BLOCK_SIZE = 1_048_576` (2^20)
- Overflow/underflow: abort on detected uint64 overflow in cursor or position arithmetic.
- Approx-equality: exact integer equality only (no tolerance path).
- Normalized exponentials / transcendental functions: N/A for this operator class.

### 0.D Ordering and Tie-Break Policy
- Index base: 0-based
- Global batch formation: ascending global virtual position
- Tie break: lowest original index wins (only relevant for boundary handling)

### 0.E Parallel, Concurrency, and Reduction Policy
- Global batch sequence **independent** of `world_size`
- Sharding: contiguous rank-ordered slices of the global virtual sequence (`global_batch_size % world_size == 0` enforced)
- `world_size=1`: full global batch
- No collectives required; pure local computation

### 0.F Environment and Dependency Policy
- Reference runtime: CPU/GPU agnostic (pure index math)
- Dependencies: manifest.datasets[dataset_key] must contain `cardinality: uint64`, `id`, `version`, `hash`
- `manifest.data.sampler_block_size: uint64` (default 1_048_576)
- Determinism level: `BITWISE` for all emitted indices and cursor state.

### 0.G Operator Manifest
- `UML_OS.Data.NextBatch_v2`
- `UML_OS.Data.SeededBlockPermute_v1` (internal helper)
- `UML_OS.Data.SeededIntraBlockMap_v1` (internal helper)
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- Fully-qualified names: `UML_OS.Data.<Name>_v#`

### 0.I Outputs and Metric Schema
- Declared outputs: `(batch_sample_indices: uint64[], cursor_next, sampling_metadata)`
- Minimum metrics: `epoch`, `global_position`, `is_shuffled`, `effective_batch_size`, `blocks_materialized`
- DP/accounting metadata output: `subsampling_mode`, `sampling_mode`, `effective_q`, `sampler_block_size`, `sampler_config_hash`
- Deterministic definitions:
  - `B_eff = global_batch_size`
  - `effective_q = float64(B_eff) / float64(N)`
  - `subsampling_mode = "SHUFFLE_WITHOUT_REPLACEMENT"` in train mode, `"NONE"` in eval/infer mode
  - `sampling_mode = "SHUFFLE_WITHOUT_REPLACEMENT_BLOCK_AFFINE_V1"` in train mode, `"SEQUENTIAL_V1"` in eval/infer mode
  - encoding rule: all mode strings used in hashes are UTF-8 CBOR text strings with no alternate normalization.
  - `sampler_config_hash = SHA-256(CBOR_CANONICAL([sampling_mode, sampler_block_size, drop_last, "epoch_seed_rule_v2", "intra_block_affine_coprime_v1", "rank_contiguous_shard_v1"]))`
- Completion status: `success | failed` with deterministic reason codes from 0.K.

### 0.J Spec Lifecycle Governance
- Reproducibility-breaking changes to sequence formation, sharding, or cursor progression require MAJOR version bump.
- Non-breaking performance-only changes (cache/prefetch without sequence changes) require MINOR bump.
- Equivalence target: E0 exact index-sequence equivalence.

### 0.K Failure and Error Semantics
- Global error model: abort-only
- Failure codes: `INVALID_DATASET_KEY`, `CARDINALITY_MISMATCH`, `BATCH_SIZE_INCONSISTENT`, `GLOBAL_POSITION_EXCEEDS_CARDINALITY`, `INVALID_STAGE_TYPE`
- Failure record fields: `t`, `failure_code`, `dataset_key`, `data_replay_t`

### 0.L Input/Data Provenance
- `dataset_cardinality` must match registered immutable dataset hash

### 0.M Recommended Presets
- `train_shuffle`: block-based + train mode
- `eval_sequential`: no-shuffle + ascending indices
- `streaming_infinite`: wrap-around with epoch seed rotation

---

### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model

### I.A Persistent State
- `data_cursors: map<string, {epoch: uint64, global_index: uint64}>` (per dataset_key)

### I.B Inputs and Hyperparameters
- `dataset_key: string`
- `world_size: uint32`
- `rank: uint32` (0-based)
- `global_batch_size: uint64` (from manifest)
- `stage_type: "train" | "eval" | "infer"`

### I.C Constraints and Feasible Set
- `global_batch_size % world_size == 0`
- `global_batch_size > 0`
- if `world_size > 1`, then `global_batch_size >= world_size`
- `sampler_block_size > 0`
- `dataset_key` exists in manifest.datasets
- Degenerate train/drop-last guard (normative): if `stage_type=="train"` and `drop_last==true` and `global_batch_size > N`, configuration is invalid and MUST abort during validation (zero-batch epochs are forbidden by default policy).
- Train epoch policy (normative): strict bijection without replacement over `[0..N-1]` per epoch; no intra-epoch wrap in train mode.
- If `drop_last=true`, train epoch size is `floor(N/global_batch_size) * global_batch_size`.
- If `drop_last=false`, final train step may be partial; no repeated samples are allowed within the same epoch.
- For `stage_type in {"eval","infer"}`, `drop_last` is ignored; final partial batch MUST be emitted.

### I.D Transient Variables
- `N`, `epoch_seed`, `block_order`, `current_block_perms` (lazy map)

### I.E Invariants and Assertions
- Same `(manifest_hash, epoch, global_position)` â†’ identical sample index
- Eval/infer: sample_indices == [global_pos, global_pos+1, â€¦] % N
- Train: permutation is a bijection over [0 â€¦ N-1]
- `NextBatch_v2` is cursor-pure: it consumes `cursor_in` and returns `cursor_next`; persistence is owned by kernel/checkpoint state.
- DP alignment invariant: emitted `subsampling_mode` must match DP accountant assumption for the same run.

---

## 3) Initialization

1. `cursor <- cursor_in` (caller-owned persistent cursor; default `{epoch:0, global_index:0}` at first use)
2. `N <- manifest.datasets[dataset_key].cardinality`
3. If new epoch (`cursor.global_index == 0`): compute `epoch_seed = SHA-256(CBOR_CANONICAL(["nextbatch_epoch_seed_v2", kernel_replay_token, manifest_hash, dataset_key, uint64(cursor.epoch)]))[0:16]` (Philox seed)

---

## 4) Operator Manifest

Active operators:
- `UML_OS.Data.NextBatch_v2`
- `UML_OS.Data.SeededBlockPermute_v1`
- `UML_OS.Data.SeededIntraBlockMap_v1`
- `UML_OS.Error.Emit_v1`

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

**Operator:** `UML_OS.Data.NextBatch_v2`  
**Category:** Data  
**Signature:** `(dataset_key, world_size, rank, stage_type, cursor_in -> batch_sample_indices: uint64[], cursor_next, sampling_metadata)`  
**Purity class:** PURE  
**Determinism:** deterministic (RNG only inside helpers for train shuffling)  
**Definition:** Computes the next micro-batch of original sample indices according to global virtual order from explicit caller-provided cursor state. Guarantees identical sequence across any distributed configuration and deterministic cursor transition.
**Preconditions / Postconditions:** dataset exists and cardinality is known; `cursor_next` is advanced exactly once on success and must be persisted by caller.  
**Edge cases:** `N < global_batch_size`, final partial range with `drop_last=true`, `world_size=1`.  
**Numerical considerations:** uint64-only arithmetic; explicit bounds checks before modulo/division.  
**Ordering/tie handling:** ascending global virtual positions; contiguous rank shard order.  
**Complexity note:** O(micro_batch_size) per call + O(num_blocks) epoch permutation materialization.  
**Failure behavior:** emits 0.K error codes and aborts deterministically.  
**Dependencies:** `SeededBlockPermute_v1`, `SeededIntraBlockMap_v1`, manifest data schema.  
**Test vectors:** see VII.B (single-rank, multi-rank, large-N, restore continuity).

**Operator:** `UML_OS.Data.SeededBlockPermute_v1`  
**Category:** Data  
**Signature:** `(num_blocks, epoch_seed -> block_order: uint64[])`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Fisher-Yates shuffle of [0 â€¦ num_blocks-1] using Philox seeded by epoch_seed. Materializes only O(num_blocks) memory. For datasets with a short tail block, caller passes only full-size block count and keeps the tail block fixed at the end.
**Preconditions / Postconditions:** `num_blocks > 0`; output is a bijection over block IDs.  
**Edge cases:** `num_blocks = 1`.  
**Numerical considerations:** integer-only index swaps.  
**Ordering/tie handling:** deterministic swap order by ascending iteration index.  
**Complexity note:** O(num_blocks) time and memory.  
**Failure behavior:** abort on invalid `num_blocks` or seed derivation failure.  
**Dependencies:** Philox implementation, deterministic seed derivation.  
**Test vectors:** fixed seed -> exact permutation sequence.

**Operator:** `UML_OS.Data.SeededIntraBlockMap_v1`  
**Category:** Data  
**Signature:** `(block_id, local_pos, block_size, epoch_seed, N -> original_index: uint64)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Computes an explicit affine bijection inside the selected block. Let `block_start = block_id * block_size`, `m = min(block_size, N - block_start)`, and derive `(k0, k1)` from Philox with counter tuple `(epoch_seed, block_id)`. If `m=1`, return `block_start`. Otherwise choose `a` deterministically from seed material:
1. `a <- 1 + (k0 mod (m-1))`
2. for `i in [0..m-2]`: let `cand = 1 + ((a - 1 + i) mod (m-1))`; choose first `cand` with `gcd(cand, m) == 1`
3. if none found (unreachable for `m>1`), abort with deterministic failure code `CONTRACT_VIOLATION`
Then set `c = k1 mod m`, compute `j = (a * local_pos + c) mod m`, and `original_index = block_start + j`.
This is bijective because `gcd(a,m)=1` by construction.
**Preconditions / Postconditions:** `local_pos < m`; output index in `[0, N-1]`; mapping is a permutation over `[block_start, block_start + m - 1]`.  
**Edge cases:** short final block, `N % block_size != 0`.  
**Numerical considerations:** integer modular arithmetic only; no float path; all intermediate arithmetic checked for uint64 overflow before modulo.  
**Ordering/tie handling:** deterministic mapping for every `(block_id, local_pos)`.  
**Complexity note:** O(1) per lookup.  
**Failure behavior:** abort on invalid block bounds.  
**Dependencies:** Philox counter path and epoch seed.  
**Test vectors:** fixed tuple -> exact mapped index; per-block bijection test over all `local_pos in [0, m-1]`.

---

## 6) Procedure

```text
1. cursor = cursor_in
2. N = manifest.datasets[dataset_key].cardinality
3. global_pos = cursor.global_index
4. global_batch_size = manifest.global_batch_size
5. If global_batch_size % world_size != 0: Error.Emit_v1(BATCH_SIZE_INCONSISTENT); abort
5a. If world_size > 1 and global_batch_size < world_size: Error.Emit_v1(BATCH_SIZE_INCONSISTENT); abort
6. micro_batch_size = global_batch_size // world_size
7. rank_start = rank * micro_batch_size
7b. sampler_block_size = manifest.data.sampler_block_size or DEFAULT_BLOCK_SIZE
7c. If sampler_block_size == 0: Error.Emit_v1(BATCH_SIZE_INCONSISTENT); abort

8. if stage_type in {"eval", "infer"}:
       is_shuffled = false
       sampling_mode = "SEQUENTIAL_V1"
       # eval/infer ignore drop_last and always emit terminal partial ranges
       batch_positions = [global_pos + rank_start + i for i in 0..micro_batch_size-1]
       batch_indices = [p % N for p in batch_positions]
   else:
       is_shuffled = true
       sampling_mode = "SHUFFLE_WITHOUT_REPLACEMENT_BLOCK_AFFINE_V1"
       block_size = sampler_block_size
       num_full_blocks = N // block_size
       has_tail = (N % block_size) != 0
       block_order = SeededBlockPermute_v1(num_full_blocks, epoch_seed) if num_full_blocks > 0 else []

       batch_indices = []
       epoch_limit = N
       if manifest.data.drop_last == true:
           num_full_batches = N // global_batch_size
           epoch_limit = (N // global_batch_size) * global_batch_size
       for i in 0..micro_batch_size-1:
           p = global_pos + rank_start + i
           if p >= epoch_limit:  # strict no-wrap train epoch policy
               break
           block_id_global = p // block_size
           if has_tail and block_id_global == num_full_blocks:
               perm_block_id = num_full_blocks  # keep short tail block fixed
           else:
               perm_block_id = block_order[block_id_global]
           local_pos = p % block_size
           orig_idx = SeededIntraBlockMap_v1(perm_block_id, local_pos, block_size, epoch_seed, N)
           batch_indices.append(orig_idx)

9. sampler_config_hash = SHA-256(CBOR_CANONICAL([sampling_mode, sampler_block_size, manifest.data.drop_last, "epoch_seed_rule_v2", "intra_block_affine_coprime_v1", "rank_contiguous_shard_v1"]))
10. epoch_limit_for_advance = N
    if stage_type == "train" and manifest.data.drop_last == true:
        epoch_limit_for_advance = (N // global_batch_size) * global_batch_size
11. produced_global_count = global_batch_size
    if stage_type == "train":
        remaining = epoch_limit_for_advance - global_pos
        if remaining <= 0:
            produced_global_count = 0
        else if remaining < global_batch_size:
            produced_global_count = remaining
12. cursor.global_index += produced_global_count
13. if cursor.global_index >= epoch_limit_for_advance:
        cursor.epoch += 1
        cursor.global_index = 0   # start new epoch
14. return batch_indices, cursor, {sampling_mode, sampler_config_hash}
```

**Scalability & Algorithmic Guarantees (v2):**
- Memory: O(num_blocks) worst-case (~1 MiB for 1 B samples with 1 M block_size); lazy per-batch block materialization possible in future.
- Time: O(micro_batch_size) per call with O(1) intra-block mapping.
- Exact bijection in train mode within each epoch; perfect reproducibility across restarts, world_size, hardware.
- Bijection proof sketch: full blocks are permuted bijectively among full blocks; each block uses affine bijection over its local domain; tail block is mapped only to itself with its own domain length, so global mapping is a permutation over `[0, N)`.
- drop_last behavior is configurable via manifest (`drop_last=false` default).
- For `drop_last=false`, terminal train step may be partial and is emitted without replacement.

---

## 7) Trace & Metrics

### Logging rule
Each invocation emits one deterministic trace record with cursor-before/cursor-after and replay token contribution.

### Trace schema (minimum required)
- `run_header`: `dataset_key`, `cardinality`, `sampler_block_size`, `is_shuffled_per_stage`
- `iter`: `t`, `epoch`, `global_position`, `is_shuffled`, `micro_batch_size`, `global_batch_size`, `subsampling_mode`, `sampling_mode`, `sampler_config_hash`, `effective_q`, `epoch_seed_hash`, `data_replay_t`
- `run_end`: final epoch count, total_samples_seen

### Metric schema
- `epoch`, `global_position`, `effective_batch_size`, `blocks_materialized_this_epoch`

### Comparability guarantee
Two runs are comparable iff dataset snapshot/hash, sampler config, replay token definition, and emitted metric schema are identical.

---

## 8) Validation

#### VII.A Lint rules (mandatory)
Passes symbol completeness, deterministic ordering, total state updates (only cursor), explicit RNG locality, edge-case totality.
- Must reject `drop_last==true && global_batch_size > N` for train stage as invalid configuration.

#### VII.B Operator test vectors (mandatory)
- world_size=1, rank=0: full global sequence matches sequential + shuffle
- world_size=8, any rank: contiguous shards reconstruct global sequence exactly
- N=10^9+, block_size=1M: no OOM, identical across runs
- eval mode: always sequential indices
- checkpoint/restore mid-epoch: identical continuation

#### VII.C Golden traces (mandatory)
Golden runs for N=10^6, 10^9 with multiple world_sizes; exact index sequences verified.

---

## 9) Refactor & Equivalence

#### VIII.A Equivalence levels
- E0: exact sample index sequences and cursor state
- E1: identical training dynamics (loss curves within noise)

#### VIII.B Allowed refactor categories
- Intra-block mapping optimization (Feistel, AES-based, etc.) preserving bijection
- Prefetch / cache-friendly block loading
- Weighted/class-balanced extensions (with manifest flag and extra seed stream)

#### VIII.C Equivalence test procedure (mandatory)
- 5 seeds Ã— 3 world_sizes Ã— 2 modes
- Compare full batch index sequences (exact match required for E0)

---

## 10) Checkpoint/Restore

### Checkpoint contents
- `data_cursors` map (epoch + global_index per dataset_key only)

### Serialization
- Deterministic CBOR with fixed field order

### Restore semantics
- Identical subsequent batch sequences under same manifest/seed
- Mid-epoch restore supported (no re-shuffle of current epoch)

FILE: layer2-specs/Deployment-Runbook.md
========================================
# UML_OS Deployment Runbook Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.DeploymentRunbook_v1`  
**Purpose (1 sentence):** Define deterministic deployment, rollback, and incident-response procedures for dev/staging/prod environments.  
**Spec Version:** `UML_OS.Implementation.DeploymentRunbook_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Operational deployment governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.DeploymentRunbook_v1`
- **Purpose (1 sentence):** Deterministic deployment operations.
- **Spec Version:** `UML_OS.Implementation.DeploymentRunbook_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Release operations and reliability.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize failed rollouts and recovery time.
### 0.B Reproducibility Contract
- Replayable given `(release_manifest_hash, environment_profile, deployment_policy_bundle_hash)`.
### 0.C Numeric Policy
- SLO/SLA thresholds evaluated in binary64.
### 0.D Ordering and Tie-Break Policy
- Deployment stages proceed in strict order: dev -> staging -> prod.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel instance rollout allowed with deterministic canary and gate aggregation.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for gate verdicts and rollback decisions.
### 0.G Operator Manifest
- `UML_OS.Deploy.PreflightChecks_v1`
- `UML_OS.Deploy.ExecuteRollout_v1`
- `UML_OS.Deploy.EvaluateHealthGates_v1`
- `UML_OS.Deploy.ExecuteRollback_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Deployment operators fully-qualified and environment-scoped.
### 0.I Outputs and Metric Schema
- Outputs: `(deployment_report, rollback_report?)`.
- Metrics: `rollout_success_rate`, `mean_recovery_time`, `incident_count`.
- `rollout_success_rate` definition (normative): `(successful_canary_stages / total_canary_stages_attempted) * 100`.
- Completion status: `success | failed | rolled_back`.
### 0.J Spec Lifecycle Governance
- Gate-policy semantic changes require version bump.
### 0.K Failure and Error Semantics
- Abort or rollback on failed critical gates.
### 0.L Input/Data Provenance
- Release artifacts and manifests are hash-addressed and signed.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.


## 2) System Model
### I.A Persistent State
- environment state snapshots and deployment history.
### I.B Inputs and Hyperparameters
- release bundle, target environment, rollout strategy, health thresholds.
### I.C Constraints and Feasible Set
- Valid deployment requires passing preflight + health gates.
### I.D Transient Variables
- canary status, gate diagnostics, rollback cursor.
### I.E Invariants and Assertions
- production promotion only after staging pass.

### II.F Deterministic Rollout Playbook (Concrete)
- Preflight checks: signature verification, dependency lock verification, config-schema validation, checkpoint compatibility check.
- Canary policy: fixed cohort order `[1%, 5%, 25%, 50%, 100%]`, each stage advances on deterministic sample-count windows (not wall-clock dwell).
- Gate thresholds:
  - error_rate <= 0.5%
  - p95_latency_delta <= 10%
  - replay_determinism_failures == 0
  - boundary rule (normative): floating-point threshold checks use `value <= threshold + EPS_EQ` with `EPS_EQ=1e-10`.
- Gate metric definitions (normative):
  - `error_rate` = `failed_requests / total_requests` over the fixed canary evaluation window declared in rollout policy.
  - `p95_latency_delta` = `(p95_latency_canary - p95_latency_baseline) / p95_latency_baseline * 100`, with baseline from the last approved production release bound by `baseline_release_hash`.
  - `replay_determinism_failures` = count of E0 replay-check failures over the same fixed window.
    - failure criterion is a divergence reported by `UML_OS.Replay.CompareTrace_v1` under the applicable comparison profile from `docs/layer2-specs/Replay-Determinism.md`.
  - rollout input MUST include explicit `baseline_release_hash`; baseline selection is not inferred implicitly.
  - All gate metrics are computed from a frozen, canonicalized telemetry snapshot committed as `metrics_snapshot_hash`.
  - `metrics_snapshot_hash = SHA-256(CBOR_CANONICAL(metrics_snapshot_map))`.
- Gate verdict determinism: verdict is computed from a frozen metrics snapshot (`metrics_snapshot_hash`) captured at each canary stage; real-time telemetry ordering is not used directly for final verdict computation.
- Rollback triggers: any threshold breach at any stage, signature mismatch, or missing trace artifacts.
- Promotion gate:
  - production promotion requires valid `ExecutionCertificate` and `EvidenceValidate` pass.
  - Signed-field hash equality checks are mandatory before promotion:
    - `ExecutionCertificate.signed_payload.manifest_hash == release_manifest_hash`
    - `ExecutionCertificate.signed_payload.trace_final_hash == approved_trace_final_hash`
    - `ExecutionCertificate.signed_payload.checkpoint_hash == approved_checkpoint_hash`
    - `ExecutionCertificate.signed_payload.policy_bundle_hash == deployment_policy_bundle_hash`
    - `ExecutionCertificate.signed_payload.lockfile_hash == lockfile_hash`
    - `ExecutionCertificate.signed_payload.dependencies_lock_hash == SHA-256(CBOR_CANONICAL(["deps_lock_v1", lockfile_hash, toolchain_hash, runtime_env_hash]))`
    - `ExecutionCertificate.signed_payload.determinism_profile_hash == runtime_determinism_profile_hash`
    - `ExecutionCertificate.signed_payload.operator_contracts_root_hash == operator_contracts_root_hash`
    - `ExecutionCertificate.signed_payload.lineage_root_hash == expected_lineage_root_hash`
- Required logged artifacts: `release_hash`, `sbom_hash`, `gate_report_hash`, `rollback_report_hash` (if rollback executed).
- Artifact commitment formulas:
  - `release_hash = SHA-256(CBOR_CANONICAL(["release_v1", image_digest, code_commit_hash, lockfile_hash, toolchain_hash]))`.
  - `image_digest` is the immutable OCI manifest digest (`sha256:<hex>`) resolved from registry manifest bytes.
  - `sbom_hash = SHA-256(sbom_bytes)` where `sbom_bytes` is canonical SPDX JSON (UTF-8, lexicographically sorted object keys, no insignificant whitespace).
- Secrets and keys:
  - secret injection only through managed secret stores,
  - key rotation procedure and rotation audit record required before promotion.
- Transport and isolation requirements:
  - control-plane mTLS required,
  - trust-root pinning policy required,
  - minimum cipher-suite baseline required,
  - namespace/network-policy/storage-path segregation required between tenants/environments.
- Migration/DR:
  - migration playbook must include schema/version compatibility checks and rollback points,
  - disaster recovery artifacts required: last-good checkpoint manifest hash, restore procedure hash, incident timeline log.

### II.G Atomic Run Commit Protocol (Normative)
- Finalization of a run is a deterministic commit-pointer protocol:
  1. write immutable content-addressed trace/checkpoint/lineage/certificate objects,
  2. compute and validate bound hashes,
  3. emit terminal WAL finalize record,
  4. publish single COMMITTED pointer object with `{trace_final_hash, checkpoint_hash, lineage_root_hash, certificate_hash, wal_terminal_hash}` via conditional create-if-absent.
- Crash recovery validates COMMITTED pointer if present; if absent, run remains uncommitted and recovery proceeds from WAL.

### II.H CAS Retention and Garbage Collection (Normative)
- Objects are content-addressed and immutable.
- Retention classes: `golden`, `certified_release`, `experimental`, `ephemeral`.
- Reachability roots include valid execution certificates and pinned model releases.
- GC policy:
  - mark reachable objects from active roots,
  - enforce minimum retention windows by class,
  - sweep only unreachable expired objects.
- GC must never delete objects reachable from active certified artifacts; every deletion emits an auditable hash-chained GC log.

### II.I Key Rotation and Revocation (Normative)
- Signing and redaction keys must declare `key_id`, validity window, and rotation cadence.
- Revocation evidence bundle must be hash-pinned and checked during certificate verification.
- Deployment promotion must fail if signer/redaction keys are revoked or outside validity window at verification time.

---
## 3) Initialization
1. Load release manifest and signatures.
2. Validate environment readiness.
3. Initialize rollout state.

---
## 4) Operator Manifest
- `UML_OS.Deploy.PreflightChecks_v1`
- `UML_OS.Deploy.ExecuteRollout_v1`
- `UML_OS.Deploy.EvaluateHealthGates_v1`
- `UML_OS.Deploy.ExecuteRollback_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

Template conformance note (III.A): each operator definition in this section is interpreted with the full EQC operator template fields. When a field is not repeated inline, the section-level defaults are: explicit typed signatures, deterministic ordering/tie handling, declared numerical policy inheritance, deterministic failure semantics (0.K), explicit dependencies, and VII.B test-vector coverage.

**Operator:** `UML_OS.Deploy.PreflightChecks_v1`  
**Category:** IO  
**Signature:** `(release, env -> preflight_report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** validates artifact integrity, configuration, and capacity prerequisites.

**Operator:** `UML_OS.Deploy.ExecuteRollout_v1`  
**Category:** IO  
**Signature:** `(release, env, strategy -> rollout_state)`  
**Purity class:** IO  
**Determinism:** deterministic orchestration  
**Definition:** executes staged rollout with deterministic canary sequence.

**Operator:** `UML_OS.Deploy.EvaluateHealthGates_v1`  
**Category:** IO  
**Signature:** `(rollout_state, thresholds -> gate_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** evaluates health and policy gates.

**Operator:** `UML_OS.Deploy.ExecuteRollback_v1`  
**Category:** IO  
**Signature:** `(env, previous_release -> rollback_report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** restores previous stable release and validates post-rollback health.

---
## 6) Procedure
```text
1. PreflightChecks_v1
2. ExecuteRollout_v1
3. EvaluateHealthGates_v1
4. If gate failure -> ExecuteRollback_v1
5. Emit deployment report
```

---
## 7) Trace & Metrics
### Logging rule
Every rollout stage emits deterministic operational records.
### Trace schema
- `run_header`: release_hash, env
- `iter`: stage, action, gate_result
- `run_end`: final_status
### Metric schema
- `rollout_success_rate`, `mean_recovery_time`, `incident_count`
### Comparability guarantee
Comparable iff release/gate policies and environment profiles are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
Passes deterministic stage ordering and explicit rollback semantics.
#### VII.B Operator test vectors (mandatory)
Includes preflight, rollout, gate-fail, rollback fixtures.
#### VII.C Golden traces (mandatory)
Golden rollout and rollback traces for baseline releases.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for gate verdict and rollout/rollback decisions.
#### VIII.B Allowed refactor categories
- deployment automation refactor preserving stage/gate semantics.
#### VIII.C Equivalence test procedure (mandatory)
Exact compare of stage transitions and final status.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- rollout cursor, canary set, gate states.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- resumed rollout yields identical stage sequence and decisions.

---
## 11) Packaging and Usage-Metering Addendum (Normative)
- Turnkey deployment artifacts MUST be published per release:
  - versioned Helm chart,
  - versioned Terraform module,
  - hardened default runtime configuration set.
- Upgrade/rollback playbooks MUST be version-locked and evidence-bound.
- Canonical usage record schema (for chargeback/internal accounting):
  - `{tenant_id, run_id, window_start_utc, window_end_utc, cpu_time_ms, gpu_time_ms, io_bytes, storage_bytes_peak, quota_policy_hash, usage_record_hash}`.
- Usage aggregation policy:
  - fixed deterministic windows, no overlapping attribution, stable ordering by `(tenant_id, run_id, window_start_utc)`.
- Enforcement loop rule:
  - quota checks and usage records must be emitted from the same deterministic resource ledger snapshot.

FILE: layer2-specs/DifferentialPrivacy-Apply.md
===============================================
# Universal Machine Learning Operating System â€” Differential Privacy Gradient Applicator
**EQC Compliance:** This specification follows EquationCode (EQC) v1.1 merged single-file format (Option A): 10 top-level sections, global semantics first, operator-owned math, control-flow-only procedure, deterministic contracts, and replayable stochasticity.

**Algorithm:** `UML_OS.DifferentialPrivacy.Apply_v3`  
**Purpose (1 sentence):** Apply deterministic clipping (with FlashDP-fused and PEFT-aware paths), smart privacy budget allocation, heterogeneous per-layer/per-group noise, pre-computed sigma schedules, scaling-law projections, and PLD-default accounting with safety-reserve abort-on-budget semantics for regulated frontier LLM training.  
**Spec Version:** `UML_OS.DifferentialPrivacy.Apply_v3` | 2026-02-18 | Authors: Olejar Damir (with EQC team improvements)  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** DP-SGD and related private first-order optimization at LLM/frontier scale.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** `UML_OS.DifferentialPrivacy.Apply_v3`
- **Purpose (1 sentence):** Differential privacy mechanism for gradients with deterministic clipping, heterogeneous noise scheduling, and exact accounting.
- **Spec Version:** `UML_OS.DifferentialPrivacy.Apply_v3` | 2026-02-18 | Authors: Olejar Damir (with EQC team improvements)
- **Domain / Problem Class:** DP-SGD and related private first-order optimization at LLM/frontier scale.

### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: `a â‰¼ b iff a <= b + EPS_EQ` for budget and threshold checks
- `EPS_EQ = 1e-10` in binary64
- Invalid objective policy: any NaN/Inf in gradients, sigma maps, or accountant state is terminal and mapped to deterministic failure code.

### 0.B Reproducibility Contract
- Seed space: `seed in {0..2^64-1}`
- PRNG family: `Philox4x32-10`
- Randomness locality: all sampling occurs only inside `UML_OS.DifferentialPrivacy.GenerateNoise_v1`
- Replay guarantee: replayable given `(seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy)`
- Replay token contribution: `dp_replay_t = SHA-256(CBOR_CANONICAL(["dp_apply_v3", kernel_replay_token, uint64(t), dp_accountant_state_hash, allocation_mode, fused_kernel, safety_reserve]))`
- `noise_seed_per_step: bool` (default `false`); when true, counter derivation is `counter = (uint128(t) << 40) + uint128(param_index_hash)` (128-bit arithmetic, no 64-bit wrap)
  - `param_index_hash` is the lower 40 bits of `U64_BE(SHA-256(CBOR_CANONICAL(["dp_param_v1", param_fqn])))`.

### 0.C Numeric Policy
- Critical arithmetic (norms, clipping scales, means, sigma schedules/maps, accountant state): IEEE-754 binary64
- Deterministic reductions: ascending global parameter index with Kahan summation in binary64
- Heterogeneous maps (`sigma_map`, `clip_norm_map`, `sensitivity_map`, `stddev_map`) are processed in binary64 with deterministic group-local Kahan reductions
- Stable norm computation: max-rescaled L2 path + Kahan accumulation
- Optional `log_space_accounting: true` for very long runs (`steps > 10k`)
- Output cast: `manifest.compute_dtype` only at final return
- Rounding mode: round-to-nearest ties-to-even
- Fast-math: forbidden
- Constants: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, `EPS_CLIP=1e-8`
- Sigma clamp: per-entry `sigma in [1e-8, 1e8]`
- NaN/Inf policy: abort per 0.K
- Approx-equality: `a ~= b iff |a-b| <= EPS_EQ`
- Accountant reproducibility: accountant path is bitwise reproducible in binary64 for identical inputs and ordering.
- Normalized exponentials: N/A for core DP pipeline except accountant internals, which must use numerically stable log-domain operations.

### 0.D Ordering and Tie-Break Policy
- Index base: `0-based`
- Stable sort required
- Tie break: lowest index wins
- Iteration/reduction order: ascending global parameter index, then ascending rank

### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel chunking: fixed 256-element chunks, deterministic merge order
- `parallelism.type: "dp_only" | "3d" | "fsdp2" | "zero3" | "moe"`
- `world_size=1`: exact `(epsilon, delta)` guarantee
- `world_size>1` with `per_sample`/`per_layer`/`per_group`: exact accounting, deterministic all-gather/all-reduce for required statistics
- `world_size>1` with `ghost` local clipping path: allowed with declared `accounting_adjustment_factor`; guarantee documented as `(epsilon', delta)` where `epsilon' >= epsilon`
- `ghost` path policy: in `regulated` mode, ghost clipping is permitted only when `accounting_adjustment_factor` is derived from a versioned audited bound artifact (`ghost_bound_hash`) and `accounting_adjustment_factor >= 1.0`; otherwise abort with `INVALID_DP_CONFIG`.
- `fsdp2/zero3`: ghost clipping uses unsharded logical views when available; only aggregate statistics are all-reduced
- `moe`: per-expert accounting with routing-aware effective sampling rate
- Hierarchical all-reduce path is allowed when `parallelism.hierarchical=true` (deterministic intra-node then inter-node merge order)
- No async updates or unordered reductions permitted.

### 0.F Environment and Dependency Policy
- Reference runtime class: GPU-enabled, distributed-capable
- Compiler/flags: fast-math disabled
- Dependencies: deterministic Philox implementation + verified accountant implementation (`pld` default; `moments`/`rdp`/`f_dp`/`gdp` fallback)
- Determinism level: `BITWISE` for clipping/sigma/accountant outputs; sampled noise is bitwise-replayable given `(seed, rng offsets, numeric policy, determinism profile)`.

### 0.G Operator Manifest
- `UML_OS.DifferentialPrivacy.PreValidation_v1`
- `UML_OS.DifferentialPrivacy.ConfigResolver_v1`
- `UML_OS.DifferentialPrivacy.SensitivityAnalyzer_v1`
- `UML_OS.DifferentialPrivacy.PrivacyBudgetAllocator_v1`
- `UML_OS.DifferentialPrivacy.Clip_v1`
- `UML_OS.DifferentialPrivacy.ClipPerSample_v1`
- `UML_OS.DifferentialPrivacy.GhostClipPerSample_v1`
- `UML_OS.DifferentialPrivacy.PerLayerClip_v1`
- `UML_OS.DifferentialPrivacy.PerGroupClip_v1`
- `UML_OS.DifferentialPrivacy.PerTensorClip_v1`
- `UML_OS.DifferentialPrivacy.PEFTAwareClipHandler_v1`
- `UML_OS.DifferentialPrivacy.FlashEfficientClip_v1`
- `UML_OS.DifferentialPrivacy.BoundedPrivacyAwareAdaptiveClipNorm_v1`
- `UML_OS.DifferentialPrivacy.PrivacyBudgetScheduler_v1`
- `UML_OS.DifferentialPrivacy.DPScalingLawProjector_v1`
- `UML_OS.DifferentialPrivacy.AmplificationByShuffling_v1`
- `UML_OS.DifferentialPrivacy.GenerateNoise_v1`
- `UML_OS.DifferentialPrivacy.Accountant.Update_v1`
- `UML_OS.DifferentialPrivacy.MomentsAccountant.Update_v1`
- `UML_OS.DifferentialPrivacy.PLDAccountant.Update_v1`
- `UML_OS.DifferentialPrivacy.RDPAccountant.Update_v1`
- `UML_OS.DifferentialPrivacy.FDPAccountant.Update_v1`
- `UML_OS.DifferentialPrivacy.GDPAccountant.Update_v1`
- `UML_OS.Error.Emit_v1`
- `UML_OS.DifferentialPrivacy.Apply_v3`

### 0.H Namespacing and Packaging
- Fully-qualified names: `UML_OS.DifferentialPrivacy.<Name>_v#`
- Sidecar mapping is mandatory (`operator -> module/function`).

### 0.I Outputs and Metric Schema
- Declared outputs: `(noisy_gradients, updated_budget, dp_metrics)`
- Minimum metrics: `clip_fraction`, `noise_scale_sigma`, `cumulative_epsilon`, `privacy_budget_remaining`
- Extended metrics: `norm_p50`, `norm_p95`, `norm_max`, `effective_noise_multiplier`, `effective_heterogeneous_multiplier`, `accountant_type_used`, `pld_epsilon_tight`, `gradient_snr`, `group_clip_fraction`, `effective_accumulation_factor`, `projected_final_epsilon`, `privacy_allocation_mode`, `fairness_clip_ratio`, `scaling_law_confidence`, `peft_noise_reduction_factor`
- Completion status: `success | failed` with deterministic reason codes from 0.K.

### 0.J Spec Lifecycle Governance
- Any accountant algorithm change or clipping strategy semantics change requires MAJOR version bump.
- Scheduler mode additions require MINOR bump if backward-compatible.
- Equivalence targets: E0 for clipping/accounting path; E2 for stochastic outputs.

### 0.K Failure and Error Semantics
- Global error model: abort-only with deterministic final record
- Failure codes: `PRIVACY_BUDGET_EXCEEDED`, `INVALID_GRADIENT`, `NAN_IN_SIGMA`, `ACCOUNTANT_OVERFLOW`, `ACCOUNTANT_DIVERGENCE`, `RNG_CONSUMPTION_VIOLATION`, `INVALID_DP_CONFIG`
- `safety_budget_reserve` is a fractional reserve `r in [0,1)`.
- Soft safety warning threshold: `warn_threshold = target_epsilon * (1 - r)`
- Failure record fields: `t`, `failure_code`, `failure_operator`, `dp_replay_t`, `state_fp_t`

### 0.L Input/Data Provenance
- Input gradients originate from kernel-validated model backward pass.
- `sampling_rate`, `batch_size`, effective dataset cardinality, accumulation factor, and routing stats (`moe`) must be traceable to manifest + dataset registry.

### 0.M Recommended Presets
- `llm_flash`: `flash_efficient + per_layer + pld + bounded_adaptive + scaling_law + fsdp2 + fused`
- `peft_max_utility`: `peft_targeted + ghost + pld + budget_allocator + low_noise`
- `regulated_fair`: `bounded_adaptive + per_group + pld + uniform_allocation + safety_reserve=0.12`
- `frontier_trillion`: `hybrid + flash_efficient + pld + dynamic_projection + 3d_parallel`

---

### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model

### I.A Persistent State
- `cumulative_epsilon_t in R_{>=0}` (binary64)
- `rng_dp_state_t` with deterministic offset ownership
- `clip_norm_state_t` (for adaptive clipping)
- `norm_history_state` (adaptive clipping): fixed-size circular buffer of recent gradient norms plus deterministic write index and count.
- `accountant_state_t` (PLD/moments/RDP/f-DP/gDP internal deterministic state)
- `accumulation_state_t` (partial clipped sums and accumulation counter)

### I.B Inputs and Hyperparameters
- `gradients`
- `security.differential_privacy`:
  - `enabled: bool`
  - `mechanism: "gaussian"`
  - `accountant: "pld" | "moments" | "rdp" | "f_dp" | "gdp"` (default/recommended: `pld`)
  - `subsampling: "SHUFFLE_WITHOUT_REPLACEMENT" | "NONE"`
  - `sampling_mode: string` (from `docs/layer2-specs/Data-NextBatch.md` sampler metadata)
  - `accountant_granularity: "PER_STEP"` (required)
  - `clipping.strategy: "per_sample" | "ghost" | "per_layer" | "per_group" | "per_tensor" | "hybrid" | "peft_targeted" | "adaptive"`
  - `clipping.norm: float | "adaptive"`
  - `clip_norm_map: dict | null`
    - completeness rule: when resolved for a step, `clip_norm_map` MUST contain an entry for every active privacy group `g`.
  - `sensitivity_map: dict | null`
  - `sigma_map: dict | null` (dimensionless multipliers `sigma_g`)
  - `noise.per_layer_multiplier: dict | null`
  - `noise.compression: "none" | "topk_dp" | "sparse_dp"`
  - `fused_kernel: bool` (default `true` for llm presets)
  - `max_microbatch: int` (default `256`)
  - `adaptive_clip_window: uint64` (default `100`, used when `clipping.strategy=="adaptive"`)
  - `noise_multiplier: float` (default `1.0`)
  - `target_epsilon: float`
  - `target_delta: float` (default `1e-5`)
  - `pld_discretization_bins: uint64` (default `1000000`)
  - `pld_truncation_bound: float64` (default `1e-12`)
  - `target_steps: int?`
  - `mode: "fixed" | "budget_adaptive" | "meet_exactly_at_target_steps" | "step_decay" | "dynamic_projection"`
  - `gradient_accumulation_steps: int` (default `1`)
  - `model_scale: float64` (optional; projector hint input)
  - `accumulation_context: {current_step: int, is_final: bool}`
  - `privacy.adaptive_accounting: "conservative" | "heuristic"`
  - `privacy_allocation: "uniform" | "layer_wise" | "custom"`
  - `safety_budget_reserve: float` (default `0.08`)
  - `accounting_adjustment_factor: float` (default `1.0`)
  - `parallelism.hierarchical: bool` (default `false`)
  - `parallelism.type: "dp_only" | "3d" | "fsdp2" | "zero3" | "moe"`
  - `training_phase: "warmup" | "main" | "cooldown"`
  - `public_modules: list | null` (zero privacy-cost modules)
- `sampling_rate`, `effective_batch_size`, `model_scale`, `t`
  - `accountant_hint` (derived) = configured `accountant` enum value for projector/scheduler hinting.

### I.C Constraints and Feasible Set
- Unconstrained optimization context.
- Runtime constraints: `target_epsilon >= 0`, `target_delta in (0,1)`, `noise_multiplier >= 0` (debug mode permits `0`), valid clipping strategy/scheduler/accountant, deterministic contract checks.
- PLD constraints: when `accountant=="pld"`, `pld_discretization_bins` and `pld_truncation_bound` are mandatory-effective (explicit or defaults), and MUST be included in DP config hash commitment.
- DP config hash commitment rule: all configured DP fields that influence behavior (including optional `adaptive_clip_window` and `model_scale` when present) MUST be included in the canonical DP config hash (`dp_policy_hash` input).

### I.D Transient Variables
- `clipped_gradients`, `per_sample_norms`, `per_group_norms`, `sigma_map_t`, `stddev_map_t`, `noise_t`, `averaged_gradients`, `projected_epsilon`, `allocation_map`, `amplification_factor`

### I.E Invariants and Assertions
- `cumulative_epsilon` is finite and non-decreasing
- output tensor shape equals input gradient shape
- all critical reductions follow fixed deterministic ordering
- clipping may occur per micro-batch; accountant update and noise draw occur once per optimizer step.

### II.F Mechanism Definition (Formal)
- Adjacency: record-level adjacency (datasets differ by one record via add/remove or replace).
- Parameter space is partitioned into disjoint groups `g in G` by `privacy_allocation`.
- Per-group sensitivity bound: for each sample `i`, clipped gradient satisfies `||clip_g(grad_{i,g})||_2 <= C_g`.
- Per-optimizer-step release for group `g`:
  `G_tilde_g = (1/B_eff) * (sum_i clip_g(grad_{i,g}) + N(0, (sigma_g * C_g / B_eff)^2 I))`,
  where `B_eff` is the effective optimizer-step batch size after accumulation.
- `sigma_map_t[g]` is the dimensionless multiplier `sigma_g`.
- `stddev_map_t[g]` is derived deterministically as `stddev_map_t[g] = sigma_map_t[g] * C_g / B_eff`.
- Group composition at a step uses the selected accountant (`PLD` default, `RDP`/`moments`/`f_dp`/`gdp` fallback) with explicit `sampling_rate`, `subsampling`, and optional `amplification_factor`.
- Normative heterogeneous composition rule:
  - Renyi-order grid is config-bound and deterministic (`alpha_grid` in DP config); default:
    - `alpha_grid = [1.25, 1.5, 1.75, 2, 2.5, 3, 4, 5, 6, 8, 10, 12, 16, 24, 32, 48, 64]`.
  - For each Renyi order `alpha` in `alpha_grid`, compute `RDP_step(alpha) = sum_g RDP_g(alpha; q, sigma_g)` using a uniform global sampling rate `q = effective_batch_size / dataset_cardinality` for all groups.
  - Compose across optimizer steps by summation in deterministic step order.
  - Convert to `(epsilon, delta)` via deterministic minimization over the fixed `alpha` grid.
  - PLD path is allowed as primary implementation only when `pld_discretization_bins`, `pld_truncation_bound`, and declared error bound are config-bound and included in trace.
- Step composition: accountant composes optimizer steps in deterministic order; `(epsilon, delta)` reported from accountant conversion per optimizer step.
- Ghost clipping: when enabled, accountant input uses `sampling_rate' = min(1.0, accounting_adjustment_factor * sampling_rate)` and requires audited bound artifact in regulated mode.
- zero-sensitivity rule: groups with sensitivity `0` MUST set `sigma_g=0`, `stddev_g=0`, and contribute zero privacy cost in accountant updates.

### II.G Subsampling/Accounting Alignment (Normative)
- `subsampling` must be one of `SHUFFLE_WITHOUT_REPLACEMENT` or `NONE`.
- Normative mapping:
  - sampler `SHUFFLE_WITHOUT_REPLACEMENT` -> accountant uses fixed-size without-replacement composition.
  - sampler `NONE` -> accountant uses full-batch composition (`q=1`).
- Accountant assumptions must match sampler behavior declared in `docs/layer2-specs/Data-NextBatch.md`.
- Heterogeneous-group rule: group-specific subsampling rates are not supported in this version; composition uses the single global sampling rate `q` for all groups.
- If exact match is unavailable, run must declare deterministic approximation policy and log `accounting_approximation_policy` in trace.

### II.H Adaptation Safety (Normative)
- Any adaptation of `clip_norm`, `allocation_map`, or budget schedule that depends on private gradients must use:
  - DP-sanitized aggregates only, or
  - explicitly budgeted adaptation composed into the same accountant state.
- Adaptation budget consumption (`delta_eps`) must be logged and included in replay/checkpoint accountant state.

### II.I DP Metric Definitions (Normative)
- `gradient_snr = mean(abs(averaged_clipped)) / (std(noise_step) + EPS_DENOM)`.
- `fairness_clip_ratio = clipped_group_count / max(1, total_group_count)`.
- `scaling_law_confidence` is the confidence output from `DPScalingLawProjector_v1` in `[0,1]`.
- `peft_noise_reduction_factor = sigma_full_model / max(EPS_DENOM, sigma_peft_target)`.
- `effective_heterogeneous_multiplier = sigma_effective / max(EPS_DENOM, sigma_base)`.

---

## 3) Initialization

1. `t <- kernel_t`
2. bind `rng_dp_state <- kernel_master_rng` with DP-owned offset stream
3. load or initialize `cumulative_epsilon <- checkpoint_or_zero`
4. `resolved_cfg <- UML_OS.DifferentialPrivacy.ConfigResolver_v1(dp_config)`
5. initialize accountant state for selected `accountant`
6. precompute sigma schedule/cache for target-based modes using deterministic global inversion (binary search cap `30` iterations; cached for reuse)

---

## 4) Operator Manifest

Active operators (exact wiring table):
- `UML_OS.DifferentialPrivacy.PreValidation_v1`
- `UML_OS.DifferentialPrivacy.ConfigResolver_v1`
- `UML_OS.DifferentialPrivacy.SensitivityAnalyzer_v1`
- `UML_OS.DifferentialPrivacy.PrivacyBudgetAllocator_v1`
- `UML_OS.DifferentialPrivacy.Clip_v1`
- `UML_OS.DifferentialPrivacy.ClipPerSample_v1`
- `UML_OS.DifferentialPrivacy.GhostClipPerSample_v1`
- `UML_OS.DifferentialPrivacy.PerLayerClip_v1`
- `UML_OS.DifferentialPrivacy.PerGroupClip_v1`
- `UML_OS.DifferentialPrivacy.PerTensorClip_v1`
- `UML_OS.DifferentialPrivacy.PEFTAwareClipHandler_v1`
- `UML_OS.DifferentialPrivacy.FlashEfficientClip_v1`
- `UML_OS.DifferentialPrivacy.BoundedPrivacyAwareAdaptiveClipNorm_v1`
- `UML_OS.DifferentialPrivacy.PrivacyBudgetScheduler_v1`
- `UML_OS.DifferentialPrivacy.DPScalingLawProjector_v1`
- `UML_OS.DifferentialPrivacy.AmplificationByShuffling_v1`
- `UML_OS.DifferentialPrivacy.GenerateNoise_v1`
- `UML_OS.DifferentialPrivacy.Accountant.Update_v1`
- `UML_OS.DifferentialPrivacy.MomentsAccountant.Update_v1`
- `UML_OS.DifferentialPrivacy.PLDAccountant.Update_v1`
- `UML_OS.DifferentialPrivacy.RDPAccountant.Update_v1`
- `UML_OS.DifferentialPrivacy.FDPAccountant.Update_v1`
- `UML_OS.DifferentialPrivacy.GDPAccountant.Update_v1`
- `UML_OS.Error.Emit_v1`
- `UML_OS.DifferentialPrivacy.Apply_v3`

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

Template conformance note (III.A): each operator below explicitly declares `Operator/Category/Signature/Purity class/Determinism/Definition`; the following fields apply to all operators unless overridden inline:
- Preconditions / Postconditions: all typed inputs validated by `PreValidation_v1`; outputs are schema-valid and deterministic under declared policies.
- Edge cases: empty/degenerate tensors, tiny batches, extreme scheduler/accountant boundaries.
- Numerical considerations: binary64 critical math, deterministic ordering, no fast-math.
- Ordering/tie handling: deterministic traversal (index/layer/group order) and stable tie-breaks.
- Complexity note: linear in touched tensor elements unless explicitly noted.
- Failure behavior: abort-only under 0.K with deterministic failure records.
- Dependencies: limited to signature inputs + declared operators in section 4.
- Test vectors: covered by VII.B deterministic and stochastic replay tests.

**Operator:** `UML_OS.DifferentialPrivacy.Apply_v3`  
**Category:** Security  
**Signature:** `(gradients, dp_config, t -> noisy_gradients, updated_budget, dp_metrics)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic control path; stochastic only via `GenerateNoise_v1`  
**Definition:** orchestrates validation, config resolution, sensitivity analysis, allocation, clipping, scheduling, projection guard, noise generation, accounting, and cast. `gradients` input is the deterministic per-optimizer-step micro-batch gradient sequence (not a pre-aggregated full-batch gradient tensor).  
**Failure behavior:** abort with 0.K codes.

**Operator:** `UML_OS.DifferentialPrivacy.PreValidation_v1`  
**Category:** Security  
**Signature:** `(dp_config, t -> ok)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates DP hyperparameters, mode/accountant compatibility, finite values, and accumulation context.  
**Failure behavior:** `INVALID_DP_CONFIG`.

**Operator:** `UML_OS.DifferentialPrivacy.ConfigResolver_v1`  
**Category:** Security  
**Signature:** `(dp_config, accumulation_context -> resolved_config)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** canonical deterministic merge of defaults, per-module/group overrides, phase overrides, and accumulation context.

**Operator:** `UML_OS.DifferentialPrivacy.SensitivityAnalyzer_v1`  
**Category:** Security  
**Signature:** `(model_layout, norm_history, routing_stats? -> sensitivity_map)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** estimates deterministic per-layer/group/tensor sensitivity for allocation and heterogenous scheduling.

**Operator:** `UML_OS.DifferentialPrivacy.PrivacyBudgetAllocator_v1`  
**Category:** Security  
**Signature:** `(resolved_cfg, sensitivity_map, norm_history -> allocation_map, clip_norm_map)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** allocates privacy budget by selected policy (`uniform`, `layer_wise`, `custom`) and emits deterministic maps.

**Operator:** `UML_OS.DifferentialPrivacy.Clip_v1`  
**Category:** Security  
**Signature:** `(gradients, clipping_cfg, max_microbatch -> clipped, norms, clip_stats)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** dispatches clipping strategy (`per_sample`, `ghost`, `per_layer`, `per_group`, `per_tensor`, `hybrid`, `peft_targeted`, `adaptive`) with deterministic microbatching.

**Operator:** `UML_OS.DifferentialPrivacy.FlashEfficientClip_v1`  
**Category:** Security  
**Signature:** `(gradients, clip_norm_map, fused_cfg -> clipped_or_averaged, norms, stats)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** fused memory-efficient clip-and-average path for structured large-model parameter layouts. `fused_cfg` is deterministically derived from `resolved_cfg` (`fused_kernel` settings and clipping mode compatibility). Noise generation is not performed here and remains exclusively in `GenerateNoise_v1`.

**Operator:** `UML_OS.DifferentialPrivacy.PEFTAwareClipHandler_v1`  
**Category:** Security  
**Signature:** `(gradients, trainable_mask, public_modules -> clipped, peft_stats)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** applies clipping/noise accounting only to trainable/private adapters and excludes public modules.

**Operator:** `UML_OS.DifferentialPrivacy.BoundedPrivacyAwareAdaptiveClipNorm_v1`  
**Category:** Security  
**Signature:** `(norm_history_state, norms_t, adaptive_accounting_mode -> clip_norm_t, norm_history_state', delta_epsilon_cost)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** bounded adaptive clip norm with deterministic update:
  - let `hist = append(norm_history_state, norms_t)` and keep the last `W` values (fixed window `W` from config),
  - `m = median(hist)` (stable sort; even-cardinality median is average of two middle values),
  - `mad = median(|hist_i - m|)`,
  - `clip_norm_t = max(lower_bound, m + k_mad * mad)` with fixed config constants `lower_bound` and `k_mad`,
  - `delta_eps = 0.01` per adaptive update (or `0` when strategy is non-adaptive),
  - return updated history state and `delta_eps` for accountant composition.

**Operator:** `UML_OS.DifferentialPrivacy.PrivacyBudgetScheduler_v1`  
**Category:** Security  
**Signature:** `(t, cumulative_epsilon, resolved_cfg, allocation_map, training_phase, effective_batch_size -> sigma_map_t)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** returns heterogeneous `sigma_map_t` using precomputed schedules for target-based modes and deterministic runtime refinement for `step_decay`/`dynamic_projection`.

**Operator:** `UML_OS.DifferentialPrivacy.DPScalingLawProjector_v1`  
**Category:** Security  
**Signature:** `(sigma_map_t, remaining_steps, model_scale, accountant_hint -> projected_epsilon, confidence)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** projects long-horizon privacy trajectory for proactive safety control (heuristic only). It does not replace formal accounting; compliance and abort decisions are based only on `Accountant.Update_v1`.

**Operator:** `UML_OS.DifferentialPrivacy.AmplificationByShuffling_v1`  
**Category:** Security  
**Signature:** `(sampling_metadata -> amplification_factor)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** computes deterministic amplification adjustment for `subsampling="SHUFFLE_WITHOUT_REPLACEMENT"` using policy-bound audited constants:
  - `sampling_metadata` canonical schema (normative): `{effective_q: float64, local_epsilon_hint: float64}` encoded as canonical CBOR map.
  - Let `q = sampling_metadata.effective_q` and `eps_local = sampling_metadata.local_epsilon_hint` (both deterministic inputs for this step).
  - Deterministic bound formula (normative default when both values are present):
    - `eps_shuf_bound = log(1 + q*q*(exp(eps_local) - 1))`
    - `amplification_factor = min(1.0, eps_shuf_bound / max(eps_local, 1e-18))`
  - Conservative fallback:
    - if required inputs are absent, non-finite, or out of range, set `amplification_factor = 1.0` (no amplification credit).
  - Policy override:
    - if an audited policy artifact declares a stricter fixed factor `f`, use `min(amplification_factor, f)` deterministically.

**Operator:** `UML_OS.DifferentialPrivacy.GenerateNoise_v1`  
**Category:** Security  
**Signature:** `(shape, stddev_map_t, rng_dp_state, compression_cfg? -> noise, rng_dp_state')`  
**Purity class:** STATEFUL  
**Determinism:** stochastic (bitwise-replayable sample stream under replay contract with fixed seed/offset/profile)  
**Definition:** isotropic/heterogeneous Gaussian generation with exact RNG offset accounting; consumes per-group standard deviations from `stddev_map_t`; applies variance-aware compression adjustments if configured.

**Operator:** `UML_OS.DifferentialPrivacy.Accountant.Update_v1`  
**Category:** Security  
**Signature:** `(accountant_type, state, sigma_map, sampling_rate, t, delta, subsampling, amplification?, delta_eps? -> epsilon_t, state')`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** dispatcher for heterogeneous composition in PLD default path and fallback accountants; forwards `subsampling` and optional `amplification_factor`/`delta_eps` to the selected accountant and composes deterministically.

---

**Operator:** `UML_OS.DifferentialPrivacy.ClipPerSample_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(per_sample_grads, clip_norm -> clipped_grads, norms)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Deterministically clips each sample gradient to the declared norm bound.

**Operator:** `UML_OS.DifferentialPrivacy.GhostClipPerSample_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(model, batch, clip_norm -> clipped_grads, norms)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** Computes per-sample clipping via ghost-norm path without full per-sample materialization.

**Operator:** `UML_OS.DifferentialPrivacy.PerLayerClip_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(gradients, per_layer_norms -> clipped_gradients, layer_stats)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Applies deterministic clipping independently per parameter layer/tensor group.

**Operator:** `UML_OS.DifferentialPrivacy.PerGroupClip_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(gradients, per_group_norms, group_map -> clipped_gradients, group_stats)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Clips gradients by configured logical groups in stable registration order.

**Operator:** `UML_OS.DifferentialPrivacy.PerTensorClip_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(gradients, clip_norm_map -> clipped_gradients, tensor_stats)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Clips each trainable tensor with its own deterministic bound.

**Operator:** `UML_OS.DifferentialPrivacy.MomentsAccountant.Update_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(state, sigma_map, sampling_rate, t, delta, subsampling, amplification_factor?, delta_eps? -> epsilon_t, state_next)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Updates privacy budget using moments accountant composition with explicit subsampling mode and optional amplification/adjustment terms.

**Operator:** `UML_OS.DifferentialPrivacy.PLDAccountant.Update_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(state, sigma_map, sampling_rate, t, delta, subsampling, amplification_factor?, delta_eps? -> epsilon_t, state_next)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Updates privacy budget using privacy-loss distribution composition (recommended), applying declared subsampling and optional amplification factor deterministically.

**Operator:** `UML_OS.DifferentialPrivacy.RDPAccountant.Update_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(state, sigma_map, sampling_rate, t, delta, subsampling, amplification_factor?, delta_eps? -> epsilon_t, state_next)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Updates privacy budget via Renyi-DP composition with deterministic order set, using declared subsampling mode and optional amplification factor.

**Operator:** `UML_OS.DifferentialPrivacy.FDPAccountant.Update_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(state, sigma_map, sampling_rate, t, delta, subsampling, amplification_factor?, delta_eps? -> epsilon_t, state_next)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Updates privacy budget via f-DP conversion path for configured compatibility mode.

**Operator:** `UML_OS.DifferentialPrivacy.GDPAccountant.Update_v1`  
**Category:** DifferentialPrivacy  
**Signature:** `(state, sigma_map, sampling_rate, t, delta, subsampling, amplification_factor?, delta_eps? -> epsilon_t, state_next)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Updates privacy budget via Gaussian-DP approximation path for configured compatibility mode.

## 6) Procedure

```text
1. PreValidation_v1(dp_config, t) -> abort on invalid.
1b. Sampling/accountant compatibility check (single deterministic gate):
    - valid iff:
      - (`sampling_mode in {"SHUFFLE_WITHOUT_REPLACEMENT_BLOCK_AFFINE_V1"}` and `subsampling == SHUFFLE_WITHOUT_REPLACEMENT`) OR
      - (`sampling_mode == "SEQUENTIAL_V1"` and `subsampling == NONE`)
    - otherwise emit `INVALID_DP_CONFIG` and abort.
2. resolved_cfg <- ConfigResolver_v1(dp_config, accumulation_context)
2b. sensitivity_map <- SensitivityAnalyzer_v1(...) when allocation/adaptive mode enabled.
3. allocation_map, clip_norm_map <- PrivacyBudgetAllocator_v1(resolved_cfg, sensitivity_map, norm_history)
4. If clipping.strategy == "adaptive":
   (clip_norm_t, clip_norm_state', delta_eps) <- BoundedPrivacyAwareAdaptiveClipNorm_v1(...)
   else delta_eps <- 0.
5. Let `micro_seq` be the deterministic ordered micro-batch sequence for the current optimizer step.
6. Initialize deterministic accumulation buffer for clipped micro-gradients.
7. For each `micro_idx, micro_gradients` in `micro_seq`:
   7a. If fused_kernel == true and per-layer compatible:
          (clipped_micro, norms, clip_stats) <- FlashEfficientClip_v1(micro_gradients, clip_norm_map, fused_cfg)
       else
          (clipped_micro, norms, clip_stats) <- Clip_v1(micro_gradients, resolved_cfg, max_microbatch)
   7b. Accumulate clipped_micro in deterministic order.
8. averaged_clipped <- deterministic_average(accumulated_clipped_micro, gradient_accumulation_steps)
8b. effective_batch_size <- global_batch_size * gradient_accumulation_steps
8c. dataset_cardinality <- sampler_metadata.dataset_cardinality
9. sigma_map <- PrivacyBudgetScheduler_v1(t, cumulative_epsilon, resolved_cfg, allocation_map, training_phase, effective_batch_size)
9b. stddev_map[g] <- sigma_map[g] * clip_norm_map[g] / effective_batch_size   # for each group g
9c. sampling_rate <- effective_batch_size / dataset_cardinality
10. remaining_steps <- (target_steps is defined) ? max(0, target_steps - t) : 0
10a. model_scale_arg <- (resolved_cfg.model_scale is defined) ? resolved_cfg.model_scale : null
10b. projected_epsilon, scaling_conf <- DPScalingLawProjector_v1(sigma_map, remaining_steps, model_scale_arg, accountant)  # pass configured accountant string as accountant_hint
11. If projected_epsilon > target_epsilon: Error.Emit_v1(PRIVACY_BUDGET_EXCEEDED, ...); abort.
12. If subsampling == "SHUFFLE_WITHOUT_REPLACEMENT":
      sampling_metadata <- {effective_q: sampling_rate, local_epsilon_hint: cumulative_epsilon}
      amplification_factor <- AmplificationByShuffling_v1(sampling_metadata)
13. (noise_step, rng_dp_state') <- GenerateNoise_v1(shape(averaged_clipped), stddev_map, rng_dp_state, noise.compression)
14. noisy_binary64 <- averaged_clipped + noise_step
15. (cumulative_epsilon, accountant_state') <- Accountant.Update_v1(accountant, accountant_state, sigma_map, sampling_rate, t, target_delta, subsampling, amplification_factor, delta_eps)
16. If cumulative_epsilon > target_epsilon + EPS_EQ: Error.Emit_v1(PRIVACY_BUDGET_EXCEEDED, ...); abort.
17. noisy_gradients <- cast(noisy_binary64, manifest.compute_dtype)
18. Accountant step semantics:
    - `accountant_granularity == PER_STEP`; `t` advances by 1 per optimizer step.
19. emit dp_metrics (`gradient_snr`, `fairness_clip_ratio`, `scaling_law_confidence`, `peft_noise_reduction_factor`, `effective_heterogeneous_multiplier`) and return.
```

---

## 7) Trace & Metrics

### Logging rule
Each DP step emits deterministic trace fields from section 7, including replay token contribution and budget transition.

### Trace schema (minimum required)
- `run_header`: `dp_mode`, `accountant`, `clipping_strategy`, `subsampling`, `sampling_mode`, `sampler_config_hash`, `parallelism.type`, `noise_seed_per_step`, `privacy_allocation_mode`, `fused_kernel`, `safety_budget_reserve`
- `iter`: `t`, `clip_fraction`, `group_clip_fraction`, `noise_scale_sigma`, `effective_noise_multiplier`, `effective_heterogeneous_multiplier`, `effective_accumulation_factor`, `cumulative_epsilon_before`, `cumulative_epsilon_after`, `projected_final_epsilon`, `norm_p50`, `norm_p95`, `norm_max`, `gradient_snr`, `fairness_clip_ratio`, `scaling_law_confidence`, `peft_noise_reduction_factor`, `accountant_type_used`, `pld_epsilon_tight` (if available), `dp_replay_t`
- `run_end`: final epsilon, budget status, accountant summary hash

### Metric schema
- `clip_fraction`, `group_clip_fraction`
- `noise_scale_sigma`, `effective_noise_multiplier`, `effective_heterogeneous_multiplier`
- `effective_accumulation_factor`
- `cumulative_epsilon`, `privacy_budget_remaining`, `projected_final_epsilon`
- Projection semantics: `projected_final_epsilon` is advisory only; authoritative privacy budget is accountant-computed `cumulative_epsilon`.
- `norm_p50`, `norm_p95`, `norm_max`
- `gradient_snr`, `fairness_clip_ratio`, `scaling_law_confidence`, `peft_noise_reduction_factor`
- `accountant_type_used`, `pld_epsilon_tight`
- `privacy_allocation_mode`

### Comparability guarantee
- E0 comparability requires identical clipping/accounting/scheduler traces and replay tokens.
- E2 comparability applies to final noisy gradients under identical stochastic contracts.

---

## 8) Validation

#### VII.A Lint rules (mandatory)
Passes all mandatory lint rules: symbol completeness, no hidden globals, total state updates, explicit stochasticity, deterministic ordering, trace compliance, typed outputs, and deterministic failure semantics.

#### VII.B Operator test vectors (mandatory)
- Deterministic path: DP disabled returns identity gradients and unchanged budget.
- Deterministic path: fixed synthetic gradients verify clipping scales, per-group/per-tensor allocations, and accountant increments in binary64.
- Accumulation path: clipping is per-micro-batch; budget update and noise RNG consumption occur once per optimizer step.
- Heterogeneous path: sigma-map composition matches reference PLD composition.
- Stochastic path: fixed seed reproduces identical RNG offsets, replay tokens, and accountant trajectory.

#### VII.C Golden traces (mandatory)
- Golden runs for `pld`, `moments`, `rdp` (and fallback accountants where configured).
- Golden scenarios for per-group/per-tensor clipping, accumulation, fused kernel, dynamic scheduler, PEFT-targeted clipping, and scaling-law projection.
- PLD must be no looser than moments under matched settings.
- Safety-reserve warning and budget exhaustion must trigger deterministic records.

---

## 9) Refactor & Equivalence

#### VIII.A Equivalence levels
- E0: exact clipping scales, sigma-map schedule, accountant outputs, and trace fields
- E1: metric-equivalent privacy/utility curve within declared tolerances
- E2: distribution-equivalent stochastic gradients under same RNG policy

Required for changes:
- accountant/clipping/scheduler/allocation semantics: E0 on deterministic path
- noise sampler internal optimization/compression: E2 minimum

#### VIII.B Allowed refactor categories
- accountant numeric stabilization
- clip kernel vectorization/fusion preserving ordering
- scheduler optimization preserving mode semantics
- operator replacement via version bump + manifest update

#### VIII.C Equivalence test procedure (mandatory)
- 10 seeds per scenario
- Compare epsilon trajectory, sigma-map trajectory, clip/allocation stats, projected epsilon, and noisy distribution diagnostics (KS test, alpha=0.01)
- Verify failure-path equivalence for budget overflow and accountant divergence

---

## 10) Checkpoint/Restore

### Checkpoint contents
- `cumulative_epsilon_t`
- `accountant_state_t`
- `dp_accountant_state_hash = SHA-256(CBOR_CANONICAL(accountant_state_t))` (normative cross-contract identifier)
- accountant internals: PLD/RDP support grid or order set, accumulated privacy state tables/log-MGFs, conversion cache
- `rng_dp_state_t` / offset
- `clip_norm_state_t` (if adaptive)
- `accumulation_state_t`
- `allocation_map_snapshot`, `sigma_schedule_cache`
- `sampling_rate_history_hash_chain`, `sigma_map_history_hash_chain`, `t_micro_counter`
- `per_module_snapshot` (resolved module/group allocation snapshot)
- DP config snapshot (`accountant`, `clipping`, `mode`, `noise_multiplier`, `safety_budget_reserve`, targets)

### Serialization
- deterministic canonical CBOR with fixed field order

### Restore semantics
- Restore under same manifest + seed yields identical post-restore deterministic path (E0 for clipping/accounting).
- Noise outputs remain E2-equivalent under identical RNG replay contract.

FILE: layer2-specs/Evaluation-Harness.md
========================================
# UML_OS Evaluation Harness Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Eval.Harness_v1`  
**Purpose (1 sentence):** Define deterministic safety/bias/robustness evaluation runs and evidence bundles linked to registry/deployment policy gates.  
**Spec Version:** `UML_OS.Eval.Harness_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Evaluation governance and evidence generation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Eval.Harness_v1`
- **Purpose (1 sentence):** Replayable evaluation evidence contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize unsafe/unvetted deployments.
### 0.B Reproducibility Contract
- Replayable given `(eval_manifest_hash, dataset_snapshot_id, determinism_tier)`.
### 0.C Numeric Policy
- Metrics in binary64 with explicit thresholds.
### 0.D Ordering and Tie-Break Policy
- Test case ordering deterministic by case_id.
### 0.E Parallel, Concurrency, and Reduction Policy
- Multi-rank evaluation aggregation deterministic.
### 0.F Environment and Dependency Policy
- Evaluation must declare determinism tier (`E0` or `E1`) and tolerance map.
### 0.G Operator Manifest
- `UML_OS.Eval.RunSuite_v1`
- `UML_OS.Eval.AggregateMetrics_v1`
- `UML_OS.Eval.BuildEvidenceBundle_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Eval.*`
### 0.I Outputs and Metric Schema
- Outputs: `(eval_report, evidence_bundle_ref)`
- Metrics: `safety_score`, `bias_score`, `robustness_score`
### 0.J Spec Lifecycle Governance
- evaluation metric semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- abort on schema mismatch or missing evidence references.
### 0.L Input/Data Provenance
- evaluation must bind `dataset_snapshot_id` and model version hash.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- eval suite definitions and threshold policies.
### I.B Inputs and Hyperparameters
- eval manifest, dataset snapshot, model artifact ref.
### I.C Constraints and Feasible Set
- evidence bundle required for policy-gated promotion.
### I.D Transient Variables
- per-case metrics and aggregated scores.
### I.E Invariants and Assertions
- evidence includes trace root and metrics digest.

### II.F Evidence Bundle (Normative)
- `eval_manifest_hash`
- `dataset_snapshot_id`
- `metrics_digest`
  - `metrics_digest = SHA-256(CBOR_CANONICAL(sorted_metrics))` where `sorted_metrics` is canonical array of `{name, value, unit?}` sorted by `name`.
- `trace_final_hash`
- `determinism_tier`
  - allowed values: `E0 | E1` as defined in `docs/layer2-specs/Replay-Determinism.md`.
  - enforcement rule: `E0` requires bitwise equality for designated critical outputs; `E1` uses tolerance-based comparators from the active determinism profile/eval config.
  - critical-output source of truth: designated critical outputs are those marked `E0` by the active determinism profile/class map for the evaluation suite.
- `replay_token`
- `aggregation_policy` schema (normative):
  - map `metric_name -> {agg: enum("mean","sum","min","max","quantile"), quantile_p?:float64}`.
  - quantile rule (normative): when `agg="quantile"`, compute nearest-rank quantile on ascending sorted values with index `k = floor(p * (n-1))` (0-based), value=`sorted[k]`.
- `evidence_bundle_ref` points to canonical CBOR payload:
  - `{eval_manifest_hash, dataset_snapshot_id, metrics_digest, trace_final_hash, determinism_tier, replay_token, eval_report_hash}`.
  - `eval_report_hash = SHA-256(CBOR_CANONICAL(eval_report))`, where `eval_report` is the output of `AggregateMetrics_v1`.

---
## 3) Initialization
1. Validate eval manifest and dataset snapshot.
2. Load model artifact and determinism profile.
3. Initialize evaluation run context.

---
## 4) Operator Manifest
- `UML_OS.Eval.RunSuite_v1`
- `UML_OS.Eval.AggregateMetrics_v1`
- `UML_OS.Eval.BuildEvidenceBundle_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Eval.RunSuite_v1`  
**Category:** Governance  
**Signature:** `(eval_manifest, model_ref, dataset_snapshot_ref -> suite_run_report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** executes the declared evaluation suite in deterministic case order and emits per-case results.

**Operator:** `UML_OS.Eval.AggregateMetrics_v1`  
**Category:** Governance  
**Signature:** `(suite_run_report, aggregation_policy -> eval_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** aggregates per-case metrics into canonical summary outputs and threshold verdicts.

**Operator:** `UML_OS.Eval.BuildEvidenceBundle_v1`  
**Category:** Governance  
**Signature:** `(eval_report, trace_ref, dataset_snapshot_ref -> evidence_bundle_ref)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** builds content-addressed evidence bundle for downstream policy gates, with `trace_final_hash` computed from the actual evaluation trace referenced by `trace_ref`.

---
## 6) Procedure
```text
1. RunSuite_v1
2. AggregateMetrics_v1
3. BuildEvidenceBundle_v1
4. Return eval_report + evidence_bundle_ref
```

---
## 7) Trace & Metrics
### Logging rule
- evaluation events emit deterministic suite/case metrics.
### Trace schema
- `run_header`: eval_manifest_hash, dataset_snapshot_id
- `iter`: case_id, metrics, status
- `run_end`: metrics_digest, evidence_bundle_ref
### Metric schema
- safety/bias/robustness metrics + threshold verdicts.
### Comparability guarantee
- comparable iff same manifest, snapshot, determinism tier, and thresholds.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- evidence completeness and replay linkage.
#### VII.B Operator test vectors (mandatory)
- deterministic evaluation on fixed datasets and tolerance-tier tests.
#### VII.C Golden traces (mandatory)
- golden evidence bundle digests.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for evidence bundle and pass/fail verdict on frozen inputs.
#### VIII.B Allowed refactor categories
- suite execution optimization preserving metrics/verdicts.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare of metrics digest + verdict.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- evaluation cursor and partial metrics state.
### Serialization
- deterministic CBOR.
### Restore semantics
- resumed evaluation yields identical evidence bundle for same inputs.

FILE: layer2-specs/Execution-Certificate.md
===========================================
# UML_OS Execution Certificate Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Certificate.ExecutionCertificate_v1`  
**Purpose (1 sentence):** Define a signed proof-carrying execution certificate that gates registry, deployment, and audit workflows.  
**Spec Version:** `UML_OS.Certificate.ExecutionCertificate_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Verifiable execution provenance and policy gating.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Certificate.ExecutionCertificate_v1`
- **Purpose (1 sentence):** Kernel-issued execution proof contract.
- **Spec Version:** `UML_OS.Certificate.ExecutionCertificate_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Signed execution evidence.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize unverifiable releases and non-auditable promotions.
### 0.B Reproducibility Contract
- Replayable given `(manifest_hash, trace_final_hash, checkpoint_hash, determinism_profile_hash, policy_bundle_hash)`.
### 0.C Numeric Policy
- Hashes/signatures exact bytes; no tolerance path.
### 0.D Ordering and Tie-Break Policy
- Certificate fields serialized in canonical key order.
### 0.E Parallel, Concurrency, and Reduction Policy
- One certificate per run_id; promotion checks deterministic across replicas.
### 0.F Environment and Dependency Policy
- `trust_mode: "SOFTWARE_ONLY" | "ATTESTED"` (default `SOFTWARE_ONLY`).
### 0.G Operator Manifest
- `UML_OS.Certificate.Build_v1`
- `UML_OS.Certificate.Sign_v1`
- `UML_OS.Certificate.Verify_v1`
- `UML_OS.Certificate.EvidenceValidate_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Certificate.*` operators are global governance operators.
### 0.I Outputs and Metric Schema
- Outputs: `(execution_certificate, verification_report)`
- Metrics: `certificate_valid`, `evidence_link_coverage`
- Completion status: `success | failed`
### 0.J Spec Lifecycle Governance
- Field additions are MINOR; required-field removals/changes are MAJOR.
### 0.K Failure and Error Semantics
- Abort on invalid signature/evidence mismatch.
### 0.L Input/Data Provenance
- Certificate must bind manifest, trace, checkpoint, sampler, DP, TMMU, backend, and attestation evidence.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- certificate registry and trust roots.
### I.B Inputs and Hyperparameters
- `tenant_id`, `run_id`, `replay_token`, `manifest_hash`, `trace_final_hash`, `checkpoint_hash`, `policy_bundle_hash`, `security_policy_hash?`, `authz_policy_hash?`, `monitor_policy_hash?`, `dp_policy_hash?`, `redaction_policy_hash?`, `dependencies_lock_hash`, `determinism_profile_hash`, `operator_contracts_root_hash`, `ir_hash`, `lineage_root_hash`, `dp_accountant_state_hash?`, `sampler_config_hash`, `data_access_plan_hash`, `dataset_snapshot_id`, `tmmu_plan_hash`, `backend_binary_hash`, `lockfile_hash`, `toolchain_hash`, `attestation_bundle_hash?`, `attestation_quote_hash?`, `redaction_key_id?`.
### I.C Constraints and Feasible Set
- Registry/deploy actions are invalid without a valid certificate.
### I.D Transient Variables
- evidence bundle hash, signature payload, verification diagnostics.
### I.E Invariants and Assertions
- One certificate signs one immutable evidence tuple.

### II.F ExecutionCertificate Structure (Normative)
- Canonical object:
  - `signed_payload` (canonical CBOR; this exact payload is signed)
  - `unsigned_metadata` (not signed; informational only)
- `signed_payload` field set is fixed by this section; no additional implementation-specific fields are allowed in signed bytes.
- policy-bundle consistency rule:
  - if individual policy hashes are present (`security/authz/monitor/dp/redaction`), they MUST match the decomposition of `policy_bundle_hash` under `policy_bundle_v1`; mismatch is deterministic verification failure.
- Dependency identity semantics:
  - `lockfile_hash` = canonical package lock digest (`LockfileDigest_v1`).
  - `dependencies_lock_hash` = derived environment-bound commitment (`DependenciesLockDigest_v1`).
  - `operator_contracts_root_hash` = `operator_registry_root_hash` from `docs/layer1-foundation/Operator-Registry-Schema.md`.
  - `certificate_hash = SHA-256(certificate_cbor)` where `certificate_cbor` is canonical serialized certificate object (signed payload + signature envelope).
- `signed_payload` required fields:
  - `certificate_version:string`
  - `tenant_id:string`
  - `run_id:string`
  - `replay_token:bytes32`
  - `manifest_hash:bytes32`
  - `trace_final_hash:bytes32`
  - `checkpoint_hash:bytes32`
  - `policy_bundle_hash:bytes32`
  - `security_policy_hash?:bytes32`
  - `authz_policy_hash?:bytes32`
  - `monitor_policy_hash?:bytes32`
  - `dp_policy_hash?:bytes32`
  - `policy_gate_hash:bytes32`
    - semantics: hash of the canonical policy-gate evaluation transcript for the certified run context, as defined in `docs/layer2-specs/Monitoring-Policy.md` (section II.G).
  - `authz_decision_hash:bytes32`
    - provenance note: full authorization context (`authz_query_hash`, verdict, reason, granted set) is carried in trace/audit records; certificate stores `authz_decision_hash` for cryptographic cross-linking.
  - `dependencies_lock_hash:bytes32`
  - `lockfile_hash:bytes32`
  - `toolchain_hash:bytes32`
  - `determinism_profile_hash:bytes32`
  - `operator_contracts_root_hash:bytes32`
  - `ir_hash:bytes32`
  - `lineage_root_hash:bytes32`
  - `redaction_policy_hash?:bytes32`
  - `redaction_key_id?:string`
  - `sampler_config_hash:bytes32`
  - `data_access_plan_hash:bytes32`
  - `dataset_snapshot_id:string`
  - `tmmu_plan_hash:bytes32`
  - `backend_binary_hash:bytes32`
  - `dp_epsilon?:float64`
  - `dp_delta?:float64`
  - `dp_accountant_state_hash?:bytes32` (if DP enabled; equals `SHA-256(CBOR_CANONICAL(accountant_state_t))` from `docs/layer2-specs/DifferentialPrivacy-Apply.md`)
  - `attestation_quote_hash?:bytes32` (required in `ATTESTED` mode)
  - `attestation_bundle_hash?:bytes32` (required in `ATTESTED` mode)
  - `trust_store_hash:bytes32`
  - `key_id:string`
  - `signature_algorithm:string` (e.g., `"ed25519"`)
  - `revocation_bundle_hash:bytes32`
  - `verification_time_utc:string` (required when online revocation/attestation checks are verdict-affecting)
  - `valid_until_utc:string` (certificate expiry upper bound for verifier acceptance)
  - `determinism_conformance_suite_id?:bytes32`
  - `step_start:uint64`
  - `step_end:uint64`
  - semantics: `step_start`/`step_end` are the inclusive first/last step indices covered by this certificate; final run certificate covers the full run interval.
  - zero-step convention: for runs that execute zero steps, set `step_start=0` and `step_end=0`.
- `unsigned_metadata` optional fields:
  - `wall_time_start_utc:string`
  - `wall_time_end_utc:string`
  - operational notes/audit pointers
- Envelope:
  - `signature:bytes64`
- Signature scheme (normative):
  - canonical payload serialization: canonical CBOR of `signed_payload`
  - signature algorithm: indicated by `signed_payload.signature_algorithm`; current required value is `"ed25519"`
  - Ed25519 implementation MUST follow RFC 8032 deterministic signing behavior (no external nonce randomness).
- Trust/revocation commitment definitions:
  - `trust_store_hash = SHA-256(CBOR_CANONICAL(trust_store_bundle))`, where `trust_store_bundle` is the canonical root/intermediate key set used for verification.
  - `revocation_bundle_hash = SHA-256(CBOR_CANONICAL(revocation_bundle))`, where `revocation_bundle` is the canonical CRL/OCSP capture (online) or pinned offline revocation set.
  - Normative source definitions are aligned with `docs/layer2-specs/Security-Compliance-Profile.md`.
  - Time-sensitive verification checks MUST use signed `verification_time_utc` as the evaluation time anchor (not verifier wall-clock time).
  - Timestamp canonical format (normative): UTC ISO 8601 without fractional seconds, exactly `YYYY-MM-DDTHH:MM:SSZ` (example: `2026-02-20T15:04:05Z`) for `verification_time_utc` and `valid_until_utc`.
  - `key_id` MUST be globally unique within trust-store scope and map to exactly one public key at verification time.

---
## 3) Initialization
1. Load trust mode and signing policy.
2. Validate required evidence hashes.
3. Build canonical signing payload.

---
## 4) Operator Manifest
- `UML_OS.Certificate.Build_v1`
- `UML_OS.Certificate.Sign_v1`
- `UML_OS.Certificate.Verify_v1`
- `UML_OS.Certificate.EvidenceValidate_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
External operator reference: `UML_OS.Error.Emit_v1` is defined in `docs/layer1-foundation/Error-Codes.md`.

**Operator:** `UML_OS.Certificate.Build_v1`  
**Category:** Security  
**Signature:** `(evidence_bundle -> certificate_payload)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** canonical payload construction from evidence tuple.

**Operator:** `UML_OS.Certificate.Sign_v1`  
**Category:** Security  
**Signature:** `(certificate_payload, signing_key_ref -> execution_certificate)`  
**Purity class:** IO  
**Determinism:** deterministic payload + deterministic signature algorithm policy  
**Definition:** signs canonical CBOR bytes of `signed_payload` only; `unsigned_metadata` is excluded. In `ATTESTED` mode key release requires attestation policy pass. `signing_key_ref` may resolve to HSM/KMS key material via daemon key broker; signer MUST enforce deterministic algorithm behavior for the selected `signature_algorithm`.

**Operator:** `UML_OS.Certificate.Verify_v1`  
**Category:** Security  
**Signature:** `(execution_certificate, trust_store -> verification_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** verifies signature over `signed_payload`, required field presence, trust chain, signer key validity window, expiry (`verification_time_utc <= valid_until_utc`), and revocation status using `revocation_bundle_hash`.

**Operator:** `UML_OS.Certificate.EvidenceValidate_v1`  
**Category:** Security  
**Signature:** `(manifest, trace, checkpoint, replay_context -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates pre-sign cross-artifact coherence and rejects mismatched evidence.

---
## 6) Procedure
```text
1. Build_v1(evidence_bundle)
2. Sign_v1(payload, signing_key_ref)
3. Verify_v1(certificate, trust_store)
4. EvidenceValidate_v1(manifest, trace, checkpoint, replay_context)
5. Return certificate + report
```

---
## 7) Trace & Metrics
### Logging rule
- Every certificate issuance and verification emits deterministic events.
### Trace schema
- `run_header`: certificate_version, trust_mode
- `iter`: run_id, certificate_hash, verify_status
- `run_end`: evidence_validation_status
### Metric schema
- `certificate_valid`, `evidence_mismatch_count`
### Comparability guarantee
- Comparable iff certificate schema, trust roots, and evidence validation rules are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- required fields complete, signature present, deterministic serialization.
#### VII.B Operator test vectors (mandatory)
- valid signature, invalid signature, missing required evidence, mismatched hash tests.
#### VII.C Golden traces (mandatory)
- golden certificate verification traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for certificate bytes and verification verdict.
#### VIII.B Allowed refactor categories
- cryptographic implementation updates preserving inputs/outputs and trust policy.
#### VIII.C Equivalence test procedure (mandatory)
- byte-level compare + deterministic verdict compare.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- last verified certificate hash and trust context hash.
### Serialization
- deterministic CBOR.
### Restore semantics
- restored verifier produces identical verdict on identical evidence bundle.

---
## 11) Trust Report and Human-Auditable Outputs (Normative)
- `Verify_v1` MUST produce a stable trust report projection in addition to binary verdict:
  - trust roots used,
  - revocation mode/status,
  - attestation verification status,
  - policy gate linkage status,
  - authorization linkage status.
- Trust report identity:
  - `trust_report_hash = SHA-256(CBOR_CANONICAL(trust_report))`.
- Regulated profile certificate evidence MUST include:
  - `chaos_recovery_proof_pack_hash` when recovery scenarios are required by policy.

FILE: layer2-specs/Experiment-Tracking.md
=========================================
# UML_OS Experiment Tracking Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Tracking.ExperimentTracking_v1`  
**Purpose (1 sentence):** Define deterministic run/metric/artifact tracking APIs and storage contracts for lifecycle observability.  
**Spec Version:** `UML_OS.Tracking.ExperimentTracking_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Experiment tracking and artifact lifecycle.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Tracking.ExperimentTracking_v1`
- **Purpose (1 sentence):** Deterministic experiment/run tracking.
- **Spec Version:** `UML_OS.Tracking.ExperimentTracking_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Tracking and artifacts.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize tracking ambiguity and non-replayable run metadata.
### 0.B Reproducibility Contract
- Replayable given `(run_id, tracking_store_hash, artifact_index_hash)`.
### 0.C Numeric Policy
- Metric values in binary64; identifiers exact.
### 0.D Ordering and Tie-Break Policy
- Events ordered by `(t, operator_seq, rank)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Concurrent metric writes merged deterministically.
### 0.F Environment and Dependency Policy
- Tracking backend must expose content-addressable artifact APIs.
### 0.G Operator Manifest
- `UML_OS.Tracking.RunCreate_v1`
- `UML_OS.Tracking.RunStart_v1`
- `UML_OS.Tracking.RunEnd_v1`
- `UML_OS.Tracking.MetricLog_v1`
- `UML_OS.Tracking.ArtifactPut_v1`
- `UML_OS.Tracking.ArtifactGet_v1`
- `UML_OS.Tracking.ArtifactList_v1`
- `UML_OS.Tracking.ArtifactTombstone_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Tracking.*` operators.
### 0.I Outputs and Metric Schema
- Outputs: `(tracking_report, artifact_index_hash)`
- Metrics: `run_count`, `metric_events`, `artifact_count`
- Completion status: `success | failed`
### 0.J Spec Lifecycle Governance
- API/signature changes require MAJOR.
### 0.K Failure and Error Semantics
- Deterministic failures on invalid run/artifact operations.
### 0.L Input/Data Provenance
- Every artifact must include content hash and tenant scope.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- run registry and artifact index.
### I.B Inputs and Hyperparameters
- `tenant_id`, `run_id`, metric payloads, artifact metadata.
### I.C Constraints and Feasible Set
- run_id unique per tenant/project.
### I.D Transient Variables
- write buffers and upload diagnostics.
### I.E Invariants and Assertions
- immutable run lineage; append-only metrics/events.

### II.F CAS Retention and GC Policy (Normative)
- Artifacts and event objects are content-addressed and immutable.
- Retention classes: `golden`, `certified_release`, `experimental`, `ephemeral`.
- Physical deletion is prohibited while object is reachable from active execution certificates or pinned model releases.
- GC must be deterministic mark/sweep over declared roots and emit hash-chained GC audit records.

### II.G Canonical Tracking Record Schemas (Normative)
- `RunRecord` (CBOR map):
  - `tenant_id:string`, `run_id:string`, `replay_token:bytes32`, `manifest_hash:bytes32`, `trace_final_hash:bytes32`, `checkpoint_hash:bytes32`, `execution_certificate_hash:bytes32`, `status:string`, `created_at:string`, `ended_at?:string`.
- `MetricRecord` (CBOR map):
  - `tenant_id:string`, `run_id:string`, `metric_name:string`, `metric_value:float64`, `metric_step:uint64`, `aggregation:enum(raw|sum|mean|min|max|quantile)`, `quantile_p?:float64`, `window_id?:string`, `recorded_at:string`.
  - semantics: each metric record stores one scalar observation; `aggregation` denotes producer-side semantic label and does not trigger query-time aggregation by itself.
- `ArtifactRecord` (CBOR map):
  - `tenant_id:string`, `run_id:string`, `artifact_id:string`, `artifact_digest:bytes32`, `artifact_size_bytes:uint64`, `storage_locator:string`, `artifact_class:string`, `created_at:string`, `tombstoned_at?:string`, `tombstone_reason?:string`.
- Type alias note: `digest_ref` (when used externally) resolves to `bytes32` in this contract version.
- Record hash rule:
  - `record_hash = SHA-256(CBOR_CANONICAL(record_map))`.
  - For `MetricRecord`, the canonical `record_map` used for hashing omits `recorded_at`; `recorded_at` remains stored metadata for human/audit readability only.

### II.H Tracking Gate Binding (Normative)
- Any tracking record used by policy gates must be hash-addressed.
- If a gate decision depends on tracking evidence, the decision transcript must include the relevant `record_hash` values and bind them through `policy_gate_hash`.
- For regulated/confidential modes, retention rules must preserve all gate-referenced records until retention expiry.

### II.I Artifact and Index Commitments (Normative)
- `artifact_id = SHA-256(artifact_bytes)` for raw artifacts; when metadata must be committed, use `SHA-256(CBOR_CANONICAL(["artifact_v1", artifact_bytes_hash, metadata_hash]))`.
- `artifact_index_hash` is computed as:
  - `metadata_hash_i = SHA-256(CBOR_CANONICAL(artifact_metadata_i))`, where `artifact_metadata_i` is the canonical metadata map stored for artifact `i`.
  - `artifact_leaf_i = SHA-256(CBOR_CANONICAL(["artifact_index_leaf_v1", artifact_id_i, metadata_hash_i, status_i]))`,
  - sorted by `artifact_id`,
  - Merkle odd-leaf rule duplicates the last leaf.
- Idempotency rule: repeated `ArtifactPut_v1` with identical `(run_id, artifact_id)` must return the existing record deterministically.
- `run_record_hash = SHA-256(CBOR_CANONICAL(RunRecord))`.
  - mutability note: `RunRecord` is mutable until `RunEnd_v1` finalizes terminal fields; `run_record_hash` is final only after run end, and pre-final uses are undefined.
- `tracking_store_hash` definition (normative):
  - `tracking_store_hash = SHA-256(CBOR_CANONICAL(["tracking_store_v1", run_record_hash, metric_stream_hash, artifact_index_hash]))`,
  - `metric_stream_hash` is computed as a deterministic hash-chain over `MetricRecord` hashes sorted by `(metric_step, metric_name, record_hash)`:
    - `h_0 = SHA-256(CBOR_CANONICAL(["metric_chain_v1"]))`,
    - for each sorted record hash `record_hash_i`: `h_i = SHA-256(CBOR_CANONICAL(["metric_chain_v1", h_{i-1}, record_hash_i]))`,
    - final `metric_stream_hash = h_n`.
  - `recorded_at` is informational metadata only and MUST NOT affect deterministic ordering/hash commitments.

---
## 3) Initialization
1. Initialize tracking store bindings.
2. Validate tenant/project namespace.
3. Initialize run/event streams.

---
## 4) Operator Manifest
- `UML_OS.Tracking.RunCreate_v1`
- `UML_OS.Tracking.RunStart_v1`
- `UML_OS.Tracking.RunEnd_v1`
- `UML_OS.Tracking.MetricLog_v1`
- `UML_OS.Tracking.ArtifactPut_v1`
- `UML_OS.Tracking.ArtifactGet_v1`
- `UML_OS.Tracking.ArtifactList_v1`
- `UML_OS.Tracking.ArtifactTombstone_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
External operator reference: `UML_OS.Error.Emit_v1` is defined in `docs/layer1-foundation/Error-Codes.md`.

**Operator:** `UML_OS.Tracking.RunCreate_v1`  
**Category:** IO  
**Signature:** `(tenant_id, run_manifest -> run_id)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** creates immutable run metadata anchor with placeholder terminal fields (`trace_final_hash`, `ended_at`) unset.

**Operator:** `UML_OS.Tracking.RunStart_v1`  
**Category:** IO  
**Signature:** `(run_id, start_metadata -> ok)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** appends deterministic run-start event and transitions run lifecycle to ACTIVE.

**Operator:** `UML_OS.Tracking.RunEnd_v1`  
**Category:** IO  
**Signature:** `(run_id, end_metadata -> ok)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** appends deterministic run-end event, atomically sets terminal run fields (`trace_final_hash`, `ended_at`, status), and seals the run event stream.

**Operator:** `UML_OS.Tracking.MetricLog_v1`  
**Category:** IO  
**Signature:** `(run_id, metric_event -> ok)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** appends typed metric event.

**Operator:** `UML_OS.Tracking.ArtifactPut_v1`  
**Category:** IO  
**Signature:** `(run_id, artifact_bytes, metadata -> artifact_id)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** stores content-addressed artifact and updates index.

**Operator:** `UML_OS.Tracking.ArtifactGet_v1`  
**Category:** IO  
**Signature:** `(run_id, artifact_id -> artifact_bytes, metadata)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** resolves artifact by content-addressed identifier and returns immutable bytes + metadata.

**Operator:** `UML_OS.Tracking.ArtifactList_v1`  
**Category:** IO  
**Signature:** `(run_id, filter? -> artifact_index)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** lists artifacts in canonical order (artifact_id ascending) with deterministic filtering.

**Operator:** `UML_OS.Tracking.ArtifactTombstone_v1`
**Category:** IO
**Signature:** `(run_id, artifact_id, reason -> tombstone_id)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** appends immutable tombstone metadata; physical deletion is deferred to retention policy. Tombstoned artifacts remain retrievable by `artifact_id` for audit/replay, and are marked as deleted in listing views.
`reason` is required and MUST be a valid UTF-8 string; it MUST be persisted into `tombstone_reason` and therefore committed by `record_hash`.

---
## 6) Procedure
```text
1. RunCreate_v1
2. RunStart_v1
3. MetricLog_v1 / ArtifactPut_v1 repeated
4. ArtifactTombstone_v1 optional
5. RunEnd_v1
6. Return tracking_report
```

---
## 7) Trace & Metrics
### Logging rule
- Tracking operations emit deterministic run/metric/artifact events.
### Trace schema
- `run_header`: tenant_id, run_id
- `iter`: event_type, key, status
- `run_end`: artifact_index_hash
### Metric schema
- `metric_events`, `artifact_count`
### Comparability guarantee
- Comparable iff schemas, run IDs, and content hashes are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- signature-locked APIs, typed events, hash-addressed artifacts.
#### VII.B Operator test vectors (mandatory)
- create/start/end flow, invalid state transitions, artifact hash mismatch.
#### VII.C Golden traces (mandatory)
- golden run-tracking traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for run/artifact identifiers and trace outputs.
#### VIII.B Allowed refactor categories
- storage backend optimization preserving IDs and hashes.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare of run metadata + artifact index hash.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- run cursor and artifact index watermark.
### Serialization
- deterministic CBOR.
### Restore semantics
- resumed tracking yields identical IDs/order under same inputs.

FILE: layer2-specs/Model-Registry.md
====================================
# UML_OS Model Registry Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Registry.ModelRegistry_v1`  
**Purpose (1 sentence):** Define deterministic model/version registry and approval gates bound to execution evidence.  
**Spec Version:** `UML_OS.Registry.ModelRegistry_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Model governance and promotion workflows.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Registry.ModelRegistry_v1`
- **Purpose (1 sentence):** Evidence-gated model lifecycle governance.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize ungoverned model promotions.
### 0.B Reproducibility Contract
- Replayable given `(model_id, model_version_id, execution_certificate_hash)`.
### 0.C Numeric Policy
- Version counters exact.
### 0.D Ordering and Tie-Break Policy
- Stage transitions follow deterministic policy graph.
### 0.E Parallel, Concurrency, and Reduction Policy
- Concurrent approvals reduced by deterministic policy precedence.
### 0.F Environment and Dependency Policy
- Registry write requires valid `ExecutionCertificate`.
### 0.G Operator Manifest
- `UML_OS.Registry.ModelCreate_v1`
- `UML_OS.Registry.VersionCreate_v1`
- `UML_OS.Registry.StageTransition_v1`
- `UML_OS.Registry.PolicyGateEvaluate_v1`
- `UML_OS.Registry.ApprovalRecord_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Registry.*` namespace.
### 0.I Outputs and Metric Schema
- Outputs: `(registry_event, gate_report)`
- Metrics: `versions_created`, `stage_transitions`, `gate_failures`
### 0.J Spec Lifecycle Governance
- Governance semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- Abort on missing/invalid evidence bundle.
### 0.L Input/Data Provenance
- Every version must bind evidence refs: replay token, trace root, checkpoint hash.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- model/version registry, approvals, policy gates.
### I.B Inputs and Hyperparameters
- `Model`, `ModelVersion`, `Stage`, `Approval`, `PolicyGate`, `SBOMRef`, `EvidenceBundleRef`.
### I.C Constraints and Feasible Set
- Stage transition invalid without policy gate pass.
### I.D Transient Variables
- gate diagnostics and approval context.
### I.E Invariants and Assertions
- immutable model version payload; append-only approvals.

### II.F CAS Retention and Reachability (Normative)
- Registry objects must reference immutable content-addressed artifacts.
- Reachability roots include:
  - active model versions in non-terminal retention classes,
  - execution certificates bound to promoted versions.
- GC safety invariant: objects reachable from active roots cannot be deleted; tombstoning is append-only and auditable.

### II.G Registry State Machine (Normative)
- States:
  - model version lifecycle: `CREATED -> STAGED -> APPROVED -> DEPLOYED | REJECTED | ARCHIVED`.
- Legal transitions:
  - `CREATED->STAGED`, `STAGED->APPROVED`, `APPROVED->DEPLOYED`,
  - `STAGED->REJECTED`, `APPROVED->ARCHIVED`, `DEPLOYED->ARCHIVED`.
- Transition invariants:
  - each transition requires valid `evidence_bundle_ref`,
  - transition writes are append-only and keyed by monotone `transition_seq`,
  - retries use deterministic `idempotency_key` and must not duplicate state changes.
  - `idempotency_key = SHA-256(CBOR_CANONICAL([tenant_id, model_id, model_version_id, transition_seq, from_stage, to_stage]))`.

### II.H Canonical Registry Record Schemas (Normative)
- `ModelRecord` (CBOR map):
  - `tenant_id:string`, `model_id:string`, `name:string`, `created_by:string`, `created_at:string`, `model_metadata_hash:bytes32`.
- `ModelVersionRecord` (CBOR map):
  - `tenant_id:string`, `model_id:string`, `model_version_id:string`, `checkpoint_hash:bytes32`, `execution_certificate_hash:bytes32`, `manifest_hash:bytes32`, `lineage_root_hash:bytes32`, `artifact_index_hash:bytes32`, `created_at:string`.
- `StageTransitionRecord` (CBOR map):
  - `tenant_id:string`, `model_id:string`, `model_version_id:string`, `transition_seq:uint64`, `from_stage:string`, `to_stage:string`, `policy_gate_hash:bytes32`, `authz_decision_hash:bytes32`, `decision_time:string`, `idempotency_key:bytes32`, `decision_reason_code:string`.
- Record hash rule:
  - `record_hash = SHA-256(CBOR_CANONICAL(record_map))`.

---
## 3) Initialization
1. Load registry schema.
2. Validate RBAC role bindings.
3. Load policy-gate definitions.

---
## 4) Operator Manifest
- `UML_OS.Registry.ModelCreate_v1`
- `UML_OS.Registry.VersionCreate_v1`
- `UML_OS.Registry.StageTransition_v1`
- `UML_OS.Registry.PolicyGateEvaluate_v1`
- `UML_OS.Registry.ApprovalRecord_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
External operator reference: `UML_OS.Error.Emit_v1` in `docs/layer1-foundation/Error-Codes.md`.

**Operator:** `UML_OS.Registry.ModelCreate_v1`  
**Category:** Governance  
**Signature:** `(tenant_id, model_spec -> model_id)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** creates immutable model namespace anchor and canonical metadata record.

**Operator:** `UML_OS.Registry.VersionCreate_v1`  
**Category:** Governance  
**Signature:** `(model_id, artifact_ref, evidence_bundle_ref -> model_version_id)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** creates immutable model version only if evidence bundle is valid.
`evidence_bundle_ref` is a `bytes32` hash of the canonical evidence bundle used for version admission checks (certificate/evaluation/provenance evidence), encoded via canonical CBOR before hashing.

**Operator:** `UML_OS.Registry.PolicyGateEvaluate_v1`  
**Category:** Governance  
**Signature:** `(model_version_id, policy_set -> gate_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** evaluates policy gates including certificate/evidence coherence.

**Operator:** `UML_OS.Registry.ApprovalRecord_v1`  
**Category:** Governance  
**Signature:** `(model_version_id, approver_principal, decision, decision_reason_code, policy_gate_hash -> approval_record_id)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** appends immutable approval decision record with deterministic reason code, explicit `policy_gate_hash`, and authz bindings.

**Operator:** `UML_OS.Registry.StageTransition_v1`  
**Category:** Governance  
**Signature:** `(model_version_id, from_stage, to_stage, policy_gate_hash, authz_decision_hash, approval_record_id -> transition_record)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** performs validated stage transition only after gate pass and verification that `approval_record_id` exists and matches `(model_version_id, to_stage, policy_gate_hash)`.

---
## 6) Procedure
```text
1. ModelCreate_v1
2. VersionCreate_v1
3. PolicyGateEvaluate_v1
4. ApprovalRecord_v1
5. StageTransition_v1
```

---
## 7) Trace & Metrics
### Logging rule
- Every registry mutation emits deterministic governance events.
### Trace schema
- `run_header`: tenant_id, registry_version
- `iter`: model_version_id, action, status
- `run_end`: final_stage
### Metric schema
- `stage_transitions`, `gate_failures`
### Comparability guarantee
- Comparable iff policy set + evidence validation rules are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- no stage transition without valid evidence + gate pass.
#### VII.B Operator test vectors (mandatory)
- valid/invalid certificate; approval role violations; gate failures.
#### VII.C Golden traces (mandatory)
- golden model promotion traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for governance decisions and stage transitions.
#### VIII.B Allowed refactor categories
- registry storage changes preserving policy outcomes.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare of gate reports + transition logs.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- registry index and policy gate state.
### Serialization
- deterministic CBOR.
### Restore semantics
- restored registry yields identical gate decisions for same inputs.

---
## 11) Export Interface Stability and Marketplace Policy (Normative)
- Exported model artifacts (`model.onnx`, `model_card.json`) are treated as versioned compatibility surfaces.
- Model card schema MUST declare explicit version and compatibility window.
- Third-party publishability policy:
  - operator/module listings in marketplace contexts require:
    - conformance evidence bundle,
    - security/compliance profile declaration,
    - registry-root/hash provenance,
    - deprecation/support window declaration.
- Governance reference:
  - `docs/layer4-implementation/Community-Governance-Model.md`.

FILE: layer2-specs/ModelIR-Executor.md
======================================
# Universal Machine Learning Operating System â€” ModelIR Executor
**EQC Compliance:** This specification follows EquationCode (EQC) v1.1 merged single-file format (Option A): 10 top-level sections, global semantics first, operator-owned math, control-flow-only procedure, deterministic contracts, and replayable stochasticity.

**Algorithm:** `UML_OS.Model.ModelIR_Executor_v1`  
**Purpose (1 sentence):** Deterministically execute any valid UML_Model_IR DAG on a contract-validated backend driver using TMMU-managed memory with strict topological ordering, static liveness analysis for slot reuse, **mode-aware forward/reverse scheduling**, and full support for forward/backward/inference passes, guaranteeing E0/E1 reproducibility per declared adapter/hardware tier while scaling to 100 B+ parameter models.  
**Spec Version:** `UML_OS.Model.ModelIR_Executor_v1` | 2026-02-18 | Authors: Olejar Damir (with EQC team improvements)  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Declarative neural-network graph execution with memory isolation and bit-identical reproducibility.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** `UML_OS.Model.ModelIR_Executor_v1`
- **Purpose (1 sentence):** Execute UML_Model_IR DAGs deterministically on validated drivers with TMMU memory management.
- **Spec Version:** `UML_OS.Model.ModelIR_Executor_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Scalable deterministic ML computation graph execution.

### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Not an optimization operator.
- Primary guarantee: deterministic critical-path outputs for identical `(ir_dag, theta, inputs, mode, replay_token, backend_binary_hash, driver_runtime_fingerprint_hash)` under a declared adapter/hardware determinism tier.
- Comparison rule: exact tensor equality on binary64 critical reductions; EPS_EQ tolerance on compute_dtype paths.

### 0.B Reproducibility Contract
- Seed space: `seed âˆˆ {0..2^64-1}` inherited from kernel master RNG (no direct draws in core path).
- PRNG family: Philox4x32-10 (only inside custom operators/driver primitives that declare consumption).
- Randomness locality: strictly inside registered custom operators or backend primitives that explicitly declare RNG consumption through `DispatchPrimitive_v1`.
- Replay guarantee: fully replayable given `(ir_hash, theta_hash, input_hash, mode, replay_token, tmmu_context, backend_binary_hash, driver_runtime_fingerprint_hash)`.
- Replay token contribution: `modelir_replay_t = SHA-256(CBOR_CANONICAL(["modelir_executor_v1", kernel_replay_token, ir_hash, mode, uint64(global_position)]))`.
- Proof-carrying IR fields:
  - `ir_schema_hash`
  - `ir_operator_set_hash`
  - `primitive_semantics_hash_set`
- Determinism tier contract: E0 only within same adapter build + deterministic kernel set + fixed math flags; E1 across broader hardware/driver classes.

### 0.C Numeric Policy
- Critical reductions/gradients/norms/fingerprints: IEEE-754 binary64 with Kahan or pairwise summation in ascending node_id order.
- All other computations: manifest.compute_dtype (float32 default).
- Rounding: round-to-nearest ties-to-even.
- Fast-math: forbidden.
- NaN/Inf policy: inherited from kernel 0.A/0.K (rank as +Inf, abort on critical paths).
- Normalized exponentials: stable log-sum-exp required for softmax/log-probability primitives.
- Approx-equality: `a â‰ˆ b` iff `|a - b| <= EPS_EQ` on non-bitwise paths.

### 0.D Ordering and Tie-Break Policy
- Index base: 0-based.
- Execution order: strict topological order with stable sort by node_id (lowest node_id wins on ties). **For backward mode: reversed topological order (guarantees correct gradient propagation order).**
- Tensor reductions: ascending flat index or node_id order.
- Backward ordering contract: execution follows topological order of the explicit gradient dependency graph (`grad_edges`); plain reverse-forward order is valid only when equivalent to `grad_edges` order.

### 0.E Parallel, Concurrency, and Reduction Policy
- Driver handles intra-op parallelism (must be deterministic per Contract.Validate_v1).
- Inter-node execution: sequential topological order (no concurrent nodes unless driver proves independence under contract).
- Reductions: fixed ascending-index tree order per kernel 0.E.

### 0.F Environment and Dependency Policy
- Requires loaded compliant backend driver (via UML_OS.Backend.LoadDriver_v1) and active TMMU.
- Reference runtime: CPU reference driver for E0 verification.
- Dependencies: UML_Model_IR schema (0.Y of kernel), registered custom operators, TMMU arena.
- **Backward-mode requirement:** ir_dag contains the same nodes as forward but DispatchPrimitive_v1 uses mode="backward" to invoke gradient kernels; execution order must follow explicit gradient dependency order.
- Determinism level: `BITWISE` for critical tensors/fingerprints, `TOLERANCE` for non-critical compute_dtype paths.

### 0.G Operator Manifest
- `UML_OS.Model.ModelIR_Executor_v1`
- `UML_OS.Model.TopoSortNodes_v1`
- `UML_OS.Model.BuildGradDependencyOrder_v1`
- `UML_OS.Model.DispatchPrimitive_v1`
- `UML_OS.Model.CollectGradients_v1`
- `UML_OS.TMMU.PrepareMemory_v2` (includes static liveness + deterministic slot assignment)
- `UML_OS.Fingerprint.StateFingerprint_v1`
- `UML_OS.TMMU.CommitExecution_v1`
- `UML_OS.Contract.Validate_v1`
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- Fully-qualified names: `UML_OS.Model.<Name>_v#`

### 0.I Outputs and Metric Schema
- Declared outputs: `(outputs: tensor_map, grads?: tensor_map, execution_fp, tmmu_state_next, rng_state_next)`
- Minimum metrics: `nodes_executed`, `mode`, `memory_reuse_ratio`, `peak_tmmu_usage`, `execution_fp`
- Completion status: `success | failed` with deterministic reason codes.

### 0.J Spec Lifecycle Governance
- Any change to execution ordering, dispatch semantics, or memory-layout determinism requires MAJOR version bump.
- Performance-only optimizations preserving outputs/trace semantics require MINOR bump.
- Equivalence target: E0 for critical paths and execution trace.

### 0.K Failure and Error Semantics
- Global error model: abort-only
- Failure codes: `INVALID_IR`, `CYCLE_DETECTED`, `SHAPE_MISMATCH`, `PRIMITIVE_UNSUPPORTED`, `TMMU_ALLOCATION_FAILURE`, `CONTRACT_VIOLATION`
- Failure record fields: `t`, `failure_code`, `node_id`, `modelir_replay_t`

### 0.L Input/Data Provenance
- IR must carry canonical `ir_hash`; all input tensors must be TMMU-resident and fingerprinted.

### 0.M Recommended Presets
- `forward_train`: forward pass + activation saving
- `backward_train`: **reverse topological gradient propagation** (reversed execution_order + gradient-kernel dispatch)
- `inference`: forward-only with no grad tracking

---

### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model

### I.A Persistent State
- Executor-local state is stateless per call; mutable tensor residency/state is externalized in `tmmu_context` and returned as `tmmu_state'`.

### I.B Inputs and Hyperparameters
- `ir_dag: UML_Model_IR` (nodes with `node_id`, `instr`, `params`, `inputs`, `shape_in/out`)
- `theta: dict` (parameter tensors)
- `input_data: tensor_map` (for input nodes)
- `mode: "forward" | "backward" | "inference"`
- `loss_outputs: array<(node_id, output_idx)>` (required in backward mode)
- `seed_rule: "UNIT_SCALAR" | "PROVIDED_GRADIENTS"`
- `replay_token: bytes32`
- `tmmu_context`
- `arena_config` (deterministic memory arena configuration passed to TMMU)
- `rng_state` (kernel-provided deterministic RNG stream state)

### I.C Constraints and Feasible Set
- DAG acyclic and shapes statically known/inferable.
- All `instr` supported by driver or registered custom.
- `global_batch_size % world_size == 0` (inherited from kernel).
- **Backward-mode invariant:** every node must have a corresponding gradient implementation in the driver.

### I.D Transient Variables
- `execution_order`, `tensor_map`, `grad_map` (backward only), `rng_state_work`

### I.E Invariants and Assertions
- Topological order respected (forward order for forward/infer; explicit gradient dependency order for backward).
- Every node input available before dispatch.
- All allocated tensors zeroed by TMMU before first write.
- Critical reductions performed in binary64 with fixed order.
- TMMU deterministic virtual addressing (delegated to `docs/layer2-specs/TMMU-Allocation.md` contract).
- Backward adjoint invariants:
  - each differentiable tensor has a declared `grad_slot`,
  - all grad slots are zero-initialized at backward start,
  - terminal loss/output gradient seed follows declared `seed_rule`,
  - multi-parent gradient contributions are accumulated by sorting contributions on `(consumer_node_pos, edge_id)` and reducing in fixed order.

### II.F IR Identity and Hash Binding (Normative)
- `ir_hash` definition:
  - validate `ir_object` against declared IR schema,
  - canonicalize as `ir_cbor = CBOR_CANONICAL(ir_object)`,
  - compute `ir_hash = SHA-256(ir_cbor)`.
- `ir_schema_hash` must be embedded in `ir_object`; therefore `ir_hash` commits both graph content and schema identity.
- Cross-artifact binding rule:
  - execution trace, checkpoint header, and execution certificate must carry the same `ir_hash` for a run.

---

## 3) Initialization

1. `Contract.Validate_v1(ir_dag, driver, mode)`
2. `execution_order â† UML_OS.Model.TopoSortNodes_v1(ir_dag)`
3. **if mode == "backward":**
   - **`backward_order, reverse_equivalent_flag â† UML_OS.Model.BuildGradDependencyOrder_v1(ir_dag, execution_order)`**
   - **if `reverse_equivalent_flag == 1`: `execution_order â† reversed(execution_order)` else `execution_order â† backward_order`**
4. `tensor_map â† UML_OS.TMMU.PrepareMemory_v2(ir_dag, execution_order, mode, replay_token, arena_config)` (static liveness + zeroing + deterministic slot reuse; mode-aware activation saving for backward)

---

## 4) Operator Manifest

Active operators:
- `UML_OS.Model.ModelIR_Executor_v1`
- `UML_OS.Model.TopoSortNodes_v1`
- `UML_OS.Model.BuildGradDependencyOrder_v1`
- `UML_OS.Model.DispatchPrimitive_v1`
- `UML_OS.Model.CollectGradients_v1`
- `UML_OS.TMMU.PrepareMemory_v2`
- `UML_OS.Fingerprint.StateFingerprint_v1`
- `UML_OS.TMMU.CommitExecution_v1`
- `UML_OS.Contract.Validate_v1`
- `UML_OS.Error.Emit_v1`

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

**Operator:** `UML_OS.Model.ModelIR_Executor_v1`  
**Category:** Model  
**Signature:** `(ir_dag, theta, input_data, mode, replay_token, tmmu_context, rng_state â†’ outputs, grads?, execution_fp, tmmu_state_next, rng_state_next)`  
**Purity class:** STATEFUL (TMMU/driver)  
**Determinism:** deterministic  
**Definition:** Executes full pass on UML_Model_IR DAG. Guarantees deterministic layout plans and critical outputs within the declared adapter/hardware determinism tier (E0/E1 contract). **Mode-aware scheduling uses explicit gradient dependency order for backward.**
**Preconditions / Postconditions:** validated IR/driver contract; outputs and optional gradients returned with committed TMMU state.  
**Edge cases:** empty DAG, single-node DAG, backward on non-differentiable nodes.  
**Numerical considerations:** binary64 critical-path reductions with deterministic ordering.  
**Ordering/tie handling:** strict topological order; stable node_id tie-break; backward uses deterministic gradient dependency order (reverse-forward only when proven equivalent).  
**Complexity note:** O(|nodes| + |edges|) dispatch path after initialization.  
**Failure behavior:** abort on 0.K failure codes.  
**Dependencies:** TopoSortNodes_v1, DispatchPrimitive_v1, CollectGradients_v1, PrepareMemory_v2, UML_OS.Fingerprint.StateFingerprint_v1, CommitExecution_v1.  
**Test vectors:** see VII.B tiny DAG forward/backward/inference checks.

**Operator:** `UML_OS.Model.TopoSortNodes_v1`  
**Category:** Model  
**Signature:** `(ir_dag â†’ execution_order: node[])`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Topological sort (Kahn/DFS) with stable tie-break by lowest node_id. Detects cycles. (Reversal for backward performed by caller/executor.)
**Preconditions / Postconditions:** input graph is declared DAG schema; output is deterministic topological ordering.  
**Edge cases:** disconnected DAG components, single node.  
**Numerical considerations:** N/A (graph-only operation).  
**Ordering/tie handling:** stable node_id ascending tie-break.  
**Complexity note:** O(|nodes| + |edges|).  
**Failure behavior:** `CYCLE_DETECTED` abort on non-DAG graph.  
**Dependencies:** IR schema validation.  
**Test vectors:** cycle detection and deterministic ordering checks.

**Operator:** `UML_OS.Model.BuildGradDependencyOrder_v1`
**Category:** Model
**Signature:** `(ir_dag, forward_execution_order -> backward_execution_order: node[], reverse_equivalent_flag: {0,1})`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** Builds a topological order over explicit gradient dependency graph (`grad_edges`, or default reverse forward-order edges when `grad_edges` absent). `reverse_equivalent_flag` is `1` only when `reversed(forward_execution_order)` is a valid topological order for the gradient dependency graph; otherwise `0` and `backward_execution_order` MUST be used.

**Operator:** `UML_OS.Model.DispatchPrimitive_v1`  
**Category:** Model  
**Signature:** `(node, tensor_map, theta, mode, tmmu_context, rng_state -> updated_tensor_map, rng_state_next)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic (driver contract)  
**Definition:** Resolves input handles, dispatches driver primitive for `node.instr` **(fwd or grad variant based on mode)**, writes output to TMMU-allocated slot, validates shapes, and forwards a deterministic RNG sub-stream for primitives/custom ops that declare randomness.
Each primitive MUST declare deterministic RNG consumption (`rng_draws_per_invocation`); if zero, `rng_state_next == rng_state`.
`tmmu_context` is an opaque runtime handle provided by the TMMU layer for deterministic memory access/slot resolution.
**Preconditions / Postconditions:** all input handles exist; output handle written with validated shape/dtype; RNG state advanced only by declared primitive RNG consumption.  
**Edge cases:** unsupported primitive, custom op fallback, zero-size tensors.  
**Numerical considerations:** primitive-specific binary64 critical paths enforced by driver contract.  
**Ordering/tie handling:** follows provided execution order exactly.  
**Complexity note:** primitive-dependent; dispatch overhead O(1) per node.  
**Failure behavior:** `PRIMITIVE_UNSUPPORTED`/`SHAPE_MISMATCH`/`CONTRACT_VIOLATION` abort.  
**Dependencies:** backend driver dispatch table, TMMU handles, kernel RNG ownership contract.  
**Test vectors:** per-primitive deterministic forward/backward outputs.

**Operator:** `UML_OS.Model.CollectGradients_v1`  
**Category:** Model  
**Signature:** `(tensor_map, ir_dag -> grads: tensor_map)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** After backward pass, aggregates all parameter gradients (from dedicated grad slots or accumulated in-place) into a clean grads dict. When multiple contributors exist, accumulation order is deterministic by `producer_node_id` ascending using binary64 compensated summation.
**Preconditions / Postconditions:** backward artifacts present; returned grads aligned to parameter registration order.  
**Edge cases:** sparse gradients, frozen parameters.  
**Numerical considerations:** deterministic accumulation order for merged gradients.  
**Ordering/tie handling:** parameter order from model registration.  
**Complexity note:** O(|theta|).  
**Failure behavior:** abort on missing gradient tensor or dtype mismatch.  
**Dependencies:** IR parameter metadata and tensor map.  
**Test vectors:** gradient extraction on known tiny models.

**Operator:** `UML_OS.TMMU.PrepareMemory_v2`  
**Category:** Memory  
**Signature:** `(ir_dag, execution_order, mode, replay_token, arena_config -> tensor_map)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** Performs static liveness analysis on IR; delegates virtual addressing to the versioned TMMU allocation contract; zeros all tensors; prepares reuse schedule. **Mode-aware: reserves extra slots for activations only when backward is requested.**
**Preconditions / Postconditions:** valid TMMU context and arena config; tensor handles are ready before dispatch.  
**Edge cases:** memory pressure near arena cap.  
**Numerical considerations:** N/A (address arithmetic in integer space).  
**Ordering/tie handling:** deterministic slot assignment order from liveness plan.  
**Complexity note:** O(|nodes| log |nodes|) worst-case for allocation planning.  
**Failure behavior:** abort on allocation failure/alignment violations.  
**Dependencies:** `UML_OS.TMMU` allocation operators and replay token context.  
**Test vectors:** deterministic slot map across repeated runs.

---

**Operator:** `UML_OS.Contract.Validate_v1`  
**Category:** Contract  
**Signature:** `(ir_dag, driver, mode -> contract_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Verifies IR schema, primitive coverage, determinism requirements, and mode constraints before execution.

**Operator:** `UML_OS.Fingerprint.StateFingerprint_v1`  
**Category:** Observability  
**Signature:** `(tensor_map -> execution_fp)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Computes canonical binary64 fingerprint over declared critical tensors using deterministic ordering.

**Operator:** `UML_OS.TMMU.CommitExecution_v1`  
**Category:** Memory  
**Signature:** `(tmmu_context -> tmmu_state_next)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** Finalizes memory barriers/ownership and commits deterministic TMMU state after batch execution.

## 6) Procedure

```text
1. Contract.Validate_v1(ir_dag, driver, mode)
2. execution_order â† TopoSortNodes_v1(ir_dag)
3. if mode == "backward":
       backward_order, reverse_equivalent_flag <- BuildGradDependencyOrder_v1(ir_dag, execution_order)
       if reverse_equivalent_flag == 1:
           execution_order <- reversed(execution_order)
       else:
           execution_order <- backward_order
4. tensor_map â† TMMU.PrepareMemory_v2(ir_dag, execution_order, mode, replay_token, arena_config)  # static liveness + zeroing + slot reuse (mode-aware)

5. rng_state_work <- rng_state
6. for node in execution_order:
       tensor_map, rng_state_work <- DispatchPrimitive_v1(node, tensor_map, theta, mode, tmmu_context, rng_state_work)

7. if mode == "backward":
       grads â† CollectGradients_v1(tensor_map, ir_dag)  # now explicitly defined operator

8. outputs â† extract_output_nodes(tensor_map, ir_dag)
9. execution_fp â† UML_OS.Fingerprint.StateFingerprint_v1(tensor_map)  # critical tensors only
10. TMMU.CommitExecution_v1()  # sync barriers for isolation
11. return outputs, grads?, execution_fp, tmmu_state_next, rng_state_work
```

**Scalability & Algorithmic Guarantees:**
- Time: O(|nodes| + |edges|) per execution after O(|nodes|) liveness prep.
- Memory: O(live set size) via static liveness + deterministic slot reuse (enables 100 B+ models on fixed arena).
- **Backward pass now algorithmically correct** (reverse topological order + mode-aware dispatch).
- Exact bijection with CPU reference driver on critical paths (E0).
- Fully supports streaming/large-batch via TMMU virtual addressing; no O(N) storage beyond live tensors.

---

## 7) Trace & Metrics

### Logging rule
Each invocation emits deterministic node-level trace records in execution order and a final summary record.

### Trace schema (minimum required)
- `run_header`: `ir_hash`, `mode`, `backend_binary_hash`, `driver_runtime_fingerprint_hash`, `tmmu_arena_size`
- `node`: `node_id`, `instr`, `shape`, `dtype`, `dispatch_success`
- `run_end`: `execution_fp`, `memory_peak`, `reuse_ratio`, `nodes_executed`
- critical reductions set (normative minimum): `loss_total`, `grad_norm`, and tensors used by `StateFingerprint_v1`.

### Metric schema
- `nodes_executed`, `memory_reuse_ratio`, `peak_tmmu_usage`, `execution_fp`

### Comparability guarantee
Two executions are comparable iff `ir_hash`, determinism tier, backend/profile hashes, trace schema, and metric schema are identical.

---

## 8) Validation

#### VII.A Lint rules (mandatory)
- DAG acyclicity, shape propagation totality, primitive coverage, topological determinism, TMMU contract adherence, **backward-order correctness**.

#### VII.B Operator test vectors (mandatory)
- Tiny linear/residual/transformer DAGs â†’ exact binary64 match vs reference driver.
- Backward pass gradient verification within EPS_EQ (now tested with explicit reverse ordering).

#### VII.C Golden traces (mandatory)
- Full forward/backward/inference on all kernel presets (ResNet, ViT, GPT) across drivers; E0 critical-path match.

---

## 9) Refactor & Equivalence

#### VIII.A Equivalence levels
- **E0** required for any change affecting critical-path tensors or execution order.
- **E1** allowed for non-critical memory optimizations.

#### VIII.B Allowed refactor categories
- Alternative topological algorithms (must preserve stable node_id order + reverse for backward).
- Advanced static liveness / fusion / **rematerialization heuristics** (via driver contract; preserves E0).
- Kernel-fusion extensions (preserves E0).

#### VIII.C Equivalence test procedure (mandatory)
- 10 seeds Ã— all presets Ã— 3 modes.
- Exact match on gradients/losses/fingerprints in binary64; statistical test on non-critical paths.

---

## 10) Checkpoint/Restore

### Checkpoint contents
- Stateless executor; relies on kernel checkpoint of `ir_dag`, `theta`, and TMMU state.

### Serialization
- TMMU state via deterministic CBOR (fixed order).

### Restore semantics
- Identical execution sequence on restore (same replay_token â†’ same slot assignments).
- Mid-pass restore not supported (atomic per-batch execution).
- Parameter ownership note: `theta` is passed by reference and may be mutated by backend primitives/gradient buffers under contract; callers must treat post-call `theta` as authoritative state.

FILE: layer2-specs/Monitoring-Policy.md
=======================================
# UML_OS Monitoring Policy Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Monitoring.Policy_v1`  
**Purpose (1 sentence):** Define deterministic monitoring, drift detection, and alert policy with privacy-safe telemetry contracts.  
**Spec Version:** `UML_OS.Monitoring.Policy_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Production monitoring and drift governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Monitoring.Policy_v1`
- **Purpose (1 sentence):** Deterministic monitoring/alerting contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize undetected drift and unsafe inference behavior.
### 0.B Reproducibility Contract
- Replayable given `(monitor_policy_hash, telemetry_window_hash)`.
### 0.C Numeric Policy
- Aggregations in binary64 with deterministic windows.
### 0.D Ordering and Tie-Break Policy
- Event ordering by `(window_start, operator_seq, rank)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel telemetry streams merged by deterministic key order.
### 0.F Environment and Dependency Policy
- Telemetry must satisfy privacy classification/redaction policy.
### 0.G Operator Manifest
- `UML_OS.Monitor.Register_v1`
- `UML_OS.Monitor.Emit_v1`
- `UML_OS.Monitor.DriftCompute_v1`
- `UML_OS.Monitor.AlertCreate_v1`
- `UML_OS.Monitor.AlertAck_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Monitor.*` namespace.
### 0.I Outputs and Metric Schema
- Outputs: `(monitor_report, alert_stream)`
- Metrics: `drift_score`, `alert_count`
### 0.J Spec Lifecycle Governance
- policy threshold/metric semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- deterministic failures on invalid telemetry schema/policy.
### 0.L Input/Data Provenance
- telemetry payloads must include run_id, model_version_id, tenant_id.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- monitor definitions, alert state, drift baselines.
### I.B Inputs and Hyperparameters
- telemetry stream, policy thresholds, window params.
### I.C Constraints and Feasible Set
- privacy-unsafe telemetry rejected.
### I.D Transient Variables
- per-window aggregates and drift diagnostics.
### I.E Invariants and Assertions
- no raw features/gradients/identifiers in emitted monitoring events.

### II.F Drift Algorithm Suite (Normative)
- `drift_algorithm_id = "PSI_KS_V1"`.
- Inputs:
  - baseline sample and current-window sample over the same feature projection.
  - fixed bin edges computed deterministically from baseline quantiles (10 bins, nearest-rank quantile rule).
  - quantile cutpoints are `p âˆˆ {0.1, 0.2, ..., 0.9}` with index `k = floor(p * (n-1))` over baseline sorted ascending.
  - duplicate-cutpoint rule: when repeated baseline values produce non-unique cutpoints, use deterministic merged bins on distinct ascending edges; if distinct values < requested bins, reduce bin count deterministically to distinct-value count.
  - baseline is selected from monitor state by `baseline_ref` declared in monitor policy (fixed reference window hash).
  - if `baseline_ref` cannot be resolved to a valid baseline artifact/window, abort deterministically with `BASELINE_MISSING`.
- Metrics:
  - PSI on binned distributions with zero-probability guard `EPS_DENOM`:
    - `PSI = Î£_i (p_i - q_i) * ln((p_i + EPS_DENOM)/(q_i + EPS_DENOM))`.
  - KS statistic on empirical CDFs:
    - `KS = max_x |F_baseline(x) - F_current(x)|`,
    - ties are resolved by stable ascending tuple order `(value, source_rank, sample_index)` where `source_rank=0` for baseline and `1` for current.
- Missingness/NaN handling:
  - `NaN`/missing values map to dedicated `MISSING` bin; included in PSI and KS counts.
- Output:
  - `drift_score = max(psi_score, ks_score)`.
  - `drift_report` includes `{drift_algorithm_id, drift_algorithm_version, psi_score, ks_score, drift_score, window_id}`.
- Reproducibility:
  - `binning_rule = "quantile_10_bins"`.
  - `nan_rule = "separate_bin"`.
  - `drift_algorithm_hash = SHA-256(CBOR_CANONICAL([drift_algorithm_id, drift_algorithm_version, binning_rule, nan_rule]))`.

### II.G Auditable Policy Transcript (Normative)
- Policy evaluation must emit deterministic transcript entries:
  - `policy_input_hashes`, `rule_id`, `threshold_id`, `verdict`, `reason_code`.
- Transcript ordering rule (normative):
  - sort entries by `(window_id, rule_id, threshold_id, metric_name)`.
- Transcript hash:
  - `policy_gate_hash = SHA-256(CBOR_CANONICAL(["monitor_gate_v1", monitor_policy_hash, ordered_transcript_entries]))`.
- `policy_gate_hash` must be emitted as a mandatory trace field and bound to execution certificate evidence in regulated modes.
- Network calls are forbidden during policy verdict evaluation unless all external inputs are pre-committed by hash.

### II.H Telemetry Window Commitment (Normative)
- `telemetry_window_hash = SHA-256(CBOR_CANONICAL(["telemetry_window_v1", window_id, start_t, end_t, aggregation_rules_hash, filter_hash]))`.
- Monitoring transcripts and gate verdicts must reference `telemetry_window_hash` for every evaluated window.
- Alert ID rule: `alert_id = SHA-256(CBOR_CANONICAL(["alert_v1", drift_report, threshold_policy]))`.
- Alert lifecycle state machine (normative): `OPEN -> ACKNOWLEDGED -> RESOLVED` with deterministic transition validation.
  - Allowed transitions only:
    - `OPEN -> ACKNOWLEDGED` (explicit acknowledgement),
    - `ACKNOWLEDGED -> RESOLVED` (condition cleared),
  - `RESOLVED` is terminal.
  - Any other transition is deterministic failure (`INVALID_STATE_TRANSITION`).

---
## 3) Initialization
1. Load monitor policy.
2. Validate telemetry schemas.
3. Initialize deterministic windows.

---
## 4) Operator Manifest
- `UML_OS.Monitor.Register_v1`
- `UML_OS.Monitor.Emit_v1`
- `UML_OS.Monitor.DriftCompute_v1`
- `UML_OS.Monitor.AlertCreate_v1`
- `UML_OS.Monitor.AlertAck_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Monitor.Register_v1`  
**Category:** Monitoring  
**Signature:** `(monitor_policy, telemetry_schema -> registration_report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** registers monitored metrics, windows, and thresholds under canonical policy hash.

**Operator:** `UML_OS.Monitor.Emit_v1`  
**Category:** Monitoring  
**Signature:** `(monitor_event -> ok)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** appends typed `MonitorEvent` to the deterministic telemetry stream.

**Operator:** `UML_OS.Monitor.DriftCompute_v1`  
**Category:** Monitoring  
**Signature:** `(windowed_metrics, baseline -> drift_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** computes drift metrics under fixed deterministic aggregation windows; missing/corrupt baseline is a deterministic failure (`BASELINE_MISSING`).

**Operator:** `UML_OS.Monitor.AlertCreate_v1`  
**Category:** Monitoring  
**Signature:** `(drift_report, threshold_policy -> alert_record)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** emits deterministic alert when threshold policy is breached.

**Operator:** `UML_OS.Monitor.AlertAck_v1`  
**Category:** Monitoring  
**Signature:** `(alert_id, principal_id, ack_reason -> ack_record)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** appends deterministic acknowledgement state transition for an existing alert (`OPEN -> ACKNOWLEDGED` only).

---
## 6) Procedure
```text
1. MonitorRegister_v1
2. MonitorEmit_v1 (stream)
3. DriftCompute_v1 (window)
4. AlertCreate_v1 / AlertAck_v1
```

---
## 7) Trace & Metrics
### Logging rule
- monitoring pipeline emits deterministic `MonitorEvent` records (schema from `docs/layer1-foundation/Data-Structures.md`) and optional linked trace entries.
### Trace schema
- `run_header`: monitor_policy_hash, tenant_id
- `iter`: `MonitorEvent`-compatible fields (`window_id`, `metric_name`, `metric_value`) plus optional `alert_state`
- `run_end`: monitor_summary_hash, policy_gate_hash
### Metric schema
- `drift_score`, `alert_count`, `false_positive_rate`
### Comparability guarantee
- Comparable iff policy hash, windowing, and `MonitorEvent` schema are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- telemetry fields typed, privacy-classed, and bounded.
#### VII.B Operator test vectors (mandatory)
- stable window aggregation, drift threshold crossings, alert transitions.
#### VII.C Golden traces (mandatory)
- golden monitoring traces for reference workloads.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for alert decisions and drift metrics on frozen telemetry.
#### VIII.B Allowed refactor categories
- pipeline scaling optimizations preserving window semantics.
#### VIII.C Equivalence test procedure (mandatory)
- compare window metrics + alert events exactly.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- monitor window cursors + alert states.
### Serialization
- deterministic CBOR.
### Restore semantics
- restored monitoring continues with identical window boundaries and alerts.

---
## 11) Policy Transcript Viewer Projection (Normative)
- In addition to hash commitments, policy-gate evaluation MUST expose a deterministic human-readable projection:
  - ordered rule evaluations,
  - input metric snapshots (redacted as required),
  - per-rule decision reason codes,
  - final pass/fail rationale.
- Viewer projection is informational but deterministic:
  - identical policy transcript input yields byte-identical viewer output.
- Projection hash:
  - `policy_transcript_view_hash = SHA-256(CBOR_CANONICAL(policy_transcript_view))`.

---
## 12) Telemetry Standards Compatibility Policy (Normative)
- Prometheus/OpenMetrics naming rules:
  - metric names MUST be lowercase snake_case with stable unit suffixes.
  - tenant/profile labels MUST use fixed canonical keys.
- OpenTelemetry mapping rules:
  - resource attributes MUST include `tenant_id`, `run_id`, `profile_id`, `env_manifest_hash`.
  - span/log identity fields MUST be deterministically derived from trace records.
- Upgrade compatibility requirement:
  - telemetry field renames/removals require a compatibility mapping table and one deprecation window.

FILE: layer2-specs/Pipeline-Orchestrator.md
===========================================
# UML_OS Pipeline Orchestrator Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Pipeline.Orchestrator_v1`  
**Purpose (1 sentence):** Define deterministic job lifecycle orchestration and signed transition recording for multi-stage ML pipelines.  
**Spec Version:** `UML_OS.Pipeline.Orchestrator_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Job scheduling and pipeline state governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Pipeline.Orchestrator_v1`
- **Purpose (1 sentence):** Deterministic pipeline/job state orchestration.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize ambiguous job lifecycle transitions.
### 0.B Reproducibility Contract
- Replayable given `(job_manifest_hash, transition_log_hash)`.
### 0.C Numeric Policy
- timestamps and counters deterministic integer types.
### 0.D Ordering and Tie-Break Policy
- transitions ordered by `(job_id, transition_seq)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- queue arbitration deterministic by priority then FIFO.
### 0.F Environment and Dependency Policy
- job manifests must be signed and schema-valid.
### 0.G Operator Manifest
- `UML_OS.Pipeline.JobSubmit_v1`
- `UML_OS.Pipeline.JobTransition_v1`
- `UML_OS.Pipeline.JobHeartbeat_v1`
- `UML_OS.Pipeline.JobCancel_v1`
- `UML_OS.Pipeline.JobQuery_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Pipeline.*` namespace.
### 0.I Outputs and Metric Schema
- Outputs: `(job_state, transition_record)`
- Metrics: `queue_depth`, `job_success_rate`
### 0.J Spec Lifecycle Governance
- state machine changes are MAJOR.
### 0.K Failure and Error Semantics
- invalid transitions abort deterministically.
### 0.L Input/Data Provenance
- all transitions reference signed job manifest hash.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- job table and transition log.
### I.B Inputs and Hyperparameters
- job manifest, priority, policy constraints.
- lease policy (`lease_ttl_ticks`, `max_retries`).
- transition controls: `attempt_id`, `transition_seq:uint64`, `backoff_schedule_id`.
  - `attempt_id` is `uint64`, starts at `0` for the initial attempt, and increments by `1` for each retry attempt of the same `job_id`.
- resource quota policy (`gpu_time_budget_ms`, `cpu_time_budget_ms`, `io_bytes_budget`, `memory_bytes_budget`).
### I.C Constraints and Feasible Set
- allowed transitions:
  - `QUEUED -> RUNNING`
  - `QUEUED -> CANCELED`
  - `RUNNING -> SUCCEEDED|FAILED|CANCELED|RETRYING`
  - `RETRYING -> QUEUED|FAILED`
- Multi-scheduler determinism:
  - single authoritative scheduler per queue partition,
  - deterministic partitioning rule: `partition_id = SHA-256(job_id) mod P`,
  - only the partition owner may emit state transitions for that job.
### I.D Transient Variables
- scheduling diagnostics.
- `idempotency_key = SHA-256(CBOR_CANONICAL([tenant_id, job_id, attempt_id, transition_seq]))`
### I.E Invariants and Assertions
- no skipped lifecycle states; transition records are append-only.
- running jobs require valid lease and heartbeat.
- quota-denied transitions are deterministic and auditable.

### II.F Resource Ledger and Quota Enforcement (Normative)
- Orchestrator must maintain a deterministic per-job resource ledger:
  - `bytes_allocated`, `peak_bytes`, `io_bytes_read`, `io_bytes_written`, `gpu_time_ms`, `cpu_time_ms`.
- Quota checks must be evaluated before state transition commits and emitted into trace with `quota_policy_hash`.
- Quota violations must map to deterministic error codes and cannot be retried unless policy explicitly allows.

### II.G Supporting Policy Artifacts (Normative)
- `QuotaPolicy` artifact:
  - schema fields: `{quota_policy_hash, gpu_time_budget_ms, cpu_time_budget_ms, io_bytes_budget, memory_bytes_budget, evaluation_rule_id}`.
  - hash: `quota_policy_hash = SHA-256(CBOR_CANONICAL(quota_policy_map))`.
- `BackoffSchedule` artifact:
  - schema fields: `{backoff_schedule_id, delays_ms: array<uint64>, jitter_mode: "NONE"}`.
  - selection rule: retry `k` uses `delays_ms[min(k, len(delays_ms)-1)]`; no random jitter allowed.
- `LeasePolicy` artifact:
  - schema fields: `{lease_policy_id, lease_ttl_ticks:uint64, heartbeat_extension_ticks:uint64, expiry_transition:"RUNNING->RETRYING"}`.
  - lease id: `lease_id = SHA-256(CBOR_CANONICAL([tenant_id, job_id, attempt_id, transition_seq]))`.

### II.H Job State Machine (Closed Set, Normative)
- States: `QUEUED`, `RUNNING`, `RETRYING`, `SUCCEEDED`, `FAILED`, `CANCELED`.
- Terminal states: `SUCCEEDED`, `FAILED`, `CANCELED`.
- Allowed transitions:
  - `QUEUED -> RUNNING`
  - `QUEUED -> CANCELED`
  - `RUNNING -> SUCCEEDED | FAILED | CANCELED | RETRYING`
  - `RETRYING -> QUEUED | FAILED` (when retry budget exhausted)
- Any other transition is deterministic `CONTRACT_VIOLATION`.

---
## 3) Initialization
1. Initialize queue and policy checks.
2. Load signing/trust config for manifests.
3. Initialize transition log.

---
## 4) Operator Manifest
- `UML_OS.Pipeline.JobSubmit_v1`
- `UML_OS.Pipeline.JobTransition_v1`
- `UML_OS.Pipeline.JobHeartbeat_v1`
- `UML_OS.Pipeline.JobCancel_v1`
- `UML_OS.Pipeline.JobQuery_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Pipeline.JobSubmit_v1`  
**Category:** Orchestration  
**Signature:** `(job_manifest, priority, idempotency_key -> job_record)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** validates submission policy and enqueues a new job deterministically.

**Operator:** `UML_OS.Pipeline.JobTransition_v1`  
**Category:** Orchestration  
**Signature:** `(tenant_id, job_id, attempt_id, expected_transition_seq, from_state, to_state, evidence_ref -> transition_record)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** validates transition against state machine and writes signed transition record atomically; accepted iff stored `transition_seq == expected_transition_seq`, then increments sequence. If `from_state=="RETRYING"` and retry budget is exhausted, only `to_state=="FAILED"` is allowed.
`evidence_ref` format (normative): nullable `bytes32` hash of canonical transition evidence payload (`null` allowed for transitions that require no external evidence).

**Operator:** `UML_OS.Pipeline.JobHeartbeat_v1`
**Category:** Orchestration
**Signature:** `(job_id, lease_id, tick -> heartbeat_record)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** extends lease if `lease_id` matches active running attempt.
`tick` semantics (normative): monotonically increasing `uint64` logical progress counter for the running attempt (for example, step counter or deterministic heartbeat sequence).

**Operator:** `UML_OS.Pipeline.JobCancel_v1`  
**Category:** Orchestration  
**Signature:** `(job_id, principal_id, reason -> cancel_record)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** requests deterministic cancellation and records authorized terminal/cancel transition.

**Operator:** `UML_OS.Pipeline.JobQuery_v1`  
**Category:** Orchestration  
**Signature:** `(job_id -> job_status_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** returns canonical current state and transition summary for a job.

---
## 6) Procedure
```text
1. JobSubmit_v1
2. JobTransition_v1(QUEUED->RUNNING)
3. JobHeartbeat_v1 repeated while RUNNING
4. If lease expires: JobTransition_v1(RUNNING->RETRYING), then RETRYING->QUEUED (bounded retries)
5. JobTransition_v1(RUNNING->terminal)
6. Return final job state
```

Atomicity and deduplication rules:
- Transition write is compare-and-swap on `(job_id, transition_seq)`.
- Duplicate dispatch/ack with same `idempotency_key` must be deduplicated and return the already-committed transition record.
- Conflicting writes must fail deterministically with conflict diagnostics and follow `backoff_schedule_id`.

---
## 7) Trace & Metrics
### Logging rule
- every transition emits a deterministic trace event.
### Trace schema
- `run_header`: orchestrator_version, queue_policy_hash
- `iter`: job_id, from_state, to_state, status
- `run_end`: transition_log_hash, run_commit_record_hash?
### Metric schema
- queue and lifecycle metrics.
### Comparability guarantee
- comparable iff same policy, queue order, and manifest signatures.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- state machine completeness and illegal transition rejection.
#### VII.B Operator test vectors (mandatory)
- legal/illegal transitions, retries, cancellation cases.
#### VII.C Golden traces (mandatory)
- golden job lifecycle traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for transition decisions and transition log.
#### VIII.B Allowed refactor categories
- queue backend changes preserving transition order semantics.
#### VIII.C Equivalence test procedure (mandatory)
- exact transition log compare.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- queue state + transition cursor.
### Serialization
- deterministic CBOR.
### Restore semantics
- resumed orchestrator yields identical transition sequence.

FILE: layer2-specs/Replay-Determinism.md
========================================
# UML_OS Replay and Determinism Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ReplayDeterminismContract_v1`  
**Purpose (1 sentence):** Define and verify deterministic replay semantics, RNG ownership, token composition, and restore equivalence.  
**Spec Version:** `UML_OS.Implementation.ReplayDeterminismContract_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Reproducibility and replay verification.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ReplayDeterminismContract_v1`
- **Purpose (1 sentence):** Deterministic replay contract.
- **Spec Version:** `UML_OS.Implementation.ReplayDeterminismContract_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Replay verification.

### 0.A Objective Semantics
- Optimization sense: `MINIMIZE` replay divergences.
- Objective type: `Scalar` (`divergence_count`).
- Invalid policy: malformed trace/token treated as failure.

### 0.B Reproducibility Contract
- Seed space: `seed âˆˆ {0..2^64-1}`.
- PRNG family: Philox4x32-10.
- Randomness locality: only declared stochastic operators may draw RNG.
- Replay guarantee: replayable given `(seed, policies, runtime_env_hash, operator_versions)`.
- Replay token definitions are explicit and versioned.

### 0.C Numeric Policy
- Determinism checks for critical fields are exact.
- Tolerance checks allowed only for declared non-critical metrics.
- Approx-equality uses explicit threshold definitions.

### 0.D Ordering and Tie-Break Policy
- Trace comparison order is canonical total order `(t, rank, operator_seq)`.

### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel traces are merged under the same canonical total order `(t, rank, operator_seq)`.

### 0.F Environment and Dependency Policy
- Reference runtime and dependency hash required for replay comparability.
- Determinism level: BITWISE/TOLERANCE/DISTRIBUTIONAL declared per field class.

### 0.G Operator Manifest
- `UML_OS.Replay.ComputeReplayToken_v1`
- `UML_OS.Replay.VerifyRNGOwnership_v1`
- `UML_OS.Replay.CompareTrace_v1`
- `UML_OS.Replay.VerifyRestore_v1`
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- Fully-qualified replay operator names required.

### 0.I Outputs and Metric Schema
- Outputs: `(replay_report, divergence_summary)`.
- Metrics: `divergence_count`, `first_divergence_t`, `rng_violation_count`.
- Completion status: `success | failed`.

### 0.J Spec Lifecycle Governance
- Replay token formula changes require MAJOR bump.

### 0.K Failure and Error Semantics
- Deterministic abort on malformed trace/hash state.

### 0.L Input/Data Provenance
- All compared traces/checkpoints must be hash-addressed.

---

### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model

### I.A Persistent State
- replay policy registry and token formulas.

### I.B Inputs and Hyperparameters
- trace pairs, checkpoint pairs, policy config.

### I.C Constraints and Feasible Set
- Unconstrained; validity by token/trace compatibility.

### I.D Transient Variables
- divergence records and rng counter deltas.

### I.E Invariants and Assertions
- deterministic comparator order and complete reporting.

### II.F Replay Token Formulas (Authoritative)
- `kernel_replay_token = SHA-256(CBOR_CANONICAL(["replay_token_v1", spec_version, policy_bundle_hash, env_manifest_hash, operator_contracts_root_hash, determinism_profile_hash, driver_runtime_fingerprint_hash, uint64(seed)]))`.
- `env_manifest_hash` is computed per `docs/layer1-foundation/Environment-Manifest.md` (alias `runtime_env_hash` must resolve to same bytes32).
- `epoch_seed = SHA-256(CBOR_CANONICAL(["nextbatch_epoch_seed_v2", kernel_replay_token, manifest_hash, dataset_key, uint64(epoch)]))[0:16]`.
- `data_replay_t = SHA-256(CBOR_CANONICAL(["nextbatch_v2", kernel_replay_token, dataset_key, uint64(epoch), uint64(global_position), uint32(world_size), uint32(rank)]))`.
- `modelir_replay_t = SHA-256(CBOR_CANONICAL(["modelir_executor_v1", kernel_replay_token, ir_hash, mode, uint64(global_position)]))`.
- `dp_replay_t = SHA-256(CBOR_CANONICAL(["dp_apply_v3", kernel_replay_token, uint64(t), dp_accountant_state_hash, allocation_mode, fused_kernel, safety_reserve]))`.
- Required comparator keys in traces: `t`, `rank`, `operator_seq`, `operator_id`, `status`, `replay_token`, plus optional domain metrics.
- Canonical compare order is `(t, rank, operator_seq)`.
- Clarification: `data_replay_t` is a per-step trace token; sampler RNG seed source is `epoch_seed` above.
- Philox mapping (normative):
  - `epoch_seed` is 16 raw bytes.
  - `philox_key = [u32_le(epoch_seed[0:4]), u32_le(epoch_seed[4:8])]`.
  - `philox_counter_base = [u32_le(epoch_seed[8:12]), u32_le(epoch_seed[12:16]), 0, 0]`.
  - All `u32_le` conversions are little-endian, unsigned.
- Counter advancement is deterministic and tracked by `rng_offset_before/after`.
  - counter increment rule: each RNG draw increments the 128-bit counter by 1 (little-endian word carry propagation across four u32 words).
- Required environment capture in replay token context:
  - driver/runtime versions,
  - determinism-affecting env vars (e.g., TF32 toggles, deterministic kernel flags, collective ordering flags),
  - backend adapter build hash.
- `DriverRuntimeFingerprint` schema and hash:
  - schema fields: `gpu_model`, `gpu_sm_count`, `driver_version`, `cuda_version`, `cudnn_version`, `cublas_version`, `nccl_version`, `os_kernel_version`, `compiler_id`, `compiler_flags_hash`, `backend_adapter_version`, `backend_build_id`.
  - `driver_runtime_fingerprint_hash = SHA-256(CBOR_CANONICAL(driver_runtime_fingerprint_map))`.
  - field-order requirement: keys MUST appear exactly in the listed order for canonical map construction.
- Replay token minimum state coverage:
  - Operator contracts: `operator_contracts_root_hash`,
  - RNG counters: `rng_offset_before`, `rng_offset_after`,
  - DP: `dp_accountant_state_hash`, `dp_config_hash`,
  - Data: `sampler_config_hash`, `effective_q`,
  - Memory: `tmmu_plan_hash`,
  - Backend: `backend_binary_hash`, `determinism_profile_hash`, `driver_runtime_fingerprint_hash`.
- Supply chain: `lockfile_hash`, `toolchain_hash`, `dependencies_lock_hash`.

### II.G DeterminismProfile (Normative)
- `tf32: bool`
- `allowlist_cublas_algorithms: array<string>`
- `allowlist_cudnn_algorithms: array<string>`
- `reduction_ordering: enum("ASCENDING_INDEX","ASCENDING_RANK_RING")`
- `atomic_reductions_allowed: bool` (`false` required for E0)
- `env_vars_fingerprint: bytes32`
  - computed as `SHA-256(CBOR_CANONICAL(sorted([(name,value)])))` over determinism-critical environment allowlist:
    - `CUBLAS_WORKSPACE_CONFIG`, `CUDA_VISIBLE_DEVICES`, `NCCL_ALGO`, `NCCL_PROTO`, `OMP_NUM_THREADS`, `PYTHONHASHSEED`.
  - inclusion rule: include only variables that are actually set; resulting `(name,value)` tuples are sorted lexicographically by `name`.
- `driver_versions: map<string,string>`
- `determinism_class_map: map<string, enum("E0","E1","NON_COMPARABLE")>`:
  - declares per-field comparator class used by `CompareTrace_v1`.
- Tier binding:
  - `BITWISE`: fixed collective algorithm/chunk order/accumulation dtype-order and `atomic_reductions_allowed=false`.
  - `TOLERANCE`: explicit per-field tolerance bands and E1 comparator profile.

### II.H Divergence Policy (Normative)
- `replay_mode: enum("STRICT_E0","TOLERANT_E1")`.
- `STRICT_E0`: bitwise equality on declared E0 fields.
- `TOLERANT_E1`: explicit per-field tolerance bands only (no implicit tolerances).
- On first divergence: emit `REPLAY_DIVERGENCE`, record deterministic diagnostics, and stop replay.
- Determinism conformance governance:
  - certificate must include `determinism_conformance_suite_id`.
  - verifier rejects certificates with unknown or revoked conformance suite IDs.

### II.I Comparison Profiles (Normative)
- Profile A (`same_world_size_same_rankmap`):
  - Preconditions: identical `world_size`, identical rank mapping.
  - E0 fields include per-rank sample indices and per-rank iterator keys.
- Profile B (`different_world_size`):
  - Preconditions: dataset snapshot and sampler contract identical, but `world_size` differs.
  - Per-rank sample indices are marked `NON_COMPARABLE`.
  - Compare deterministic global fields only: `dataset_snapshot_id`, `sampler_config_hash`, `effective_q`, replay token lineage, and declared aggregate metrics under E1 policy.
- Verifier must record selected comparison profile in replay report and treat mismatched profile selection as deterministic failure.

---

## 3) Initialization

1. Load policy definitions.
2. Load traces/checkpoints.
3. Validate hash integrity.

---

## 4) Operator Manifest

- `UML_OS.Replay.ComputeReplayToken_v1`
- `UML_OS.Replay.VerifyRNGOwnership_v1`
- `UML_OS.Replay.CompareTrace_v1`
- `UML_OS.Replay.VerifyRestore_v1`
- `UML_OS.Error.Emit_v1`

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

**Operator:** `UML_OS.Replay.ComputeReplayToken_v1`  
**Category:** IO  
**Signature:** `(state -> token)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** canonical token derivation by declared formula.  
**Preconditions / Postconditions:** required fields present.  
**Edge cases:** missing optional fields disallowed if formula requires them.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** canonical field order.  
**Complexity note:** O(serialized_state_size).  
**Failure behavior:** deterministic token-computation error.  
**Dependencies:** canonical serializer/hash function.  
**Test vectors:** fixed state -> token snapshots.

**Operator:** `UML_OS.Replay.VerifyRNGOwnership_v1`  
**Category:** IO  
**Signature:** `(trace -> ownership_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** verifies only declared stochastic operators consume RNG offsets.  
**Preconditions / Postconditions:** trace has rng metadata.  
**Edge cases:** zero-draw runs.  
**Numerical considerations:** counter arithmetic in uint64.  
**Ordering/tie handling:** trace order.  
**Complexity note:** O(trace_events).  
**Failure behavior:** `RNG_CONSUMPTION_VIOLATION`.  
**Dependencies:** operator manifest ownership declarations.  
**Test vectors:** valid/invalid ownership traces.

**Operator:** `UML_OS.Replay.CompareTrace_v1`  
**Category:** IO  
**Signature:** `(trace_a, trace_b, comparison_profile -> divergence_summary)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** compares trace fields under declared determinism class rules using `docs/layer2-specs/Trace-Sidecar.md` schema, active determinism profile, and the selected comparison profile from Section II.I:
- E0 fields: exact byte equality (`replay_token`, hashes, `operator_id`, `operator_seq`, state fingerprints, decision/status codes),
- E1 fields: tolerance comparisons as declared by profile/field policy (for example numeric metrics), using
  `|a-b| <= max(abs_tol, rel_tol * max(|a|, |b|))` with deterministic per-field `abs_tol`/`rel_tol`,
  where `abs_tol` and `rel_tol` are sourced from the active determinism profile (or field overrides). If unspecified, defaults are `abs_tol = EPS_EQ` and `rel_tol = 0`.
- key-space and record ordering must match exactly in canonical `(t, rank, operator_seq)` order.
- profile mismatch rule: if `comparison_profile` is missing, unknown, or inconsistent with trace preconditions, return deterministic divergence failure (`REPLAY_DIVERGENCE`) with explicit reason in diagnostics.
**Preconditions / Postconditions:** identical schema keys/types.  
**Edge cases:** different lengths.  
**Numerical considerations:** exact for E0 fields, threshold for E1.  
**Ordering/tie handling:** canonical `(t, rank, operator_seq)` order.  
**Complexity note:** O(trace_size).  
**Failure behavior:** deterministic divergence report; emits `REPLAY_DIVERGENCE` on first mismatch under selected replay mode.  
**Dependencies:** determinism-class map.  
**Test vectors:** replay-equivalent and divergent pairs.

---

**Operator:** `UML_OS.Replay.VerifyRestore_v1`  
**Category:** Replay  
**Signature:** `(checkpoint_blob, restored_state, replay_token -> restore_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Verifies that restore state and replay token exactly match checkpoint commitments and deterministic replay contracts.

## 6) Procedure

```text
1. ComputeReplayToken_v1 for both runs
2. VerifyRNGOwnership_v1 for both traces
3. CompareTrace_v1(trace_a, trace_b, comparison_profile)
4. VerifyRestore_v1(checkpoint_blob, restored_state, replay_token)
5. Return replay_report
```

---

## 7) Trace & Metrics

### Logging rule
Every replay check emits deterministic divergence records.

### Trace schema
- `run_header`: token formulas, policy hash
- `iter`: check_id, result, divergence_location
- `run_end`: status, divergence_summary

### Metric schema
- `divergence_count`, `first_divergence_t`, `rng_violation_count`

### Comparability guarantee
Comparable iff policy hash, token formulas, and trace schema are identical.

---

## 8) Validation

#### VII.A Lint rules (mandatory)
Passes deterministic ordering, explicit stochastic ownership, trace compliance.

#### VII.B Operator test vectors (mandatory)
Token, RNG ownership, and trace comparison vectors.

#### VII.C Golden traces (mandatory)
Golden replay-equivalent and known-divergence fixtures.

---

## 9) Refactor & Equivalence

#### VIII.A Equivalence levels
- E0 for replay report identity.

#### VIII.B Allowed refactor categories
- Comparator optimization preserving report semantics.

#### VIII.C Equivalence test procedure (mandatory)
Exact comparison of divergence summary outputs.

---

## 10) Checkpoint/Restore

### Checkpoint contents
- replay policy hash, token formulas, comparator config.

### Serialization
- deterministic CBOR/JSON.

### Restore semantics
- restored contract yields identical replay verdicts.

FILE: layer2-specs/Run-Commit-WAL.md
====================================
# UML_OS Run Commit WAL Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Commit.RunCommitWAL_v1`  
**Purpose (1 sentence):** Define deterministic write-ahead logging and recovery rules for atomic run commit of trace/checkpoint/lineage/certificate artifacts.  
**Spec Version:** `UML_OS.Commit.RunCommitWAL_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Crash-consistent artifact finalization.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Commit.RunCommitWAL_v1`
- **Purpose (1 sentence):** Atomic, replayable run finalization.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: exact WAL replay and final artifact set equality.
- Invalid objective policy: partial-commit states are failures.
### 0.B Reproducibility Contract
- Replayable given `(wal_records, run_id, tenant_id)`.
### 0.C Numeric Policy
- Counters and sequence IDs use uint64.
- Counter overflow is forbidden: any increment that would exceed `2^64-1` MUST abort with `COUNTER_OVERFLOW`.
### 0.D Ordering and Tie-Break Policy
- WAL records are strictly ordered by `wal_seq`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Exactly one active commit writer per `(tenant_id, run_id)`.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE`.
### 0.G Operator Manifest
- `UML_OS.Commit.WALAppend_v1`
- `UML_OS.Commit.WALRecover_v1`
- `UML_OS.Commit.FinalizeRunCommit_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- WAL paths:
  - `wal/run_commit/<tenant_id>/<run_id>/records/<wal_seq>.cbor`
  - `runs/<tenant_id>/<run_id>/COMMITTED` (single canonical commit-pointer object)
### 0.I Outputs and Metric Schema
- Outputs: `(commit_status, commit_record_hash, wal_terminal_hash)`.
### 0.J Spec Lifecycle Governance
- WAL record shape changes are MAJOR.
### 0.K Failure and Error Semantics
- Abort on sequence gaps, duplicate terminal records, or hash mismatch.
### 0.L Input/Data Provenance
- All artifact IDs/hashes in WAL must be content-addressed.

---
## 2) System Model
### I.A Persistent State
- WAL append log and commit index.
### I.B Inputs and Hyperparameters
- temp artifact refs and final artifact refs.
### I.C Constraints and Feasible Set
- valid iff WAL sequence monotone and commit protocol complete.
### I.D Transient Variables
- recovery plan and validation diagnostics.
### I.E Invariants and Assertions
- exactly one committed terminal record per run.

### II.F WAL Record Schema (Normative)
- Required fields:
  - `tenant_id:string`
  - `run_id:string`
  - `wal_seq:uint64`
  - `record_type:enum("PREPARE","CERT_SIGNED","FINALIZE","ROLLBACK")`
  - `trace_tmp_hash?:bytes32`
  - `checkpoint_tmp_hash?:bytes32`
  - `lineage_tmp_hash?:bytes32`
  - `certificate_tmp_hash?:bytes32`
  - `trace_final_hash?:bytes32`
  - `checkpoint_final_hash?:bytes32`
  - `lineage_final_hash?:bytes32`
  - `certificate_final_hash?:bytes32`
  - `manifest_hash?:bytes32`
  - `policy_bundle_hash?:bytes32`
  - `operator_registry_hash?:bytes32`
  - `determinism_profile_hash?:bytes32`
  - `checkpoint_hash?:bytes32`
  - `lineage_root_hash?:bytes32`
  - `certificate_hash?:bytes32`
  - `commit_pointer_hash?:bytes32`
  - `prev_record_hash:bytes32`
  - `record_length_u32:uint32`
  - `record_crc32c:uint32`
  - `record_hash:bytes32`

WAL hash-chain rule:
- Define `wal_record_payload_i` as the canonical CBOR map of the WAL record with all present fields except `record_hash`.
- `record_hash_i = SHA-256(CBOR_CANONICAL(["wal_record_v1", wal_record_payload_i]))`
- `commit_record_hash = record_hash` of the terminal `FINALIZE` WAL record.
- `wal_terminal_hash = commit_record_hash`.
- WAL framing integrity rule:
  - records are persisted as `[record_length_u32 | record_cbor_bytes | record_crc32c]`,
  - `record_length_u32` and `record_crc32c` are encoded in little-endian byte order,
  - `record_crc32c` uses CRC-32C (Castagnoli polynomial, RFC 3720),
  - `record_crc32c` is computed over `record_cbor_bytes`,
  - recovery MUST reject checksum mismatches and truncated trailing records as `WAL_CORRUPTION`.

Terminal commit record rule:
- `record_type="FINALIZE"` MUST include:
  - `trace_final_hash`, `checkpoint_hash`, `lineage_root_hash`, `certificate_hash`,
  - `manifest_hash`, `policy_bundle_hash`, `operator_registry_hash`, `determinism_profile_hash`.
- `CERT_SIGNED` record payload rule:
  - `record_type="CERT_SIGNED"` MUST include at least one of:
    - `certificate_tmp_hash` (pre-final certificate artifact), or
    - `certificate_final_hash` (finalized certificate artifact),
  - and SHOULD include `policy_bundle_hash` + `determinism_profile_hash` to bind signing context.

### II.G Recovery Rule (Normative)
- Deterministic `WALRecover_v1` algorithm:
  1. Enumerate records for `(tenant_id, run_id)` by strictly ascending `wal_seq`.
  2. Validate continuity: first record MUST have `wal_seq=0`; each next record MUST increment by exactly 1.
  3. Validate framing/checksum for each record (`record_length_u32`, `record_crc32c`); detect and reject torn writes.
  4. Validate hash chain: for each record `i>0`, `prev_record_hash_i == record_hash_{i-1}`; recompute each `record_hash_i` from canonical payload and verify equality.
  5. If chain validation fails (gap, mismatch, duplicate terminal), abort with `WAL_CORRUPTION`.
  6. Determine terminal state from highest `wal_seq` record:
     - `FINALIZE`: verify all referenced final artifacts exist and hashes match; if valid, mark committed and return success.
     - `ROLLBACK`: ensure no final artifacts are visible via COMMITTED pointer; return rolled-back success.
     - non-terminal (`PREPARE` or `CERT_SIGNED`): execute deterministic rollback:
       - remove temp artifacts referenced by WAL (idempotent),
       - remove COMMITTED pointer if present and inconsistent,
       - append terminal `ROLLBACK` record if absent.
  7. Emit deterministic recovery report with status, terminal record hash, and any removed temp refs.

Canonical commit barrier:
- Write immutable content-addressed artifacts first.
- Publish a single commit-pointer object `runs/<tenant_id>/<run_id>/COMMITTED` via conditional create-if-absent.
- Commit pointer payload binds `{trace_final_hash, checkpoint_hash, lineage_root_hash, certificate_hash, wal_terminal_hash}`.
- WAL remains recovery evidence; COMMITTED pointer is the canonical visibility barrier.

---
## 3) Initialization
1. Open/create WAL stream.
2. Validate existing sequence continuity.
3. Initialize commit state machine.

---
## 4) Operator Manifest
- `UML_OS.Commit.WALAppend_v1`
- `UML_OS.Commit.WALRecover_v1`
- `UML_OS.Commit.FinalizeRunCommit_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Commit.WALAppend_v1`  
**Category:** IO  
**Signature:** `(tenant_id, run_id, wal_record -> wal_state')`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** resolves run-scoped WAL path from `(tenant_id, run_id)`, then appends canonical record with monotone `wal_seq`.
Caller contract: `wal_record` MUST contain at least `record_type` plus required payload fields for that type; caller MUST NOT provide `wal_seq`, `prev_record_hash`, `record_hash`, `record_length_u32`, or `record_crc32c` (these are deterministically filled by the operator).

**Operator:** `UML_OS.Commit.WALRecover_v1`  
**Category:** IO  
**Signature:** `(tenant_id, run_id -> recovery_report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** Executes II.G algorithm exactly using `(tenant_id, run_id)` to resolve `wal_stream` and `artifact_store` deterministically (tenant/run scoped namespace paths), validates sequence/hash-chain, then deterministically finalize-or-rollback with idempotent artifact handling and explicit corruption failure.

**Operator:** `UML_OS.Commit.FinalizeRunCommit_v1`  
**Category:** IO  
**Signature:** `(tenant_id, run_id -> commit_status)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** resolves run-scoped commit context from `(tenant_id, run_id)`, verifies all referenced immutable artifacts and hashes, publishes commit pointer atomically, and returns deterministic terminal commit status.

---
## 6) Procedure
```text
0. WALRecover_v1(tenant_id, run_id) on startup/resume
1. WALAppend_v1(tenant_id, run_id, {record_type:"PREPARE"})
2. WALAppend_v1(tenant_id, run_id, {record_type:"CERT_SIGNED", certificate_tmp_hash})
3. FinalizeRunCommit_v1(tenant_id, run_id)
4. WALAppend_v1(tenant_id, run_id, {record_type:"FINALIZE", trace_final_hash, checkpoint_hash, lineage_root_hash, certificate_hash, manifest_hash, policy_bundle_hash, operator_registry_hash, determinism_profile_hash})
```

---
## 7) Trace & Metrics
### Logging rule
- Every WAL transition emits deterministic trace records.
### Trace schema
- `run_header`: tenant_id, run_id
- `iter`: wal_seq, record_type, status
- `run_end`: commit_status, commit_record_hash
### Metric schema
- `wal_records`, `recovery_attempts`, `rollback_count`
### Comparability guarantee
- Comparable iff WAL schema and recovery rules are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- monotone sequence, single terminal state.
#### VII.B Operator test vectors (mandatory)
- crash-before-finalize, crash-after-cert, duplicate-finalize cases.
#### VII.C Golden traces (mandatory)
- golden commit and recovery traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for final commit status and committed artifact hashes.
#### VIII.B Allowed refactor categories
- storage backend changes preserving WAL semantics.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare of terminal WAL state and final artifacts.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- WAL cursor and last validated terminal record hash.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- resumed commit/recovery produces identical terminal outcome.

FILE: layer2-specs/Security-Compliance-Profile.md
=================================================
# UML_OS Security and Compliance Profile
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Security.ComplianceProfile_v1`  
**Purpose (1 sentence):** Define deterministic security/compliance requirements for managed, confidential, and regulated operation modes.  
**Spec Version:** `UML_OS.Security.ComplianceProfile_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Security policy and regulated execution governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Security.ComplianceProfile_v1`
- **Purpose (1 sentence):** Security/compliance policy contract.
- **Spec Version:** `UML_OS.Security.ComplianceProfile_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Auditable secure execution.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize policy violations and unverifiable execution paths.
### 0.B Reproducibility Contract
- Replayable given `(policy_bundle_hash, attestation_bundle_hash, certificate_schema_version)`.
### 0.C Numeric Policy
- Compliance counters/thresholds in exact integer or binary64 as declared.
### 0.D Ordering and Tie-Break Policy
- Security checks execute in deterministic policy order.
### 0.E Parallel, Concurrency, and Reduction Policy
- Concurrent audits merged deterministically.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for policy verdicts and signatures.
### 0.G Operator Manifest
- `UML_OS.Security.ValidatePolicy_v1`
- `UML_OS.Security.AttestTEE_v1`
- `UML_OS.Security.VerifyCertificate_v1`
- `UML_OS.Security.SignComplianceRecord_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Fully-qualified security operators and signed sidecars required.
### 0.I Outputs and Metric Schema
- Outputs: `(compliance_report, signed_record)`.
- Metrics: `policy_violations`, `attestation_failures`, `signature_valid`.
- Completion status: `success | failed`.
### 0.J Spec Lifecycle Governance
- Regulatory-policy semantic changes require MAJOR bump.
### 0.K Failure and Error Semantics
- Abort on critical security failures.
### 0.L Input/Data Provenance
- Policy source, attestation evidence, and certificate chain are hash-addressed.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.


## 2) System Model
### I.A Persistent State
- compliance policy registry and signer metadata.
### I.B Inputs and Hyperparameters
- execution mode, policy set, attestation evidence.
### I.C Constraints and Feasible Set
- Valid if policy + attestation + signature requirements pass.
### I.D Transient Variables
- compliance diagnostics and signature payloads.
### I.E Invariants and Assertions
- no unsigned compliant status is accepted in regulated mode.

### II.F Threat Model and Governance (Normative)
- Threat model: malicious tenant code, compromised node runtime, stale/revoked attestations, unsigned artifact injection, and transport MITM.
- Trust boundaries and required controls:
  - tenant code â†” runtime: sandboxing, least privilege, syscall policy.
  - runtime â†” daemon/control plane: mTLS + attestation identity binding.
  - daemon â†” storage: signed artifact verification + path segregation.
  - daemon â†” KMS/HSM: authenticated key access + audit logging.
  - node â†” network fabric: network policies + authenticated channels.
- Required attestation claims:
  - platform measurement/PCR set,
  - TCB version,
  - runtime config hash,
  - loaded driver hash,
  - policy hash.
- Key governance:
  - `key_origin: enum("KMS","HSM")`,
  - signing keys must reside in KMS/HSM-backed stores,
  - `rotation_max_age_days` and `rotation_procedure_hash` are mandatory,
  - revocation checks mandatory for quote certs, signing certs, and policy keys,
  - role-based signing authorization and audit trail.
- Access governance:
  - `access_control_model` (RBAC roles + required permissions),
  - `breakglass_policy` must be explicit, time-bounded, and fully audited.
  - operator-level capability enforcement is mandatory via `required_capabilities` from canonical operator registry.
  - authorization decision hash:
    - `authz_query_hash = SHA-256(CBOR_CANONICAL([tenant_id, principal_id, operator_id, sorted(required_capabilities), authz_policy_hash, capability_matrix_hash]))`.
    - `authz_decision_hash = SHA-256(CBOR_CANONICAL([authz_query_hash, verdict_enum, granted_capabilities_hash, decision_reason_code]))`.
    - definitions and canonical field semantics are normative as specified in `docs/layer2-specs/AuthZ-Capability-Matrix.md` section II.G.
  - denied authorization decisions must be recorded as deterministic trace events and included in certificate evidence binding.
- Registry governance roles:
  - `registry_approver`, `registry_publisher`, `registry_auditor` (least-privilege RBAC mandatory).
- Multi-tenant requirement:
  - `tenant_id` must be present in run, trace, checkpoint, artifact, and registry records.
- Transport/security baseline:
  - mTLS required for control plane APIs,
  - service identity binding to attestation identity,
  - pinned trust roots and minimum cipher-suite policy are mandatory.
- Deterministic verification evidence bundle (mandatory for reproducible verdicts):
  - `revocation_mode: enum("ONLINE_CAPTURE","PINNED_OFFLINE_BUNDLE")`,
  - `trust_store_hash`,
  - `revocation_bundle_hash` (canonical hash of either online capture bundle or pinned offline bundle),
  - `attestation_bundle_hash`.
- Normative evidence schemas:
- `TrustStore` CBOR map:
    - `trust_roots: array<bytes>`, `version:string`, `issuer_policies_hash:bytes32`.
    - `trust_roots` MUST be sorted lexicographically by raw byte value.
- `RevocationBundle` CBOR map:
    - `mode`, `ocsp_responses?:array<bytes>`, `crl_blobs?:array<bytes>`, `fetch_metadata_hash:bytes32`, `source_timestamps:array<string>`.
    - `ocsp_responses`, `crl_blobs`, and `source_timestamps` MUST be sorted deterministically by bytewise lexicographic order.
- `AttestationBundle` CBOR map:
    - `tee_type:string`, `measurements_hash:bytes32`, `quote_blob:bytes`, `verification_report_hash:bytes32`, `tcb_version:string`.
    - `measurements_hash` computation (normative): `SHA-256(CBOR_CANONICAL(["measurements_v1", pcr_values_sorted_by_index]))`.
    - `attestation_quote_hash = SHA-256(quote_blob)` is a component hash; certificate binding is authoritative on `attestation_bundle_hash` (and may additionally include `attestation_quote_hash`).
  - Hash rule for each bundle:
    - `*_hash = SHA-256(CBOR_CANONICAL(bundle_map))`.
  - `ONLINE_CAPTURE` revocation mode requires that OCSP/CRL artifacts are captured at signing time and bound into `revocation_bundle_hash`; verifiers MUST use this captured bundle for verdict evaluation.
- Verification verdict determinism claim is scoped to identical evidence bundles and `policy_bundle_hash`.
- Time-policy rule:
  - if verification time affects verdict, it must be frozen as an explicit declared input and included in signed evidence;
  - otherwise verification time is informational only and excluded from deterministic verdict computation.
  - canonical timestamp format for verification-related fields (including `verification_time_utc` and revocation `source_timestamps`) is UTC ISO 8601 without fractional seconds: `YYYY-MM-DDTHH:MM:SSZ`.
- Regulated-mode trace redaction binding:
  - certificate signed payload must include `redaction_policy_hash` and `redaction_key_id` when `redaction_mode != NONE`.
  - `redaction_key_id` definition (normative): UTF-8 string key identifier that uniquely resolves to the HMAC redaction key material in the active trust/key store.
  - presence rule: `redaction_key_id` is required when `redaction_mode != NONE` and must be absent when `redaction_mode == NONE`.
  - field-level transformation rules must conform to `docs/layer1-foundation/Redaction-Policy.md`.

---
## 3) Initialization
1. Load policy profile.
2. Validate signing keys and trust anchors.
3. Initialize compliance context.

---
## 4) Operator Manifest
- `UML_OS.Security.ValidatePolicy_v1`
- `UML_OS.Security.AttestTEE_v1`
- `UML_OS.Security.VerifyCertificate_v1`
- `UML_OS.Security.SignComplianceRecord_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

Template conformance note (III.A): each operator definition in this section is interpreted with the full EQC operator template fields. When a field is not repeated inline, the section-level defaults are: explicit typed signatures, deterministic ordering/tie handling, declared numerical policy inheritance, deterministic failure semantics (0.K), explicit dependencies, and VII.B test-vector coverage.

**Operator:** `UML_OS.Security.ValidatePolicy_v1`  
**Category:** IO  
**Signature:** `(runtime_state, policy -> policy_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates runtime behavior against policy rules.

**Operator:** `UML_OS.Security.AttestTEE_v1`  
**Category:** Security  
**Signature:** `(runtime_state -> quote)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic protocol path  
**Definition:** collects and validates TEE quote.
Validation is deterministic against policy-declared expected measurements (`expected_measurements_hash`) and pinned verifier trust roots; mismatch aborts with `ATTESTATION_FAILURE`.

**Operator:** `UML_OS.Security.VerifyCertificate_v1`  
**Category:** Security  
**Signature:** `(certificate_input, trust_roots? -> report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** verifies signature chains and required claims. `certificate_input` MAY be either a loaded certificate object or a canonical certificate path; if path is provided, loading/decoding is deterministic and part of this operator.

**Operator:** `UML_OS.Security.SignComplianceRecord_v1`  
**Category:** Security  
**Signature:** `(compliance_report, signing_key -> signed_record)`  
**Purity class:** IO  
**Determinism:** deterministic payload canonicalization  
**Definition:** signs canonical compliance payload.

---
## 6) Procedure
```text
1. ValidatePolicy_v1
2. AttestTEE_v1 (mode-dependent)
3. VerifyCertificate_v1
4. SignComplianceRecord_v1
5. Emit compliance_report + signed_record
```

---
## 7) Trace & Metrics
### Logging rule
All security checks emit deterministic audit records.
### Trace schema
- `run_header`: policy_bundle_hash, mode
- `iter`: check_id, result, evidence_hash
- `run_end`: compliance_status, signature_hash
### Metric schema
- `policy_violations`, `attestation_failures`, `signature_valid`
### Comparability guarantee
Comparable iff `policy_bundle_hash`, trust roots, and evidence schema are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
Passes policy completeness, deterministic ordering, and traceability checks.
#### VII.B Operator test vectors (mandatory)
Valid/invalid policy and certificate fixtures.
#### VII.C Golden traces (mandatory)
Golden compliant and non-compliant execution audit traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for compliance verdict and signed payload hash.
#### VIII.B Allowed refactor categories
- verifier/signer implementation refactor preserving verdict semantics.
#### VIII.C Equivalence test procedure (mandatory)
Exact compliance report + signature verification comparison.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- policy state, trust anchors, and partial audit records.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- resumed compliance evaluation yields identical verdict/signature.

---
## 11) Auditor-Ready Security Case Addendum (Normative)
- Security/compliance implementations MUST maintain a control-mapped security case artifact containing:
  - assets and trust boundaries,
  - attacker capabilities and assumptions,
  - required mitigations,
  - evidence locations in UML_OS artifacts (trace fields, certificate payload fields, policy transcripts).
- Mode-specific proof obligations:
  - `managed`: prove policy enforcement, key provenance, and authorization binding.
  - `confidential`: prove attestation and runtime measurement integrity.
  - `regulated`: prove all managed/confidential obligations plus revocation capture and immutable audit evidence completeness.
- Security case identity:
  - `security_case_hash = SHA-256(CBOR_CANONICAL(security_case_bundle))`.

---
## 12) Control Crosswalk Format (Normative)
- Security case bundle MUST include a control crosswalk table:
  - `control_id`,
  - `requirement_text`,
  - `evidence_field_refs`,
  - `evidence_artifact_refs`,
  - `verification_procedure_id`,
  - `pass_fail_criteria`.
- Crosswalk entries MUST be machine-readable and deterministic to enable automated audit verification.
- Threat/crosswalk implementation guidance:
  - `docs/layer4-implementation/Threat-Model-and-Control-Crosswalk.md`.

FILE: layer2-specs/TMMU-Allocation.md
=====================================
# Universal Machine Learning Operating System â€” TMMU Allocation
**EQC Compliance:** This specification follows EquationCode (EQC) v1.1 merged single-file format (Option A): 10 top-level sections, global semantics first, operator-owned math, control-flow-only procedure, deterministic contracts, and replayable stochasticity.

**Algorithm:** `UML_OS.TMMU.PrepareMemory_v2`  
**Purpose (1 sentence):** Perform static liveness analysis, slot-optimal interval-graph coloring, multi-arena size-aware logical slot assignment, and deterministic injective arena-offset logical-address mapping for any UML_Model_IR DAG, guaranteeing bit-identical layout plans, alignment safety, and replayability across large models.  
**Spec Version:** `UML_OS.TMMU.PrepareMemory_v2` | 2026-02-17 | Authors: Olejar Damir (with EQC team improvements)  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Deterministic, size-aware, multi-arena tensor memory planning via interval-graph register allocation for deep learning computation graphs.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** `UML_OS.TMMU.PrepareMemory_v2`
- **Purpose (1 sentence):** Statically compute optimal reusable logical slots and deterministic logical addresses with maximal liveness-based reuse.
- **Spec Version:** `UML_OS.TMMU.PrepareMemory_v2` | 2026-02-17 | Authors: Olejar Damir (with EQC team)
- **Domain / Problem Class:** Scalable, reproducible, alignment-aware tensor memory planning for ML graphs.

### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Not an optimization operator (enables extreme efficiency).
- Primary guarantee: identical logical slots, logical addresses, and tensor_map for identical `(ir_dag, execution_order, mode, replay_token)`.
- Optimization scope clarification:
  - slot count is optimal for interval overlap constraints,
  - total byte footprint across arenas is heuristic (deterministic, not globally optimal).
- Comparison rule: exact equality of logical addresses and live ranges.

### 0.B Reproducibility Contract
- Seed space: `seed âˆˆ {0..2^64-1}` inherited from kernel replay context.
- PRNG family: Philox4x32-10 (not sampled in allocator core path).
- Assignment is 100% deterministic given replay_token.
- Two-level mapping:
  - Logical slot ID (0-based, assigned by optimal greedy linear scan on interval graph).
  - Logical address is deterministic arena offset mapping: for each arena, slots are ordered deterministically and assigned by aligned prefix-sum offsets.
- Randomness locality: no sampling in core allocation path; any pseudo-random fill/zero pattern generation is operator-owned (`ZeroTensor_v1`) and deterministic.
- Replay guarantee: replayable given `(replay_token, ir_hash, mode, arena_config, execution_order)`.
- Replay token size: fixed 32 bytes (SHA-256 output), inherited from kernel contract.
- No randomness in core path. Full replayability of layout, zeroing, and physical remapping.

### 0.C Numeric Policy
- All sizes, offsets, alignments, and addresses in uint64.
- No floating-point in allocation path.
- Zeroing policy: `ZeroTensor_v1` writes literal zeros only.
- Optional debug fill: `DebugFillTensor_v1` may write deterministic patterns; forbidden in `confidential` and `regulated` modes.
- Overflow policy: abort on uint64 overflow in offset/size arithmetic.
- Approx-equality: exact integer equality only.
- Normalized exponentials / transcendental functions: N/A for allocator semantics.

### 0.D Ordering and Tie-Break Policy
- Tensors ordered by first definition node_id (earliest wins on ties).
- Logical slots assigned in ascending order (lowest available first).
- Within same birth time: larger tensors first (size-descending heuristic for better packing).
- Secondary tie-break for equal birth and equal size: `tensor_id` lexicographic ascending.

### 0.E Parallel, Concurrency, and Reduction Policy
- Allocation is purely sequential and deterministic.
- Driver-level intra-op parallelism does not affect virtual layout.

### 0.F Environment and Dependency Policy
- Requires UML_Model_IR with complete shape, dtype, and tensor-role hints.
- Depends on execution_order and arena_config.
- Reference runtime: pure Python simulator for E0 verification.
- Dependencies: replay_token and deterministic slot ordering.
- Determinism level: `BITWISE` for slot assignments and logical-address mapping.

### 0.G Operator Manifest
- `UML_OS.TMMU.PrepareMemory_v2`
- `UML_OS.TMMU.PlanMemory_v2`
- `UML_OS.TMMU.ApplyPlan_v1`
- `UML_OS.Model.AnalyzeLiveness_v1`
- `UML_OS.TMMU.AssignLogicalSlots_v1` (new)
- `UML_OS.TMMU.MapToVirtualAddresses_v1` (new)
- `UML_OS.TMMU.ZeroTensor_v1`
- `UML_OS.TMMU.DebugFillTensor_v1`
- `UML_OS.TMMU.CommitExecution_v1`
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- Fully-qualified names: `UML_OS.TMMU.<Name>_v#`

### 0.I Outputs and Metric Schema
- Declared outputs: `tensor_map: dict[tensor_id â†’ {logical_address, arena, logical_slot, size, lifetime}]`, `metrics`
- Minimum metrics: `peak_logical_slots`, `peak_physical_bytes_per_arena`, `memory_reuse_ratio`, `max_live`, `internal_fragmentation_ratio`, `allocation_time_ns`
- Completion status: `success | failed` with deterministic failure codes from 0.K.

### 0.J Spec Lifecycle Governance
- Changes affecting liveness intervals, slot assignment, or logical-address derivation require MAJOR version bump.
- Performance-only implementation changes that preserve outputs/trace semantics require MINOR bump.
- Equivalence target: E0 for slot map and logical-address determinism.

### 0.K Failure and Error Semantics
- Failure codes: `INVALID_IR_SHAPES`, `LIVENESS_CYCLE`, `ADDRESS_COLLISION`, `ALLOCATION_OVERFLOW`, `ARENA_TOO_SMALL`, `ALIGNMENT_VIOLATION`
- `ADDRESS_COLLISION` is unreachable in nominal path with injective arena-offset mapping; it is reserved for corrupted metadata detection.
- Always aborts with full context.

### 0.L Input/Data Provenance
- Relies on ir_dag canonical hash and replay_token.
- All shapes/dtypes/roles fingerprinted.

### 0.M Recommended Presets
- `train_full`: forward + backward (max activation retention)
- `inference`: aggressive reuse
- `remat_enabled`: future selective rematerialization hints

### 0.N Arena Policy (new)
- `parameters`: persistent, no reuse, sequential offsets.
- `activations`: high-reuse interval allocation.
- `gradients`: backward-only, high-reuse.
- Each arena has its own logical-slot space and virtual-address base.

---

### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model

### I.A Persistent State
- None (stateless; arenas managed by upper TMMU layer).

### I.B Inputs and Hyperparameters
- `ir_dag: UML_Model_IR` (with tensor roles)
- `execution_order: node[]`
- `mode: "forward" | "backward" | "inference"`
- `replay_token: bytes32` (32 bytes, SHA-256)
- `arena_config`: {arena_name â†’ {capacity_bytes, alignment_bytes (default 128), page_size}}

### I.C Constraints and Feasible Set
- All shapes/dtypes known statically.
- Acyclic dataflow.
- Peak live bytes per arena â‰¤ arena capacity.
- Alias/in-place constraints must be declared in IR metadata and honored by liveness planner.
- Dynamic shapes require either declared shape envelope or deterministic replan trigger policy.

### I.D Transient Variables
- `live_ranges`, `active_set`, `logical_slot_map`, `logical_address_table`, `free_intervals_per_arena` (for size-aware fallback)

### I.E Invariants and Assertions
- No access before birth or after death.
- Live tensors in same logical slot never overlap.
- Base storage slot offsets are unique within arena; views/aliases may overlap by declared alias contract.
- Alignment respected.
- Mathematical guarantee: #logical_slots_per_arena = max simultaneous live tensors in that arena (interval graph optimality).

### II.F Arena and Slot Model (Normative)
- Arena model: each device exposes `{arena_id, base_ptr, size_bytes, alignment_bytes}`.
- Slot model: each allocation emits `{arena_id, slot_offset, size_bytes, alignment, generation}`.
- Pointer derivation: `ptr = base_ptr + slot_offset`.
- Hashes are allowed only for stable tensor identity/fingerprints, never as address source.
- Backend allocation scope:
  - backend direct allocations are forbidden for traced tensors and contract-critical buffers;
  - backend-internal ephemeral scratch is allowed only if it is excluded from trace/certificate semantics and cannot affect deterministic outputs.

### II.G Alias and In-Place Semantics (Normative)
- Shared-storage tensors must declare `alias_group_id`.
- Views must declare `view_descriptor = {base_tensor_uid, byte_offset, byte_length, stride_desc}`.
- In-place writes are allowed only when all are true:
  - `alias_group_refcount == 1`,
  - `saved_for_backward == false`,
  - liveness constraints remain valid for the base storage.
- Alias refcount lifecycle:
  - increment on alias/view creation bound to `alias_group_id`,
  - decrement on deterministic end-of-liveness event for each alias member,
  - storage reuse allowed only when refcount reaches zero.

### II.H Dynamic Shapes and Replan Policy (Normative)
- Dynamic dimensions must declare `shape_envelope` bounds.
- `replan_policy: "ABORT" | "REPLAN_AT_SAFEPOINT"`.
- Replans may occur only at declared safepoints (iteration boundary), must emit trace record with old/new `tmmu_plan_hash`, and checkpoint must store updated plan hash.

### II.I Distributed Sharding Awareness (Normative)
- Plan validity must include `{rank, world_size, shard_spec_hash}`.
- `tmmu_plan_hash` must incorporate rank-local arena layout and global shard specification.
- Planner must support parameter, activation, and optimizer-state sharding contracts.

### II.K Plan Hash (Normative)
- `execution_order_hash = SHA-256(CBOR_CANONICAL(execution_order))`.
- `shard_spec_hash = SHA-256(CBOR_CANONICAL(shard_spec))`, where `shard_spec` is resolved from manifest parallelism/sharding configuration.
- `tmmu_plan_hash = SHA-256(CBOR_CANONICAL(["tmmu_plan_v1", ir_hash, mode, arena_config_hash, execution_order_hash, rank, world_size, shard_spec_hash, slot_assignment_table, logical_address_table]))`.
- `replay_token` is `bytes32` and is included in `slot_assignment_table` derivation inputs.

### II.J Resource Ledger Emission (Normative)
- Allocator must emit deterministic resource-ledger counters per step:
  - `bytes_allocated`, `peak_bytes`, `allocation_failures`, `internal_fragmentation_ratio`.
- Quota policy integration:
  - allocator receives `memory_bytes_budget`,
  - on budget breach emits deterministic quota failure and no partial allocation commit.

---

## 3) Initialization

1. Validate IR, shapes, roles, execution_order vs mode.
2. `live_ranges â† AnalyzeLiveness_v1(ir_dag, execution_order, mode)`
3. Classify tensors into arenas based on role/mode.

---

## 4) Operator Manifest

Active operators:
- `UML_OS.TMMU.PrepareMemory_v2`
- `UML_OS.Model.AnalyzeLiveness_v1`
- `UML_OS.TMMU.AssignLogicalSlots_v1`
- `UML_OS.TMMU.MapToVirtualAddresses_v1`
- `UML_OS.TMMU.ZeroTensor_v1`
- `UML_OS.TMMU.DebugFillTensor_v1`
- `UML_OS.TMMU.CommitExecution_v1`
- `UML_OS.Error.Emit_v1`

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

**Operator:** `UML_OS.TMMU.PrepareMemory_v2`  
**Category:** Memory  
**Signature:** `(ir_dag, execution_order, mode, replay_token, arena_config â†’ tensor_map, metrics)`  
**Purity class:** STATEFUL  
**Determinism:** Fully deterministic  
**Definition:** Compatibility wrapper orchestrating `PlanMemory_v2` (PURE) and `ApplyPlan_v1` (STATEFUL) with identical observable outputs to legacy callers.
**Preconditions / Postconditions:** valid IR and arena config; returns deterministic tensor_map/metrics with zeroed handles.  
**Edge cases:** tiny graphs, near-capacity arenas, mixed-role tensors.  
**Numerical considerations:** integer-only offset/address arithmetic with overflow checks.  
**Ordering/tie handling:** birth-time ascending, size-desc tie-break, lowest-slot-first assignment.  
**Complexity note:** O(N log N) worst-case (N=tensors).  
**Failure behavior:** abort with 0.K allocator codes.  
**Dependencies:** PlanMemory_v2, ApplyPlan_v1, AnalyzeLiveness_v1, AssignLogicalSlots_v1, MapToVirtualAddresses_v1, ZeroTensor_v1, CommitExecution_v1.  

**Operator:** `UML_OS.TMMU.PlanMemory_v2`
**Category:** Memory
**Signature:** `(ir_dag, execution_order, mode, arena_config -> tmmu_plan, metrics)`
**Purity class:** PURE
**Determinism:** Fully deterministic
**Definition:** Builds tensor interval set from IR outputs/inputs/persistent buffers, computes births/deaths from execution order, and emits deterministic slot/offset plan with plan hash.

**Operator:** `UML_OS.TMMU.ApplyPlan_v1`
**Category:** Memory
**Signature:** `(tmmu_plan, runtime_arena_handles -> tensor_map, metrics, tmmu_state')`
**Purity class:** STATEFUL
**Determinism:** deterministic
**Definition:** Applies logical `(arena_id, offset_bytes)` plan to runtime pointers, performs zero/fill operations, and commits allocator state.
**Test vectors:** see VII.B chain/residual/large-model slot maps.

**Operator:** `UML_OS.Model.AnalyzeLiveness_v1`  
**Category:** Model  
**Signature:** `(ir_dag, execution_order, mode â†’ live_ranges)`  
**Purity class:** PURE  
**Definition:** Linear pass; backward extends activation lifetimes until gradient use.
If `saved_for_backward=true`, death time is extended through the last backward consumer of the saved tensor/view.
**Preconditions / Postconditions:** valid execution_order and IR references; returns complete live intervals for all tensors.  
**Edge cases:** branched DAG fan-out/fan-in and backward retention boundaries.  
**Numerical considerations:** N/A (graph interval computation).  
**Ordering/tie handling:** deterministic node traversal order.  
**Complexity note:** O(|nodes| + |edges|).  
**Failure behavior:** abort on malformed IR references.  
**Dependencies:** UML_Model_IR schema.  
**Test vectors:** known DAGs with expected intervals.

**Operator:** `UML_OS.TMMU.AssignLogicalSlots_v1` (new)  
**Category:** Memory  
**Signature:** `(live_ranges, arena_config -> logical_slot_assignment: dict[tensor_id -> (arena, logical_slot_id)], slot_size_map: dict[(arena, logical_slot_id) -> uint64], slot_alignment_map: dict[(arena, logical_slot_id) -> uint64])`  
**Purity class:** PURE  
**Definition:** Optimal greedy linear-scan on interval graph per arena (optimal slot count). Each logical slot backing is sized to max tensor assigned to it and emits deterministic `slot_size_map` / `slot_alignment_map` required by virtual mapping.
**Preconditions / Postconditions:** intervals are valid and non-negative; output has no overlapping intervals per slot.  
**Edge cases:** equal birth/death times and sparse arenas.  
**Numerical considerations:** integer interval endpoints only.  
**Ordering/tie handling:** deterministic tie-breaks by birth then size then tensor_id.  
**Complexity note:** O(N log N).  
**Failure behavior:** abort on invalid interval data.  
**Dependencies:** live-range analyzer and arena config.  
**Test vectors:** interval-coloring optimality cases.
**Policy note:** slot-count optimality does not guarantee globally minimal physical bytes under heterogeneous tensor sizes; first-fit deterministic policy may leave additional fragmentation, which is tracked by `internal_fragmentation_ratio`.

**Operator:** `UML_OS.TMMU.MapToVirtualAddresses_v1` (new)  
**Category:** Memory  
**Signature:** `(logical_slot_assignment, arena_config, slot_size_map, slot_alignment_map -> logical_map)`  
**Purity class:** PURE  
**Definition:** For each arena independently, sort slots by `logical_slot_id` ascending and compute aligned offsets by prefix sum: `offset_0=0`, `offset_{k+1}=align_up(offset_k + slot_size_k, align_{k+1})`, where `align_k = max(slot_alignment_map[arena, slot_k], arena_config[arena].alignment_bytes)`. If `slot_alignment_map` entry is missing, default alignment is `arena_config[arena].alignment_bytes`. Emit logical addresses as `(arena_id, offset_bytes)`; runtime resolves to physical pointers out-of-band.
**Preconditions / Postconditions:** logical slots assigned; output addresses unique per `(arena, slot)`.  
**Edge cases:** large slot cardinality and arena name collisions (disallowed).  
**Numerical considerations:** uint64 offset arithmetic with overflow checks; no hash truncation/collision path.  
**Ordering/tie handling:** deterministic map key order for serialization.  
**Complexity note:** O(slots).  
**Failure behavior:** abort on arena overflow or alignment violation.  
**Dependencies:** deterministic ordering and arena config.  
**Test vectors:** fixed arena config + slot maps -> exact logical map.

**Operator:** `UML_OS.TMMU.ZeroTensor_v1`  
**Category:** Memory  
**Signature:** `(logical_address, size_bytes -> ok)` (driver primitive)  
**Purity class:** STATEFUL  
**Definition:** Deterministic zero-fill.
**Preconditions / Postconditions:** address is valid and writable; tensor contents are zeroed.  
**Edge cases:** repeated zeroing and page boundary segments.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** called in deterministic tensor-map order.  
**Complexity note:** O(size of tensor backing).  
**Failure behavior:** abort on invalid address/write failure.  
**Dependencies:** driver memory primitive.  
**Test vectors:** zero verification across varied tensor sizes.

**Operator:** `UML_OS.TMMU.DebugFillTensor_v1`  
**Category:** Memory  
**Signature:** `(logical_address, pattern_seed -> ok)`  
**Purity class:** STATEFUL  
**Definition:** Deterministic debug pattern fill for allocator diagnostics only.
**Preconditions / Postconditions:** allowed only in non-confidential and non-regulated modes.  
**Edge cases:** repeated fill operations.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** deterministic tensor-map order.  
**Complexity note:** O(size of tensor backing).  
**Failure behavior:** abort on invalid address/mode violation.  
**Dependencies:** driver memory primitive and execution mode.

**Operator:** `UML_OS.TMMU.CommitExecution_v1`  
**Category:** Memory  
**Signature:** `(() -> tmmu_state')`  
**Purity class:** STATEFUL  
**Definition:** Executes deterministic synchronization barriers, commits arena visibility state for downstream consumers, and seals per-batch memory metadata for replay/audit consistency.
**Preconditions / Postconditions:** pending memory operations completed; committed state is durable for next stage.  
**Edge cases:** no-op batch and single-arena execution.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** deterministic barrier ordering across arenas.  
**Complexity note:** O(number of active arenas).  
**Failure behavior:** abort on synchronization failure.  
**Dependencies:** runtime barrier and allocator metadata state.  
**Test vectors:** repeated commit idempotence and deterministic state hash.

---

## 6) Procedure

```text
1. live_ranges â† AnalyzeLiveness_v1(ir_dag, execution_order, mode)
   # Mode-aware lifetime extension for backward activations/gradients

2. logical_slots, slot_size_map, slot_alignment_map â† AssignLogicalSlots_v1(live_ranges, arena_config)
   # Per-arena linear-scan (optimal for interval graphs):
   #   - Sort tensors by birth time, then size descending
   #   - Maintain active_slots set (bitset or min-heap of used slots)
   #   - For each tensor: expire ended slots, assign lowest unused logical_slot
   #   - Emit slot_size_map[(arena, slot)] = max(required_tensor_bytes for tensors in slot)
   #   - Emit slot_alignment_map[(arena, slot)] = max(required_tensor_alignment, arena_config[arena].alignment_bytes)

3. logical_map â† MapToVirtualAddresses_v1(logical_slots, arena_config, slot_size_map, slot_alignment_map)
   # Per arena: deterministic slot order by logical_slot_id
   # offset_0 = 0
   # offset_{k+1} = align_up(offset_k + slot_size_k, align_{k+1})
   # va(slot_k) = arena_base[arena] + offset_k

4. tensor_map â† {}
   tensor_intervals_sorted â† tensors sorted deterministically by `tensor_id` ascending
   for tensor in tensor_intervals_sorted:   # tensors, not nodes
       (arena, slot) â† logical_slots[tensor.id]
       logical_addr â† logical_map[(arena, slot)]  # (arena_id, offset_bytes)
       size â† compute_bytes(tensor.shape, tensor.dtype)
       tensor_map[tensor.id] â† {logical_address: logical_addr, arena, logical_slot: slot, size, lifetime: live_ranges[tensor.id], alignment: arena_config[arena].alignment}

5. for each tensor in tensor_map:
       ZeroTensor_v1(tensor_map[tensor_id].logical_address, tensor_map[tensor_id].size)
       # DebugFillTensor_v1 is optional and forbidden in confidential/regulated modes.

6. metrics â† ComputeMetrics(live_ranges, logical_slots, logical_map)
   # Includes per-arena peak, reuse_ratio = 1 - (slots_used / total_tensors), fragmentation

7. tmmu_state' â† CommitExecution_v1()
8. return tensor_map, metrics
```

**Scalability & Algorithmic Guarantees (upgraded):**
- Time: O(N log N) worst-case with heap/interval-tree for active set (N = #tensors)
- Space: O(max live) 
- Mathematical optimality: #logical_slots = max live tensors per arena (interval graphs are perfect â†’ greedy coloring is exact)
- This optimality applies to slot count only; total allocated bytes after slot sizing/alignment are heuristic and may be suboptimal.
- Memory reuse ratio typically >95% on transformer graphs
- Physical-byte optimality is not guaranteed for heterogeneous sizes under first-fit; this is an explicit tradeoff for deterministic reproducibility and slot optimality.
- Supports 100B+ models via compact per-slot backing + huge virtual address space (2^48+)
- Alignment & padding enforced per arena
- Future-proof: easy extension to remat, paging, size-class bucketing

---

## 7) Trace & Metrics

### Logging rule
Each allocation run emits deterministic per-tensor allocation records and one deterministic summary record.

### Trace schema
- `allocation_header`: ir_hash, mode, replay_token_prefix, per-arena config
- `tensor`: tensor_id, arena, logical_slot, logical_address, size, live_range, bytes
- `summary`: peak_bytes_per_arena, total_logical_slots, reuse_ratio, fragmentation_pct

### Metric schema
- `peak_tmmu_usage_per_arena`, `memory_reuse_ratio`, `activation_retention_ratio`, `allocation_time_ns`, `max_live`, `internal_fragmentation_ratio`

### Comparability guarantee
Two allocation runs are comparable iff `ir_hash`, arena config, replay token context, trace schema, and metric schema are identical.

---

## 8) Validation

#### VII.A Lint rules (mandatory)
- All tensors aligned and slotted without live overlap.
- #slots == max live per arena.
- Backward lifetimes correctly extended.
- Logical-address uniqueness & determinism.

#### VII.B Operator test vectors (mandatory)
- Linear chain â†’ perfect reuse (1 slot)
- Residual blocks â†’ optimal coloring
- GPT-2 / Llama-scale â†’ high reuse + alignment validation

#### VII.C Golden traces (mandatory)
- Match reference Python simulator (E0) for all presets/modes/seeds.

---

## 9) Refactor & Equivalence

#### VIII.A Equivalence levels
- **E0** required for any change to liveness, slot assignment, or logical-address computation.
- **E1** allowed for heuristics (e.g., sorting order).

#### VIII.B Allowed refactor categories
- Graph-coloring variants, ILP solver (if E0 preserved), rematerialization planner, hierarchical arenas.

#### VIII.C Equivalence test procedure (mandatory)
- Identical logical addresses, logical slots, and live sets on golden graphs (10 seeds Ã— all presets Ã— 3 modes).

---

## 10) Checkpoint/Restore

### Checkpoint contents
- logical_slot_assignment + live_ranges + metrics (compact).

### Serialization
- CBOR, deterministic ordering (sorted by node_id).

### Restore semantics
- Same replay_token â†’ identical layout.
- Physical backing re-mappable by driver.

### Dynamic/Alias Policy
- IR must declare:
  - `alias_group_id` for shared-storage views,
  - `must_not_alias` constraints,
  - `in_place_write` markers extending live ranges,
  - `saved_for_backward` markers.
- Replan key: `(shape_envelope_hash, mode, arena_config_hash)`; if runtime shape exits envelope, deterministic replan is required and logged.

FILE: layer2-specs/Trace-Sidecar.md
===================================
# UML_OS Trace Sidecar Schema
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Trace.SidecarSchema_v1`  
**Purpose (1 sentence):** Define a canonical machine-readable trace schema shared by all UML_OS components.  
**Spec Version:** `UML_OS.Trace.SidecarSchema_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Trace interoperability and comparability.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Trace.SidecarSchema_v1`
- **Purpose (1 sentence):** Canonical trace schema contract.
- **Spec Version:** `UML_OS.Trace.SidecarSchema_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Unified trace format.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize trace ambiguity and schema drift.
### 0.B Reproducibility Contract
- Replayable given `(schema_version, trace_final_hash, replay_token_formula)`.
### 0.C Numeric Policy
- Field types are explicit; numeric fields use declared scalar kinds.
### 0.D Ordering and Tie-Break Policy
- Canonical record order:
  - `RUN_HEADER` is always first,
  - `ITER` records are sorted by `(t, rank, operator_seq)`,
  - `RUN_END` is always last.
### 0.E Parallel, Concurrency, and Reduction Policy
- Multi-rank traces merged in one canonical total order: `(t, rank, operator_seq)`.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for schema and required key set.
### 0.G Operator Manifest
- `UML_OS.Trace.ValidateSchema_v1`
- `UML_OS.Trace.NormalizeRecord_v1`
- `UML_OS.Trace.ComputeTraceHash_v1`
### 0.H Namespacing and Packaging
- Namespaced schema keys required.
### 0.I Outputs and Metric Schema
- Outputs: `(normalized_trace, trace_final_hash)`.
- Metrics: `record_count`, `missing_required_keys`.
- Completion status: `success | failed`.
### 0.J Spec Lifecycle Governance
- Required-key changes are MAJOR.
### 0.K Failure and Error Semantics
- Abort on schema violations in strict mode.
### 0.L Input/Data Provenance
- Trace source component and replay context required.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.


## 2) System Model
### I.A Persistent State
- trace schema registry.
### I.B Inputs and Hyperparameters
- raw trace stream and schema version.
### I.C Constraints and Feasible Set
- valid iff required keys/types are present.
### I.D Transient Variables
- normalized records and diagnostics.
### I.E Invariants and Assertions
- key set and type contract invariant.

### II.F Canonical Trace Schema (Concrete)
- Hash algorithms:
  - `record_hash_i = SHA-256(CBOR_CANONICAL(normalized_record_i))`
  - Whole-run hash chain:
    - `h_0 = SHA-256(CBOR_CANONICAL(["trace_chain_v1"]))`
    - `h_i = SHA-256(CBOR_CANONICAL(["trace_chain_v1", h_{i-1}, record_hash_i]))` for records in canonical order
    - `trace_final_hash = h_last`
- Trace endpoints:
  - `trace_head_hash = h_0`
  - `trace_final_hash = h_last`
- Self-reference rule: when hashing the `run_end` record, `run_end.trace_final_hash` is omitted from the canonical CBOR map input.
- Empty-bytes substitution is forbidden for omitted fields in canonical hashing paths.
- Canonical serialization: `CBOR_CANONICAL` from `docs/layer1-foundation/Canonical-CBOR-Profile.md`.
- `TraceRecord` union (normative):
  - `kind: enum("RUN_HEADER","ITER","POLICY_GATE_VERDICT","CHECKPOINT_COMMIT","CERTIFICATE_INPUTS","RUN_END","ERROR")`.
- Required `RUN_HEADER` fields/types: `kind:"RUN_HEADER"`, `schema_version:string`, `replay_token:bytes32`, `run_id:string`, `tenant_id:string`, `task_type:string`, `world_size:uint32`, `backend_binary_hash:bytes32`, `driver_runtime_fingerprint_hash:bytes32`, `policy_bundle_hash:bytes32`, `monitor_policy_hash:bytes32`, `operator_contracts_root_hash:bytes32`, `redaction_mode:string`, `redaction_key_id?:string`, `redaction_policy_hash?:bytes32`, `hash_gate_M:uint64`, `hash_gate_K:uint64`.
- Optional `run_header` fields/types: `authz_decision_hash?:bytes32`.
- Required `ITER` fields/types: `t:uint64`, `stage_id:string`, `operator_id:string`, `operator_seq:uint64`, `rank:uint32`, `status:string`, `replay_token:bytes32`.
- `operator_seq` is a per-step, per-rank monotone counter:
  - initialize `operator_seq=0` at the start of each `(t, rank)` step scope,
  - increment by 1 for each operator invocation in execution order.
- Uniqueness invariant: there must be at most one `ITER` record for each `(t, rank, operator_seq)` tuple.
- Optional `ITER` fields/types: `loss_total:float64`, `grad_norm:float64`, `state_fp:bytes32`, `functional_fp:bytes32`, `rng_offset_before:uint64`, `rng_offset_after:uint64`.
- Optional `ITER` fields/types: `resource_ledger_hash:bytes32`, `quota_decision:string`, `quota_policy_hash:bytes32`.
  - `resource_ledger_hash = SHA-256(CBOR_CANONICAL(resource_ledger_map))` with deterministic key order.
- Optional `ITER` fields/types: `tracking_event_type:string`, `artifact_id:string`, `metric_name:string`, `metric_value:float64`, `window_id:string`.
- Required `POLICY_GATE_VERDICT` fields/types: `t:uint64`, `policy_gate_hash:bytes32`, `transcript_hash:bytes32`.
  - `transcript_hash = SHA-256(CBOR_CANONICAL(policy_transcript))` where `policy_transcript` is the canonical ordered transcript as defined by the active policy-gate contract (for monitoring gates, see `docs/layer2-specs/Monitoring-Policy.md` II.G).
- Required `CHECKPOINT_COMMIT` fields/types: `t:uint64`, `checkpoint_hash:bytes32`, `checkpoint_header_hash:bytes32`, `checkpoint_merkle_root:bytes32`, `trace_snapshot_hash:bytes32`.
- Required `CERTIFICATE_INPUTS` fields/types: `t:uint64`, `certificate_inputs_hash:bytes32`.
  - `certificate_inputs_hash = SHA-256(CBOR_CANONICAL(certificate_inputs_bundle))` where `certificate_inputs_bundle` is the canonical evidence bundle passed to certificate build/sign flow.
- Required `RUN_END` fields/types: `status:string`, `final_state_fp:bytes32`, `trace_final_hash:bytes32`.
- Required `ERROR` fields/types: `t:uint64`, `failure_code:string`, `failure_operator:string`, `diagnostics_hash:bytes32`.
- Migration controls:
  - `migration_supported_from: array<string>`
  - `migration_operator: string`
  - `migration_invariants: array<string>`

### II.G Privacy Classification and Redaction Contract
- Field classification labels: `PUBLIC | INTERNAL | CONFIDENTIAL`.
- Field-level baseline classes:
  - `PUBLIC`: `t`, `operator_id`, `operator_seq`, hash digests, status.
  - `INTERNAL`: driver/runtime fingerprints, backend/hash metadata.
  - `CONFIDENTIAL`: any value that can leak sample/model-sensitive properties.
- No-raw-data rule: traces must not contain raw examples, prompts, gradients, secrets, or direct identifiers.
- Confidential-mode redaction: sensitive values must be replaced by deterministic keyed hashes (`HMAC-SHA256`) with declared key identifier, as defined in `docs/layer1-foundation/Redaction-Policy.md`.
  - Redacted value encoding (normative): store full HMAC output as `bytes32`.
- Size and sampling controls: deterministic per-operator caps and sampling policy must be declared to bound trace overhead.
- Deterministic size/sampling controls:
  - `max_bytes_per_step:uint64`
  - `max_record_bytes:uint32`
  - `sample_policy: enum("HASH_GATED","FIXED_RATE","OFF")`
  - defaults for `HASH_GATED`: `hash_gate_M=100`, `hash_gate_K=1`.
  - HASH_GATED inclusion rule: include iff `U64_BE(SHA-256(CBOR_CANONICAL([replay_token, t, operator_seq]))) mod hash_gate_M < hash_gate_K`.
  - Invariant: `0 <= hash_gate_K <= hash_gate_M` and `hash_gate_M > 0`.
  - Validation requirement: `UML_OS.Trace.ValidateSchema_v1` MUST enforce `hash_gate_M > 0` and `hash_gate_K <= hash_gate_M`; violation is deterministic schema failure.
  - Cap overflow drop policy: `DROP_LOWEST_PRIORITY_CLASS_FIRST` with fixed priority ordering:
    - `RUN_HEADER` > `ERROR` > `POLICY_GATE_VERDICT` > `CHECKPOINT_COMMIT` > `CERTIFICATE_INPUTS` > `RUN_END` > `ITER`.
  - `mandatory_record_kinds = {"RUN_HEADER","POLICY_GATE_VERDICT","CHECKPOINT_COMMIT","CERTIFICATE_INPUTS","RUN_END","ERROR"}`.
  - Mandatory records MUST NEVER be sampled out or dropped.
  - If caps force dropping mandatory records: emit `TRACE_CAP_EXCEEDED_MANDATORY` and abort deterministically.

### II.H Policy Transcript and Run Commit Binding (Normative)
- Policy evaluation must emit a deterministic transcript record stream containing:
  - `policy_input_hashes`, `rule_id`, `rule_version`, `verdict`, `reason_code`.
- Network reads during policy evaluation are forbidden unless inputs are pre-committed and referenced by hash.
- Transcript fold hash:
  - `policy_gate_hash = SHA-256(CBOR_CANONICAL(["policy_transcript_v1", ordered_policy_records]))`.
- `policy_gate_hash` must appear in trace mandatory records and in `Execution-Certificate` signed payload.
- Atomic commit linkage:
  - trace must include `run_commit_prepare` and `run_commit_record` mandatory records,
  - `run_commit_record` must bind `trace_final_hash`, `checkpoint_hash`, `lineage_root_hash`, `certificate_hash`.
- Naming normalization:
  - `trace_final_hash` is the canonical commitment name for this linear hash-chain model (`h_last`).

---
## 3) Initialization
1. Load schema version.
2. Validate required keys.
3. Initialize normalization pipeline.

---
## 4) Operator Manifest
- `UML_OS.Trace.ValidateSchema_v1`
- `UML_OS.Trace.NormalizeRecord_v1`
- `UML_OS.Trace.ComputeTraceHash_v1`

---
## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

Template conformance note (III.A): each operator definition in this section is interpreted with the full EQC operator template fields. When a field is not repeated inline, the section-level defaults are: explicit typed signatures, deterministic ordering/tie handling, declared numerical policy inheritance, deterministic failure semantics (0.K), explicit dependencies, and VII.B test-vector coverage.

**Operator:** `UML_OS.Trace.ValidateSchema_v1`  
**Category:** IO  
**Signature:** `(trace, schema -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** required key/type validation.

**Operator:** `UML_OS.Trace.NormalizeRecord_v1`  
**Category:** IO  
**Signature:** `(record -> normalized_record)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** canonical key order and value normalization.

**Operator:** `UML_OS.Trace.ComputeTraceHash_v1`  
**Category:** IO  
**Signature:** `(normalized_trace -> trace_final_hash)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** computes per-record SHA-256 hashes and folds them with the `trace_chain_v1` hash-chain rule to emit the whole-run `trace_final_hash`.

---
## 6) Procedure
```text
1. ValidateSchema_v1
2. NormalizeRecord_v1 for each record
3. ComputeTraceHash_v1
4. Return normalized_trace + hash
```

---
## 7) Trace & Metrics
### Logging rule
Trace schema validation itself emits deterministic validation records.
### Trace schema
- `run_header`: schema_version, source_component
- `iter`: t, operator, validation_status
- `run_end`: trace_final_hash, status
### Metric schema
- `record_count`, `missing_required_keys`
### Comparability guarantee
Comparable iff schema version, key set, and hash formula are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
Passes schema completeness, deterministic ordering, no hidden globals.
#### VII.B Operator test vectors (mandatory)
Valid/invalid trace fixtures.
#### VII.C Golden traces (mandatory)
Golden trace hashes for canonical samples.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for normalized trace and hash.
#### VIII.B Allowed refactor categories
- parser/normalizer optimization preserving outputs.
#### VIII.C Equivalence test procedure (mandatory)
Exact normalized record and hash comparison.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- schema version and normalization state.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- resumed validation yields identical outputs.

---
## 11) Observability Bridge Mapping (Normative)
- UML_OS trace/metrics MUST support deterministic export mapping to OpenTelemetry and Prometheus conventions.
- Minimum mapping requirements:
  - `run_header.run_id` -> OTel trace resource attribute `uml_os.run_id`.
  - `iter.operator` -> OTel span attribute `uml_os.operator_id`.
  - `iter.t` -> OTel span attribute `uml_os.step`.
  - `trace_final_hash` -> OTel trace attribute `uml_os.trace_final_hash`.
  - deterministic metric names map to Prometheus-safe snake_case names with fixed units.
- Export mapping identity:
  - `observability_mapping_hash = SHA-256(CBOR_CANONICAL(mapping_table_v1))`.
- Determinism requirement:
  - identical UML_OS trace input MUST produce identical OTel/Prometheus export payloads and identical `observability_mapping_hash`.
- Reference implementation location:
  - `docs/layer4-implementation/Interoperability-Standards-Bridge.md`.

FILE: layer2-specs/UML_OS-Kernel-v3.22-OS.md
============================================
# Universal Machine Learning Operating System (UML_OS) v3.22-OS
**EQC Compliance:** This specification follows the merged single-file format of EquationCode (EQC) v1.1 (Option A) with the required 10 top-level sections and all mandatory invariants (global semantics first, control-flow-only procedure, versioned operators, purity/RNG contracts, total state updates, trace schema, equivalence levels, lint rules, checkpoint replay guarantees).

**Algorithm:** Deterministic training OS kernel with operator contracts, namespace isolation, and hardware attestation.  
**Purpose (1 sentence):** Execute declarative machine learning training, evaluation, inference, and confidential operations under contract-enforced determinism, namespace isolation, hardware-rooted attestation, and verifiable provenance.  
**Spec Version:** UML_OS-v3.22-OS | 2026-02-17 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Reproducible neural-network training, evaluation, inference, and confidential lifecycle management.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** Deterministic training OS kernel with operator contracts, namespace isolation, and hardware attestation.
- **Purpose (1 sentence):** Execute declarative machine learning training, evaluation, inference, and confidential operations under contract-enforced determinism, namespace isolation, hardware-rooted attestation, and verifiable provenance.
- **Spec Version:** UML_OS-v3.22-OS | 2026-02-17 | Authors: Olejar Damir
- **Domain / Problem Class:** Reproducible neural-network training, evaluation, inference, and confidential lifecycle management.

### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: `a â‰¼ b â‡” a â‰¤ b + EPS_EQ`
- `EPS_EQ = 1e-10` (float64)
- Invalid objective policy: NaN/Â±Inf ranked as `+Inf`; mark `INVALID_OBJECTIVE`; do not apply update; emit deterministic failure record; abort (0.K).

### 0.B Reproducibility Contract
- Default reproducibility class: `R1 (statistical)`
- `R0` only for reference single-process CPU golden traces
- Seed space: `seed âˆˆ {0..2^64-1}`
- PRNG family: Philox4x32-10
- Single master stream with fixed sub-stream offsets: `init`, `cluster`, `misc`
- Randomness locality: all sampling occurs **only inside operators**
- Replay guarantee: replayable given `(seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy)`
- Replay token: `replay_token = SHA-256(CBOR_CANONICAL(["replay_token_v1", spec_version, policy_bundle_hash, env_manifest_hash, operator_contracts_root_hash, determinism_profile_hash, driver_runtime_fingerprint_hash, uint64(seed)]))`
- `env_manifest_hash` is defined normatively in `docs/layer1-foundation/Environment-Manifest.md` (`runtime_env_hash` alias allowed in checkpoint contracts).
- Replay context must also bind:
  - `sampler_config_hash`,
  - `tmmu_plan_hash`,
  - `dp_accountant_state_hash`,
  - `operator_contracts_root_hash`,
  - `determinism_profile_hash`,
  - backend runtime fingerprint.
- Canonical hash/input encoding rule (global): all hash inputs are domain-separated CBOR arrays; strings encoded UTF-8; integers encoded as unsigned big-endian logical values via CBOR major type.
- Hash primitives policy (global, normative):
  - contract-critical digests MUST use `SHA-256(CBOR_CANONICAL(...))`,
  - domain-separation tag is required as first CBOR array element,
  - digest slicing (e.g., `[0:16]`) must use leftmost bytes,
  - digest-to-uint conversion uses big-endian interpretation.

### 0.C Numeric Policy
- Core arithmetic (loss, metrics, termination, fingerprints, gradient norms, DP accounting, critical reductions): IEEE-754 binary64 with deterministic ascending-index order and EPS guards.
- Model parameters, optimizer state, intermediates, non-critical computations: manifest.compute_dtype (float32 default).
- Critical reductions and fingerprints: binary64, deterministic ascending-index order
- All reductions (including all-reduce, gradient norm, loss summation) use Kahan compensated summation or pairwise tree reduction in binary64 with fixed ascending-index order; E0 bitwise guarantees apply within a fixed `(world_size, collective algorithm, rank order, driver build, math flags)` equivalence class.
- Rounding mode: round-to-nearest ties-to-even
- Fast-math: forbidden
- Constants: `EPS_EQ = 1e-10`, `EPS_DENOM = 1e-12`, `EPS_PROB = 1e-15`
- Clamps: `exp` argument `[-80, 80]`; denominator `max(den, EPS_DENOM)`; probabilities `[EPS_PROB, 1]` then renormalize
- NaN/Inf policy: NaN/Â±Inf ranked as `+Inf` (see 0.A); abort per 0.K on critical paths
- Normalized exponentials: stable log-sum-exp required in all softmax / log-probability paths
- Approx-equality: `a â‰ˆ b` iff `|a - b| â‰¤ EPS_EQ`
- Counter overflow policy: `t`, `current_step`, `operator_seq`, and all uint64 counters MUST fail-fast on overflow (`COUNTER_OVERFLOW`); wraparound is forbidden.

### 0.D Ordering and Tie-Break Policy
- Index base: `0-based`
- Stable sort required
- Ties: lowest index wins
- Fixed action order: `["optimize", "eval", "infer", "switch"]`

### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel reductions: fixed 256-element chunks in ascending global index
- Rank aggregation: ascending rank order
- `world_size > 1` requires deterministic collectives and fixed ordering
- Collective algorithm rule (normative): ring all-reduce with ascending-rank send/recv order and fixed chunk partitioning; reduction accumulation uses binary64 Kahan summation in deterministic chunk order.

### 0.F Environment and Dependency Policy
- Each backend driver (loaded via `UML_OS.Backend.LoadDriver_v1`) must implement deterministic forward/backward passes with fixed ascending-index reduction order, deterministic collectives (all-reduce, broadcast) using ascending-rank ring topology, RNG forwarding from kernel master streams with declared offsets, exact operator contracts for all dispatched primitives, and must pass the mandatory ReproducibilityTest suite. The suite requires E0 equivalence within a declared backend/hardware equivalence class (same build/profile), and E1 vs certified CPU reference on larger workloads. Driver verification (including binary/manifest hash check) is mandatory inside `Contract.Validate_v1` before any dispatch.
- Driver interface contract (mandatory for LoadDriver_v1): Implements Forward_v2/Backward_v1/Inference.RunBatch_v1 on UML_Model_IR DAG using only deterministic primitives; no exposed user-callable loops; supports memory-zeroing hooks, TMMU allocation/liveness hints, and TEE quote collection; declares exact op-to-primitive mapping. Passes mandatory ReproducibilityTest suite (E0 on tiny graphs vs certified CPU reference in binary64; E1 on larger workloads) before dispatch. In regulated mode only drivers from the configured signed registry are accepted.
- Determinism level: `BITWISE` for critical observables (`loss_total`, `grad_norm`, fingerprints, `state_fp`) within a declared adapter/hardware equivalence class; `TOLERANCE` for raw model parameters.
- `state_fp` canonicalization rule: compute from quantized parameter view `q(theta)=round(theta*2^24)/2^24` in binary64 with fixed ordering, so tolerance-level parameter drift does not violate fingerprint comparability policy.

### 0.G Operator Manifest
Active operator wiring is declared in section `4) Operator Manifest`.

### 0.H Namespacing and Packaging
- Fully-qualified names: `UML_OS.<Category>.<Name>_v#`
- Sidecar mapping required: operator -> module/function
- Normative naming rule: all operators MUST match `UML_OS.<subsystem>.<name>_v<integer>`; flat operators are forbidden.

### 0.I Outputs and Metric Schema
- Declared outputs: `theta_final`, `trace`, `checkpoint`, `tape_digest`, `training_certificate`
- Minimum metric schema: `loss_total`, `grad_norm`, `functional_fp`
- Completion status: `success | terminated | failed` with deterministic reason codes.

### 0.J Spec Lifecycle Governance
Reproducibility-breaking changes require MAJOR bump (vX.Y.Z â†’ v(X+1).0.0).  
Deprecations replace via manifest wiring only.  
Equivalence target for any change: E1 (metric-equivalent) minimum, E0 (trace-equivalent) for kernel or attestation changes.  
Migration: update manifest operator versions and replay_token.

### 0.K Failure and Error Semantics
- Global error model: abort-only
- Final failure record includes: `t`, `failure_code`, `failure_operator`, `replay_token`, `rng_fingerprint_t`, `state_fp_t`

### 0.L Input/Data Provenance
- Dataset id/version/hash mandatory
- Strict parsing and immutable dataset registration mandatory

### 0.M Declarative Configuration
- YAML config mandatory input path
- Canonical JSON serialization before hashing

### 0.N Layered Operating-System Architecture
- Layer ordering:
  - Kernel (VI procedure + operator dispatch + contracts)
  - Driver (deterministic device primitives)
  - Runtime (pinned dependencies)
  - Module (verified operator packages)
  - Daemon (mandatory in managed, confidential, regulated modes or when UML_OS_ROOT shared or world_size > 1; optional/in-process in local): Central OS service layer. Owns immutable CAS at UML_OS_ROOT, deterministic scheduling (job_priority + FIFO + SHA-256(CBOR_CANONICAL(["daemon_sched_v1", manifest_hash, hardware_attest_id, job_id])) for reproducible allocation), launches isolated per-job process/Pod with namespace isolation (RNG/checkpoints/tapes/lineage plus persisted kernel namespace state) and explicit tensor.zero_() + sync barriers on every boundary, enforces quotas/RBAC/audits, coordinates TEE quotes and heterogeneous drivers. In local mode Bootstrap_v1 embeds equivalent in-process functionality (identical contracts, replay_token, fingerprints, certificate). Deployable as single binary or K8s operator. The daemon also registers the Tensor Memory Management Unit (TMMU) that exclusively owns and controls every tensor pointer across the job lifetime. Allocations, frees, device-to-device transfers and zeroing occur only via TMMU. Addressing is arena/offset based (injective deterministic layout) as delegated to `docs/layer2-specs/TMMU-Allocation.md` (`MapToVirtualAddresses_v1`) and versioned there. TMMU performs static liveness analysis on UML_Model_IR (shapes known) to enable deterministic slot reuse within safety margins; enforces tensor.zero_() + synchronization barriers on every stage, job, and namespace boundary for isolation; blocks any backend direct allocation for traced tensors and contract-critical buffers. This guarantees identical virtual address plans and deterministic layout decisions within a declared hardware/driver equivalence class.
  - Management (CLI entrypoints)
  - User (manifests only)
- Filesystem roots:
  - `/datasets/<id-version-hash>/`
  - `/namespaces/<tenant_id>/<run_id>/`
  - `/jobs/queue/`
- Namespace path: `/<tenant_id>/<run_id>` where `run_id = hex(SHA-256(CBOR_CANONICAL([tenant_id, replay_token]))[0:8])` (16 hex chars).
- `UML_OS_ROOT` is a required immutable run-scoped root URI/path (`file://`, `s3://`, `gcs://`, or absolute local path), fixed at daemon startup.

### 0.P Bootstrap
- Single entrypoint: `UML_OS.OS.Bootstrap_v1`
- Performs deterministic initialization, manifest/data validation, module wiring, distributed setup, and namespace entry

### 0.Q Global Manifest Additions
- `env_manifest_hash` includes `daemon_concurrency_max=16` and all required runtime fields from `docs/layer1-foundation/Environment-Manifest.md`.
- `spec_version: string`
- `tenant_id: string`
- `seed: uint64`
- `task_type`: `multiclass | binary | regression`
- `alpha` (default `1.0`)
- `execution_mode: "local" | "managed" | "confidential" | "regulated"` (default `managed`)
- `global_batch_size` (default `256`)
- `fingerprint_frequency`
- `optimizer` config
- `grad_clip_norm`
- `checkpoint_frequency`
- `job_priority` (1..10)
- `policy.rules` (optional runtime stage/action decision rules)
- `policy_bundle` (authoritative cryptographic policy commitment input; may coexist with `policy.rules`)
- `datasets: object` (keys = dataset_keys e.g. "train", "val", "test"; each value = `{id: string, version: string, hash: string}`)
- `data: {sampler_block_size?: integer (default 1048576)}`
- `custom_operators[]`
- `parallelism: {strategy: "none" | "ddp" | "fsdp" | "tensor_parallel" | "pipeline_parallel" | "hybrid", world_size_override?, sharding_config?: object}`
  - `world_size_override` semantics (normative): if provided, it MUST equal the actual initialized `world_size`; mismatch is deterministic failure (`CONTRACT_VIOLATION`).
- `manifest_inheritance: {parent_manifest_path?: string}` (resolved and merged by daemon in Bootstrap_v1; child may override only non-security fields; security parameters inherited strictly)
- `hardware_affinity: {gpu_ids?: array of int, cpu_cores?: array of int}` (optional; daemon pins for deterministic scheduling)
- `profile: "research" | "enterprise" | "regulated"` (Bootstrap_v1 expands to execution_mode-appropriate defaults for security, quotas, evaluation metrics, pipeline_stages, and pipeline checks). If pipeline_stages absent, default is: research = [{step_id:"train",type:"train"},{step_id:"eval",type:"eval",depends_on:["train"]}], enterprise = [{step_id:"train",type:"train"},{step_id:"eval",type:"eval",depends_on:["train"]},{step_id:"infer",type:"infer",depends_on:["eval"]}], regulated = same as enterprise plus DP-forced augment stage if augment_config present.
- `backend: "pytorch" | "jax" | "custom"` (default `"pytorch"`)
- `pipeline_stages: array` of objects `{step_id: string, type: "train"|"eval"|"infer"|"augment", manifest_path?: string, depends_on?: array of step_id, dataset_key?: string}`
- `resource_requests: {cpus: int, gpus: int, memory_gb: float} (global or per-stage in pipeline_stages objects; daemon scheduler enforces)`
- `memory_arena_config: object` (optional deterministic arena configuration for TMMU initialization/planning; per-arena entries may include `capacity_bytes`, `alignment_bytes`)
- `quota: {memory_bytes_budget?: uint64, gpu_time_ms_budget?: uint64, cpu_time_ms_budget?: uint64, io_bytes_budget?: uint64}` (optional runtime enforcement thresholds consumed by kernel resource_ledger checks)
- `resource_ledger_schema` (fixed): `{flops:uint64, bytes_allocated:uint64, peak_bytes:uint64, gpu_time_ns:uint64, cpu_time_ns:uint64}`; kernel updates counters each step by summing operator-declared resource contributions (declared in operator contract metadata; this version assumes fixed per-operator costs).
- `rbac: {principals: array, permissions: map}` (optional; daemon enforces on NamespaceEnter_v1 and critical ops).
- `storage: {backend: "local" | "s3-compatible" | "gcs", endpoint?: string, bucket?: string, credentials_secret?: string}` (daemon uses for all CAS reads/writes; credentials_secret resolved securely by daemon only)
- `monitoring_export: {prometheus_endpoint?: string, log_sink?: string}` (daemon pushes deterministic metrics, audit summaries, and usage records; optional)
- `rbac_source: "local" | "ldap" | "oidc"` (default "local"; daemon integrates for `NamespaceEnter_v1` and critical ops)
- `environment: {env_manifest_hash: bytes32, requirements_hash?: string (SHA-256 of canonical pinned dependency manifest), container_image?: string}`
- `daemon_mode: "standalone" | "cluster"` (default `"standalone"`)
- `distributed: {timeout_seconds: int (default 300)}`
- `fine_tune` config (`full` or `lora`)
- `evaluation` config
- `security: {attestation_required: bool, functional_commitment: bool (default false), differential_privacy: {enabled: bool (default false), target_epsilon: float (default 0.0)}}`
- `model` (`preset`/`preset_params`/`architecture`)
- `compute_dtype: "float32" | "float64"`
- `model.architecture` supports `type: "custom"`

Supported presets in `ExpandPreset_v1`: `mlp_classifier`, `basic_cnn`, `resnet18`, `resnet50`, `vit_tiny`, `bert_tiny`, `gpt2_small`. LoRA insertion is deterministic from checkpoint hash.
- `fingerprint_frequency` semantics (normative): `0` disables periodic fingerprints; otherwise fingerprints run when `t % fingerprint_frequency == 0`.
- Default dataset keys per stage (if `pipeline_stages[i].dataset_key` omitted): `train -> "train"`, `eval -> "val"`, `infer -> "test"`.

### 0.R Distributed and Multi-tenancy Policy
- Deterministic rank ordering and deterministic collective primitives
- `global_batch_size % world_size == 0` required for distributed runs
- Global batch sequence is world-size invariant by data contract; update values are E0 only within fixed distributed configuration and E1 across compatible re-shards; sharding remains contiguous rank-ordered after global deterministic permutation; collective order fixed by ascending rank.
- E0 distributed requirement: all ranks MUST report identical `driver_runtime_fingerprint_hash`; mismatch is deterministic failure (or explicit downgrade to non-E0 mode if policy allows).
- Per-rank RNG derivation (normative): `rank_rng_seed = SHA-256(CBOR_CANONICAL(["rank_rng_v1", replay_token, uint32(rank)]))`; each rank initializes its RNG master from this seed to avoid cross-rank stream collisions.
- In `daemon_mode=cluster`, all collectives respect manifest `distributed.timeout_seconds` (default 300); any timeout or communication error aborts deterministically with `DISTRIBUTED_COMMUNICATION_FAILURE` record (included in trace and certificate).
- Declared parallelism.strategy is implemented by the loaded driver under Contract.Validate_v1 and the ReproducibilityTest suite (sharding of model parameters and data consistent with NextBatch_v2 and UML_Model_IR node annotations). Hybrid strategies combine via manifest-defined stage or node partitioning.

### 0.S RNG Consumption Contract
- Every operator declares exact RNG draws and stream ownership
- Kernel checks declared-vs-actual offsets every call
- Violations abort with `RNG_CONSUMPTION_VIOLATION`

### 0.T Execution Model
- VI kernel procedure is the only conformant execution path

### 0.U Execution Contract
- All execution occurs exclusively through the VI kernel procedure in section 6 and registered, contract-validated operators/drivers. No user-provided training/evaluation/inference loops or direct backend calls permitted; manifest declares the complete computation graph. In managed/confidential/regulated modes, daemon and drivers sandbox execution: any non-registered library primitive call, unapproved import, or side effect triggers CONTRACT_VIOLATION abort with telemetry recorded in Contract.Validate_v1. Custom logic permitted only via RegisterCustom_v1 operators that pass full Contract.Validate_v1 (purity, RNG consumption, ordering, determinism, IR mapping). Violations abort with CONTRACT_VIOLATION.

### 0.V Operation Modes
- `local`: daemon optional, relaxed warnings mode
- `managed`: full enforcement, signed certificate required
- `confidential`: TEE launch + quote mandatory, full enforcement, signed certificate includes quote
- `regulated`: daemon mandatory; enforces exact differential-privacy accounting, immutable append-only audit trail, and electronic signatures. Launches inside hardware TEE if present. If Security.AttestTEE_v1 fails at any point, kernel issues immediate termination, executes deterministic best-effort zeroization hooks for owned memory regions, records zeroization evidence, and aborts. Full RNG auditing; produces signed provenance record.
- Legacy framework import rule: `UML_OS.Import.LegacyFramework_v1` is allowed only on SERVICE surface in `local`/`managed`; forbidden in `confidential`/`regulated`.

### 0.W CLI and Usability Requirements
- Required commands (prioritized entrypoints): `umlos quickstart [template: classification|regression|pipeline|regulated]` (creates minimal ready-to-run manifest.yaml + project layout + example pipeline under current dir; runnable in <10 s), `umlos run manifest.yaml`, `umlos validate`, `umlos doctor`, `umlos replay <token>`, `umlos certificate verify`, `umlos migrate <legacy_path> [options] --output-dir .` (analyzes common training scripts/notebooks, generates runnable UML_OS manifest.yaml + IR; runs Contract.Validate_v1 on result), plus `job submit`/`export`/`infer`/`namespace init`/`daemon start`/`dataset register`/`import`/`audit export`/`ps/logs/kill/queue`. All CLI paths perform full Contract.Validate_v1 + manifest validation before any action.

### 0.X Training Certificate Contract
- Certificate field-set is authoritative in `docs/layer2-specs/Execution-Certificate.md` only.
- Kernel and adapters MUST NOT add implicit certificate fields outside `docs/layer2-specs/Execution-Certificate.md` `signed_payload` and allowed `unsigned_metadata`.
- Daemon signs certificate using namespace ed25519 private key; `regulated` mode additionally applies declared electronic signatures.
- `augment_metadata` for each symbolic stage (if present)

### 0.Y UML_Model_IR
Neutral declarative ML-ISA (Instruction Set Architecture) used by all Model/* system calls and drivers.
- Nodes: array of `{node_id: string, instr: string (from mandatory base set: MATMUL, CONV2D, LAYERNORM, ATTENTION, RESIDUAL_ADD, GELU, SOFTMAX, etc.), params: dict, inputs: array of node_id or 'input_data', shape_in/out: tuple(s), grad_edges?: array<node_id>}`
- `grad_edges` (optional) declares explicit gradient dependency edges for backward scheduling; when absent, reverse forward order is used subject to executor equivalence checks.
- For parallel strategies nodes include optional sharding_spec resolved by driver into device placement.
- Execution: strict topological order (stable sort by node_id on ties).
- All presets expand to valid ML-ISA. Custom layers via RegisterCustom_v1 declare full instruction mapping.
- Drivers translate ML-ISA â†’ native executable under Contract.Validate_v1 (E0 within declared backend/hardware equivalence class; CPU reference used for E1 semantic checks).
- Canonical CBOR serialization (fixed field order) for all hashing.

### 0.Z Logging Contract (fulfills Block V.A)
`UML_OS.IO.WriteTape_v1` serves as the canonical `LogIteration` operator. Every iteration appends a structured trace record containing all required V.B fields (`t`, `state`, `action`, `loss_total`, `grad_norm`, `state_fp`, `functional_fp`, `replay_token`/fingerprint, etc.).

---

### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model

### I.A Persistent State
- `theta`
- `state âˆˆ {S_INIT, S_TRAINING, S_EVALUATING, S_TERMINATED}`
- `t`
- `replay_token`
- `run_id`
- `current_step`
- `loss_hist`
- `data_cursors: map<string, (epoch: int, global_index: int)>` (key = dataset_key).
- `rng_master_state` + offsets
- `dp_accountant_state`, `cumulative_epsilon`
- `tmmu_context`
- `operator_contracts_root_hash`
- `resource_ledger`
- `tape_state`

### I.B Inputs and Hyperparameters
All immutable inputs and hyperparameters are declared in the YAML manifest (see `0.Q Global Manifest Additions`). Key declared items: `global_batch_size`, optimizer config, `pipeline_stages`, `security.{attestation_required, differential_privacy}`, `compute_dtype`, and related runtime policy fields.

### I.C Constraints and Feasible Set
Unconstrained optimization problem. All runtime contracts (driver determinism, purity, RNG consumption, ordering) are enforced by `UML_OS.Contract.Validate_v1` and backend driver verification.

### I.D Transient Variables
- `batch`, `logits`, `L_tot`, `action`, `grads`, `noisy_grads`, `grad_norm`, `eval_result`, `outputs`
- Transients are iteration-local and cannot be referenced across iterations unless promoted into persistent state.

### I.E Invariants and Assertions
- Finite tensors
- Deterministic ordering
- Contract checks mandatory

### Architecture Overview (Document Wiring)
- Core execution specs: `docs/layer2-specs/Data-NextBatch.md`, `docs/layer2-specs/ModelIR-Executor.md`, `docs/layer2-specs/TMMU-Allocation.md`, `docs/layer2-specs/DifferentialPrivacy-Apply.md`.
- Interface and type contracts: `docs/layer1-foundation/API-Interfaces.md`, `docs/layer1-foundation/Data-Structures.md`, `docs/layer2-specs/Config-Schema.md`.
- Reliability and observability contracts: `docs/layer1-foundation/Error-Codes.md`, `docs/layer2-specs/Trace-Sidecar.md`, `docs/layer2-specs/Checkpoint-Schema.md`, `docs/layer2-specs/Replay-Determinism.md`.
- Delivery and compliance contracts: `docs/layer4-implementation/Backend-Adapter-Guide.md`, `docs/layer2-specs/Security-Compliance-Profile.md`, `docs/layer1-foundation/Dependency-Lock-Policy.md`, `docs/layer2-specs/Deployment-Runbook.md`.
- Planning and execution governance: `docs/layer4-implementation/Implementation-Roadmap.md`, `docs/layer4-implementation/Code-Generation-Mapping.md`, `docs/layer3-tests/Test-Plan.md`, `docs/layer3-tests/Performance-Plan.md`.
- Lifecycle and governance extensions: `docs/layer2-specs/Experiment-Tracking.md`, `docs/layer2-specs/Model-Registry.md`, `docs/layer2-specs/Monitoring-Policy.md`, `docs/layer2-specs/Evaluation-Harness.md`, `docs/layer2-specs/Data-Lineage.md`, `docs/layer2-specs/Pipeline-Orchestrator.md`, `docs/layer2-specs/Execution-Certificate.md`.
- Coding acceleration contracts: `docs/layer4-implementation/Reference-Implementations.md`, `docs/layer3-tests/Test-Vectors-Catalog.md`, `docs/layer4-implementation/Repo-Layout-and-Interfaces.md`.
- New contract subdocuments:
  - `docs/layer1-foundation/Operator-Registry-Schema.md` (authoritative registry schema),
  - `docs/layer1-foundation/Digest-Catalog.md` (digest label/value authority),
  - `docs/layer1-foundation/Canonical-CBOR-Profile.md` (single commitment serialization profile),
  - `docs/layer2-specs/Run-Commit-WAL.md` (atomic commit journal + recovery),
  - `AuthZ-Capability-Matrix.md` (operator capability policy),
  - `docs/layer1-foundation/Determinism-Profiles.md` (BITWISE/TOLERANCE runtime profiles).
- Wiring invariant: all operator names referenced across documents must be fully qualified and versioned. Shared operators may be imported by reference from dedicated contract documents (for example `UML_OS.Error.Emit_v1` in `docs/layer1-foundation/Error-Codes.md`).

### II.F Deterministic Runtime Governance (Normative)
- Distributed reduction determinism must follow declared `determinism_profile`:
  - `BITWISE` mode requires fixed collective algorithm, fixed chunk order, fixed accumulation dtype/order, and no nondeterministic atomics.
  - `TOLERANCE` mode requires explicit per-field tolerance bands and E1 comparability policy.
- Kernel must emit deterministic policy and authorization transcripts:
  - policy transcript hash `policy_gate_hash`,
  - authorization transcript hash `authz_decision_hash`.
- End-of-run artifacts must be finalized only through the atomic run commit protocol (`trace/checkpoint/lineage/certificate` two-phase commit).

---

## 3) Initialization

1. `t <- 0`
2. `persistent_state <- UML_OS.OS.Bootstrap_v1(manifest)`
3. `canonical_manifest <- UML_OS.Data.Manifest_v1(manifest)` then `UML_OS.Data.ValidateManifest_v1(canonical_manifest)`
4. `active_namespace <- UML_OS.OS.NamespaceEnter_v1(namespace_path)`
5. `driver <- UML_OS.Backend.LoadDriver_v1(manifest.backend)` then `dist_state <- UML_OS.Distributed.Setup_v1(...)`
6. `arena_config <- manifest.memory_arena_config or deterministic default policy` then `tmmu_context <- UML_OS.TMMU.Init_v1(ir_graph, "train", replay_token, arena_config)`
7. Initialize `theta` deterministically from manifest/seed contract
8. Initialize `state <- S_TRAINING`, `loss_hist`, `data_cursors`, tape, fingerprints, and RNG offsets
9. Run `UML_OS.Contract.Validate_v1(...)` before entering the main procedure loop

---

## 4) Operator Manifest

Active operators (exact wiring table):
- `UML_OS.OS.Bootstrap_v1`
- `UML_OS.OS.ResolvePath_v1`
- `UML_OS.OS.NamespaceEnter_v1`
- `UML_OS.Data.Manifest_v1`
- `UML_OS.Data.ValidateManifest_v1`
- `UML_OS.Data.NextBatch_v2`
- `UML_OS.Data.RegisterDataset_v1`
- `UML_OS.Data.ImportAndRegister_v1`
- `UML_OS.Model.Forward_v2`
- `UML_OS.Model.ExpandPreset_v1`
- `UML_OS.Model.ApplyFineTune_v1`
- `UML_OS.Objective.TotalLoss_v1`
- `UML_OS.Optimizer.Update_v1`
- `UML_OS.Module.RegisterCustom_v1`
- `UML_OS.Policy.Evaluate_v1`
- `UML_OS.Contract.Validate_v1`
- `UML_OS.IO.WriteTape_v1`
- `UML_OS.IO.SaveCheckpoint_v1`
- `UML_OS.Certificate.WriteExecutionCertificate_v1`
- `UML_OS.State.Journal_v1`
- `UML_OS.Termination.Check_v1`
- `UML_OS.Fingerprint.StateFingerprint_v1`
- `UML_OS.Fingerprint.Functional_v1`
- `UML_OS.Error.Emit_v1`
- `UML_OS.Distributed.Setup_v1`
- `UML_OS.Distributed.Barrier_v1`
- `UML_OS.Evaluation.Run_v1`
- `UML_OS.Security.AttestTEE_v1`
- `UML_OS.Verifiable.CommitFunctional_v1`
- `UML_OS.DifferentialPrivacy.Apply_v3`
- `UML_OS.Backend.LoadDriver_v1`
- `UML_OS.Pipeline.Dispatch_v1`
- `UML_OS.Config.DeterministicStageMerge_v1`
- `UML_OS.Inference.RunBatch_v1`
- `UML_OS.Model.Backward_v1`
- `UML_OS.TMMU.Init_v1`
- `UML_OS.Symbolic.Augment_v1`
- `UML_OS.Security.VerifyCertificate_v1`
- `UML_OS.Certificate.EvidenceValidate_v1`
- `UML_OS.Transition.SwitchState_v1`
- `UML_OS.Commit.WALAppend_v1`
- `UML_OS.Commit.FinalizeRunCommit_v1`

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.
External operator reference: `UML_OS.Commit.WALAppend_v1` and `UML_OS.Commit.FinalizeRunCommit_v1` are defined normatively in `docs/layer2-specs/Run-Commit-WAL.md` and imported by reference.

**Kernel System Call Interface**  
All system calls follow the EQC template and may be invoked **only** through the VI kernel procedure in section 6. No user code may call backend primitives, torch.add, jax ops, or any library function directly. Every tensor allocation, forward/backward step, or state mutation must be a syscall. Violations trigger CONTRACT_VIOLATION abort.

**Operator:** `UML_OS.OS.Bootstrap_v1`  
**Category:** Init  
**Signature:** `(manifest -> persistent_state)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** PRNG master seeded from fixed manifest hash (single Philox + fixed offsets; no draws); parameter init; buffer allocation; data manifest load + ValidateManifest_v1 + ImportAndRegister_v1 if needed; ApplyFineTune_v1 if declared; ExpandPreset_v1 if preset set; Backend.LoadDriver_v1(manifest.backend); Distributed.Setup_v1; policy load; namespace enter; Security.AttestTEE_v1 (confidential mode only); resolve and merge `manifest_inheritance` if declared; apply `profile`-specific defaults and materialize default pipeline_stages if absent per 0.Q profile rule; resolve and merge manifest_inheritance before pipeline materialization; set `hardware_affinity` pinning if specified; if environment.requirements_hash declared and execution_mode != "local": compute current environment SHA-256 hash from pinned runtime manifest and abort with CONTRACT_VIOLATION on mismatch; in local mode emit deterministic warning record only (no abort). Legacy framework import is delegated to `UML_OS.Import.LegacyFramework_v1` on SERVICE surface and forbidden in `confidential`/`regulated` modes.
**Preconditions / Postconditions:** manifest canonicalized; TEE quote valid in confidential mode.  
**Edge cases:** missing dataset hash, invalid URI, TEE unavailable.  
**Numerical considerations:** manifest-hash-derived bytes for theta init (no RNG).  
**Ordering/tie handling:** N/A.  
**Failure behavior:** `CONTRACT_VIOLATION` or `ATTESTATION_FAILURE` -> abort with record.  
**Dependencies:** 0.Q manifest fields.

**Operator:** `UML_OS.Data.Manifest_v1`  
**Category:** Data  
**Signature:** `(manifest -> canonical_manifest)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** canonicalize manifest JSON/YAML; compute hash inputs.  
**Preconditions / Postconditions:** valid schema -> canonical bytes.  
**Edge cases:** malformed keys/order.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** sorted keys.  
**Failure behavior:** abort on schema mismatch.  
**Dependencies:** 0.Q schema.

**Operator:** `UML_OS.Data.ValidateManifest_v1`  
**Category:** Data  
**Signature:** `(manifest -> ok)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates required fields, hashes, operator contracts, dataset refs.  
**Preconditions / Postconditions:** all mandatory fields present.  
**Edge cases:** missing `global_batch_size`, invalid `execution_mode`.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** deterministic field walk.  
**Failure behavior:** abort with `CONTRACT_VIOLATION`.  
**Dependencies:** 0.Q.

**Operator:** `UML_OS.Data.RegisterDataset_v1`  
**Category:** Data  
**Signature:** `(path,id,version -> dataset_id_hash)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** computes SHA-256 over canonical dataset bytes/manifest, validates schema, stores immutable dataset under canonical path.  
**Preconditions / Postconditions:** data readable; hash persisted.  
**Edge cases:** duplicate id/version mismatch.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** lexicographic file traversal.  
**Failure behavior:** abort on hash mismatch.  
**Dependencies:** OS path resolver.

**Operator:** `UML_OS.Data.ImportAndRegister_v1`  
**Category:** Data  
**Signature:** `(uri,id,version -> dataset_id_hash)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** imports from local/s3/hf URI then delegates to RegisterDataset_v1.  
**Preconditions / Postconditions:** imported bytes immutable after registration.  
**Edge cases:** URI unavailable/auth failure.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** deterministic chunk/file order.  
**Failure behavior:** abort.  
**Dependencies:** RegisterDataset_v1.

**Operator:** `UML_OS.Data.NextBatch_v2`  
**Category:** Data  
**Signature:** `(dataset_key, world_size, rank, data_cursor_in -> batch, data_cursor_next)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic with declared RNG  
**Definition:** Uses manifest.datasets[dataset_key]. Implements memory-efficient deterministic global sampling independent of dataset size. Epoch permutation seeded by `SHA-256(CBOR_CANONICAL(["nextbatch_epoch_seed_v2", kernel_replay_token, manifest_hash, dataset_key, uint64(epoch)]))` using Philox4x32-10. Partition into blocks of size manifest.data.sampler_block_size (default 1<<20). Materialize only the block permutation list (size N/B, always â‰ª dataset size); within each block compute intra-block positions via the bijective mapping specified in `docs/layer2-specs/Data-NextBatch.md` (`SeededIntraBlockMap_v1`) with explicit short-tail handling. For any global position p compute originating sample index in O(1) per sample after block list is built. Form global batches sequentially from the virtual sequence; split into contiguous rank-ordered shards. Guarantees identical global batch sequence across world_size values; update dynamics are E0 only within fixed distributed configuration and E1 across compatible re-shards. Eval and infer stages always use strict ascending original index order (no shuffle). `NextBatch_v2` is cursor-pure; kernel persists `data_cursor_next` into `data_cursors[dataset_key]`.
**Preconditions / Postconditions:** `global_batch_size % world_size == 0`.  
**Edge cases:** world_size=1, final batch boundary.  
**Numerical considerations:** preprocessing stable in binary64 for reductions.  
**Ordering/tie handling:** ascending global index.  
**Failure behavior:** abort on invalid shard/batch.  
**Dependencies:** 0.R.

**Operator:** `UML_OS.Model.ExpandPreset_v1`  
**Category:** Model  
**Signature:** `(model.preset, preset_params, fine_tune -> uml_model_ir_dag)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** expands known preset table into UML_Model_IR DAG; inserts LoRA adapters deterministically when configured.  
**Preconditions / Postconditions:** preset exists.  
**Edge cases:** unknown preset/target module.  
**Numerical considerations:** no RNG.  
**Ordering/tie handling:** registration order of layers.  
**Failure behavior:** abort.  
**Dependencies:** 0.Q model fields.

**Operator:** `UML_OS.Model.ApplyFineTune_v1`  
**Category:** Model  
**Signature:** `(theta, fine_tune_cfg, uml_model_ir_dag -> theta')`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** applies full or LoRA fine-tune wiring/checkpoint loading on UML_Model_IR DAG.  
**Preconditions / Postconditions:** checkpoint hash must match manifest.  
**Edge cases:** missing checkpoint, incompatible layer shapes.  
**Numerical considerations:** deterministic load/merge order.  
**Ordering/tie handling:** parameter registration order.  
**Failure behavior:** abort.  
**Dependencies:** checkpoint manifest.

**Operator:** `UML_OS.Model.Forward_v2`  
**Category:** Model  
**Signature:** `(theta, batch, uml_model_ir_dag, replay_token, tmmu_context -> logits)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** dispatches to active backend driver; executes UML_Model_IR DAG (custom layers via registry); all reductions in binary64 with ascending-index order.  
**Preconditions / Postconditions:** architecture validated.  
**Edge cases:** empty batch, invalid custom ref.  
**Numerical considerations:** critical reductions in binary64; deterministic reduction order.  
**Ordering/tie handling:** layer order fixed by architecture list.  
**Failure behavior:** abort.  
**Dependencies:** RegisterCustom_v1.

**Operator:** `UML_OS.Objective.TotalLoss_v1`  
**Category:** Objective  
**Signature:** `(logits, labels, alpha, task_type -> L_tot)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** `L_sup = mean(loss_by_type)` in binary64. Multiclass: `-log(softmax(logits)[labels])` (stable log-softmax); binary: BCE with logits; regression: MSE. `L_tot = alpha * L_sup`. Reduction: exact sum then divide by batch size (ascending index).  
**Preconditions / Postconditions:** labels valid for task type.  
**Edge cases:** invalid class ids, NaN logits.  
**Numerical considerations:** stable CE/BCE/MSE paths; EPS clamps as needed.  
**Ordering/tie handling:** ascending index accumulation.  
**Failure behavior:** invalid objective policy from 0.A/0.K.  
**Dependencies:** 0.A, 0.C.

**Operator:** `UML_OS.Optimizer.Update_v1`  
**Category:** Update  
**Signature:** `(theta, grads, optimizer_cfg -> theta')`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** if optimizer==\"adamw\": `m_t = beta1*m_{t-1} + (1-beta1)*g`; `v_t = beta2*v_{t-1} + (1-beta2)*g**2`; `m_hat = m_t/(1-beta1^t)`; `v_hat = v_t/(1-beta2^t)`; `theta = theta - lr*(m_hat/(sqrt(v_hat)+eps) + weight_decay*theta)`. Optimizer moments, bias corrections, and parameter updates performed in manifest.compute_dtype; gradient norm for clipping and all scalar reductions computed in binary64 (ascending registration order); weight_decay applied after the adaptive step (standard decoupled AdamW). Other optimizers follow analogous deterministic updates in the same dtype policy.  
**Preconditions / Postconditions:** optimizer config valid.  
**Edge cases:** zero/NaN gradients.  
**Numerical considerations:** clip norm in binary64.  
**Ordering/tie handling:** parameter registration order.  
**Failure behavior:** abort on non-finite gradients.  
**Dependencies:** 0.Q optimizer.

**Operator:** `UML_OS.Module.RegisterCustom_v1`  
**Category:** Module  
**Signature:** `(custom_operators[] -> registry')`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** loads user-declared custom operators from manifest and verifies declared purity, RNG consumption, contract hash, and UML_Model_IR DAG mapping before registration.  
**Preconditions / Postconditions:** contract declaration present per operator.  
**Edge cases:** missing module path, contract mismatch.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** registration in declared manifest order.  
**Failure behavior:** abort with `CONTRACT_VIOLATION`.  
**Dependencies:** `custom_operators` manifest field.

**Operator:** `UML_OS.Policy.Evaluate_v1`  
**Category:** Policy  
**Signature:** `(state, metrics, policy_rules -> action)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** evaluates canonical policy rules from `manifest.policy.rules` in declared order; highest priority wins; ties by lowest index. Policy-bundle hashes remain independent commitment material and are not the runtime rule source.  
**Preconditions / Postconditions:** `policy_rules` schema valid.  
**Edge cases:** no matching rule -> fallback `optimize`.  
**Numerical considerations:** comparisons in binary64.  
**Ordering/tie handling:** deterministic rule order.  
**Failure behavior:** abort on malformed rule expression.  
**Dependencies:** 0.Q.

**Operator:** `UML_OS.Evaluation.Run_v1`  
**Category:** Evaluation  
**Signature:** `(theta, dataset_key, metrics -> eval_result)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** computes declared metrics at configured frequency; uses manifest.datasets[dataset_key]; deterministic full pass in ascending original index order (no shuffle; fixed seed=0 if any ordering needed).  
**Preconditions / Postconditions:** val split exists if configured.  
**Edge cases:** empty val split.  
**Numerical considerations:** binary64 reductions for metrics.  
**Ordering/tie handling:** ascending index over val data.  
**Failure behavior:** abort on missing eval split.  
**Dependencies:** `evaluation` manifest.

**Operator:** `UML_OS.Inference.RunBatch_v1`  
**Category:** Inference  
**Signature:** `(theta, dataset_key, replay_token, tmmu_context -> outputs)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** uses manifest.datasets[dataset_key]; dispatches driver for inference (full pass or per-batch as configured); writes outputs and fingerprint material.  
**Preconditions / Postconditions:** backend loaded and batch schema valid.  
**Edge cases:** empty batch.  
**Numerical considerations:** binary64 for critical reductions/fingerprint path.  
**Ordering/tie handling:** ascending sample index order.  
**Failure behavior:** abort on backend/runtime mismatch.  
**Dependencies:** Backend.LoadDriver_v1.

**Operator:** `UML_OS.Model.Backward_v1`
**Category:** Model
**Signature:** `(L_tot, theta, ir_graph, replay_token, tmmu_context -> grads, grad_norm)`
**Purity class:** STATEFUL
**Determinism:** deterministic
**Definition:** Compute partial derivatives following ir_graph in reverse topological order. For each instruction the driver executes the corresponding gradient kernel; if the backend instruction is non-deterministic, driver falls back to binary64 CPU reference path. Global gradient norm computed with Kahan summation in binary64 (ascending index). If DP is disabled and `grad_clip_norm` is declared, apply `g = g * min(1, clip_norm / (norm + EPS_EQ))`; if DP is enabled, return unclipped gradients and perform clipping only inside `UML_OS.DifferentialPrivacy.Apply_v3`.
**Preconditions / Postconditions:** Forward_v2 completed on same ir_graph; L_tot finite; grads returned in exact theta registration order.
**Edge cases:** single micro-batch, world_size=1.
**Numerical considerations:** Critical layers (embeddings, norms) accumulated in binary64 before cast to compute_dtype.
**Ordering/tie handling:** ascending index.
**Failure behavior:** abort on INF_GRADIENT or NAN_GRADIENT per 0.K.
**Dependencies:** loaded driver, ir_graph from Bootstrap.

**Operator:** `UML_OS.Distributed.Setup_v1`  
**Category:** Distributed  
**Signature:** `(parallelism, world_size, backend -> dist_state)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** initializes deterministic collectives and rank order; validates identical distributed determinism profile across ranks and derives per-rank RNG masters using `rank_rng_seed` rule from 0.R.  
**Preconditions / Postconditions:** valid backend and world size.  
**Edge cases:** world_size=1.  
**Numerical considerations:** deterministic reduction primitives only.  
**Ordering/tie handling:** ascending rank.  
**Failure behavior:** abort on unsupported backend.  
**Dependencies:** 0.R.

**Operator:** `UML_OS.Distributed.Barrier_v1`
**Category:** Distributed
**Signature:** `(() -> ok)`
**Purity class:** STATEFUL
**Determinism:** deterministic
**Definition:** executes a deterministic global barrier across ranks using ascending-rank coordination and timeout `manifest.distributed.timeout_seconds`.
**Failure behavior:** abort on timeout/communication failure with deterministic code `DISTRIBUTED_COMMUNICATION_FAILURE`.
**Dependencies:** distributed communicator state.

**Operator:** `UML_OS.Backend.LoadDriver_v1`  
**Category:** Backend  
**Signature:** `(manifest.backend -> driver_handle)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** Loads and verifies backend driver contract (including binary/manifest hash check against any regulated-mode registry); binds dispatch table for Forward/Update/Distributed/Backward; runs minimal ReproducibilityTest subset on load (E0 on tiny graphs); aborts with `BACKEND_CONTRACT_VIOLATION` on failure.  
**Preconditions / Postconditions:** driver implements all required primitives.  
**Edge cases:** unknown backend id.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** N/A.  
**Failure behavior:** abort `BACKEND_CONTRACT_VIOLATION`.  
**Dependencies:** manifest `backend`.

**Operator:** `UML_OS.TMMU.Init_v1`
**Category:** Memory
**Signature:** `(ir_dag, mode, replay_token, arena_config -> tmmu_context)`
**Purity class:** STATEFUL
**Determinism:** deterministic
**Definition:** initializes deterministic TMMU run context from IR + mode + replay token, validates arena capacities/alignments, and creates memory handles used by model executor operators.
**Preconditions / Postconditions:** backend loaded; `arena_config` resolved from manifest/default policy.
**Failure behavior:** abort on invalid arena config or TMMU init failure.
**Dependencies:** `docs/layer2-specs/TMMU-Allocation.md`.

**Operator:** `UML_OS.Pipeline.Dispatch_v1`  
**Category:** Pipeline  
**Signature:** `(pipeline_stages, current_step -> next_manifest, action)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Resolves dependency graph; returns next stage manifest or termination.  
**Preconditions / Postconditions:** stage ids unique and resolvable.  
**Edge cases:** missing dependency.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** deterministic topological order with stable tie-break.  
**Failure behavior:** abort on cycle or missing dependency.  
**Dependencies:** manifest `pipeline_stages`.

**Operator:** `UML_OS.Config.DeterministicStageMerge_v1`
**Category:** Config
**Signature:** `(base_manifest, stage_manifest -> merged_manifest)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** canonical base-first merge where stage manifest may override only non-security fields (`pipeline stage-local hyperparameters`, `dataset_key`, `checkpoint flags`, `evaluation options`). Security/policy identity fields (`policy_bundle_hash`, security mode, attestation requirements, authz/monitor/dp/redaction policy hashes, tenant identity) MUST remain unchanged. Output is re-validated by `UML_OS.Data.ValidateManifest_v1`.

**Operator:** `UML_OS.Contract.Validate_v1`  
**Category:** Contract  
**Signature:** `(runtime_state -> ok)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** checks declared invariants, objective finiteness, RNG delta contracts, ordering contracts; additionally verifies backend driver contract and pipeline DAG acyclicity.  
**Preconditions / Postconditions:** all required telemetry present.  
**Edge cases:** local relaxed mode emits warnings.  
**Numerical considerations:** EPS_EQ thresholding.  
**Ordering/tie handling:** deterministic check order.  
**Failure behavior:** abort/warn per execution mode.  
**Dependencies:** 0.V.

**Operator:** `UML_OS.Fingerprint.StateFingerprint_v1`  
**Category:** Fingerprint  
**Signature:** `(state -> state_fp)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** incremental SHA-256 chaining over deterministic state tuples (domain-separated canonical CBOR).  
**Preconditions / Postconditions:** persistent state serializable.  
**Edge cases:** empty history.  
**Numerical considerations:** binary64 serialization for critical tensors/metrics.  
**Ordering/tie handling:** deterministic serialization order.  
**Failure behavior:** abort on serialization mismatch.  
**Dependencies:** persistent state schema.

**Operator:** `UML_OS.Fingerprint.Functional_v1`  
**Category:** Fingerprint  
**Signature:** `(theta, probe_set -> functional_fp)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** runs canonical probe set (first 1024 items deterministic), computes probe loss/metric, hashes bytes into functional fingerprint.  
**Preconditions / Postconditions:** probe set available.  
**Edge cases:** dataset size < 1024 uses cyclic repeat.  
**Numerical considerations:** binary64 path.  
**Ordering/tie handling:** ascending original index.  
**Failure behavior:** abort on non-finite probe outputs.  
**Dependencies:** dataset manifest.

**Operator:** `UML_OS.Verifiable.CommitFunctional_v1`  
**Category:** Fingerprint  
**Signature:** `(probe_outputs_bytes, functional_fp, security.functional_commitment -> commitment?)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** if enabled, compute `functional_commitment = SHA-256(CBOR_CANONICAL(["functional_commitment_v1", probe_outputs_bytes, functional_fp]))` and attach to trace/certificate. `probe_outputs_bytes` is canonical CBOR serialization of probe outputs in deterministic probe order.
**Preconditions / Postconditions:** functional_fp available.  
**Edge cases:** disabled path returns no commitment.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** canonical byte order.  
**Failure behavior:** abort on digest mismatch.  
**Dependencies:** `security.functional_commitment`.

**Operator:** `UML_OS.Certificate.EvidenceValidate_v1`
**Category:** Security
**Signature:** `(manifest, trace, checkpoint, replay_context -> valid: bool, report: dict)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** validates pre-sign evidence coherence and consistency (`manifest_hash`, `trace_final_hash`, `checkpoint_hash`, `lineage_root_hash`, `policy_bundle_hash`, `replay_token`, and related run-bound commitments) before certificate signing.

**Operator:** `UML_OS.Security.VerifyCertificate_v1`
**Category:** Security
**Signature:** `(certificate_input_or_path, trust_roots? -> valid: bool, report: dict)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** Accepts canonical certificate object/bytes or path as `certificate_input_or_path`; if path is provided, deterministic loading is part of this operator. Verifies daemon/HSM/electronic signatures, Merkle trace root, all pipeline lineage hashes, state_fp/functional_fp consistency (within EPS_EQ where applicable), privacy budget <= target (if present), and attestation quote (if confidential/regulated). Returns structured report with per-section pass/fail.
**Preconditions / Postconditions:** certificate readable and schema-valid.
**Edge cases:** missing quote, signature mismatch, token mismatch.
**Numerical considerations:** binary64 EPS_EQ for fingerprint checks.
**Ordering/tie handling:** N/A.
**Failure behavior:** returns false + detailed report (non-abort).
**Dependencies:** 0.X.

**Operator:** `UML_OS.Security.AttestTEE_v1`  
**Category:** Security  
**Signature:** `(execution_mode, manifest_hash, replay_token -> quote)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic protocol path  
**Definition:** in confidential mode, collect hardware quote covering kernel measurement + manifest hash + replay token; store for certificate.  
**Preconditions / Postconditions:** TEE available and quote valid.  
**Edge cases:** unavailable TEE, invalid quote, mismatch measurement.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** N/A.  
**Failure behavior:** `ATTESTATION_FAILURE` abort.  
**Dependencies:** confidential execution mode.

**Operator:** `UML_OS.IO.WriteTape_v1`  
**Category:** IO  
**Signature:** `(event -> tape_state')`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** append event in deterministic order with fixed block/chaining rules.  
**Preconditions / Postconditions:** tape open and writable.  
**Edge cases:** block rollover.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** ascending t.  
**Failure behavior:** abort on write/hash mismatch.  
**Dependencies:** tape state.

**Operator:** `UML_OS.State.Journal_v1`
**Category:** IO
**Signature:** `(t, stage_id, data_cursors, rng_offsets, resource_ledger, dp_accountant_state?, state_fp? -> journal_state')`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** Write-ahead log: append cryptographically chained record (`SHA-256(CBOR_CANONICAL(["journal_link_v1", previous_hash, event, uint64(t)]))`) to journal before any state mutation is visible.
Journal operator computes deterministic hashes internally:
  - `data_cursors_hash = SHA-256(CBOR_CANONICAL(data_cursors))`
  - `rng_offsets_hash = SHA-256(CBOR_CANONICAL(rng_offsets))`
  - `resource_ledger_hash = SHA-256(CBOR_CANONICAL(resource_ledger))`
  - `dp_accountant_state_hash = SHA-256(CBOR_CANONICAL(dp_accountant_state))` when present.
Canonical journal event shape (normative): CBOR map containing
`{t:uint64, stage_id:string, data_cursors_hash:bytes32, rng_offsets_hash:bytes32, resource_ledger_hash:bytes32, dp_accountant_state_hash?:bytes32, state_fp?:bytes32}`.
Storage location (normative): append-only per-run file under namespace journal path (e.g., `<namespace>/journal/run_journal.cborlog`); concrete filesystem target is resolved via `UML_OS.OS.ResolvePath_v1`.
Scope clarification: Journal records incremental step-state transitions for recovery/audit and is distinct from commit WAL (`UML_OS.Commit.WALAppend_v1`), which is only the atomic artifact-finalization protocol.
**Preconditions / Postconditions:** journal open; hash chain preserved.
**Failure behavior:** abort on write failure.

**Operator:** `UML_OS.IO.SaveCheckpoint_v1`  
**Category:** IO  
**Signature:** `(state -> checkpoint)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** writes full checkpoint at frequency or termination using deterministic serialization. In distributed mode, rank 0 writes the canonical checkpoint after deterministic gather/barrier; checkpoint payload must include `theta`, `data_cursors`, `rng_master_state`/offsets, and `dp_accountant_state` when DP is enabled, plus sharding metadata needed for restore.
**Preconditions / Postconditions:** checkpoint path resolved in namespace.  
**Edge cases:** checkpoint_frequency=0 disables periodic writes.  
**Numerical considerations:** binary64 for critical values.  
**Ordering/tie handling:** fixed field order.  
**Failure behavior:** abort on write/serialize failure.  
**Dependencies:** section 10 schema.

**Operator:** `UML_OS.Certificate.WriteExecutionCertificate_v1`  
**Category:** IO  
**Signature:** `(run_state -> execution_certificate.cbor)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** emits canonical `ExecutionCertificate` object exactly as defined in `docs/layer2-specs/Execution-Certificate.md`. Legacy `UML_OS.IO.WriteTrainingCertificate_v1` is deprecated and must be implemented as a thin alias wrapper to this operator.
**Preconditions / Postconditions:** daemon signing key available.  
**Edge cases:** missing quote in confidential mode.  
**Numerical considerations:** deterministic digest encoding.  
**Ordering/tie handling:** ascending t in trace chain.  
**Failure behavior:** abort on signing failure.  
**Dependencies:** daemon key + 0.X contract.

**Operator:** `UML_OS.Termination.Check_v1`  
**Category:** Termination  
**Signature:** `(state, limits -> bool)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** evaluates manifest termination criteria.  
`limits` schema (normative): `{max_steps_per_stage?:uint64, max_epochs?:uint64, max_wall_time_seconds?:uint64}`; check order is fixed by key order above.
Wall-time reproducibility note (normative): if `max_wall_time_seconds` is used, E0/E1 reproducibility is not guaranteed due to runtime timing variance; such runs are comparable only under looser replay equivalence policies.
**Preconditions / Postconditions:** criteria declared.  
**Edge cases:** max_steps=0.  
**Numerical considerations:** EPS_EQ comparisons.  
**Ordering/tie handling:** deterministic criterion order.  
**Failure behavior:** abort on invalid criteria.  
**Dependencies:** manifest limits.

**Operator:** `UML_OS.Transition.SwitchState_v1`  
**Category:** Transition  
**Signature:** `(state, action -> state')`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** transitions among declared lifecycle states for evaluate/train/terminate paths.  
State transition table (normative):
- `S_INIT + train -> S_TRAINING`
- `S_TRAINING + optimize -> S_TRAINING`
- `S_TRAINING + eval -> S_EVALUATING`
- `S_EVALUATING + optimize -> S_TRAINING`
- `S_TRAINING|S_EVALUATING|S_INFERENCING + infer -> S_INFERENCING`
- `ANY + terminate -> S_TERMINATED`
- other transitions are invalid and abort with `CONTRACT_VIOLATION`.
**Preconditions / Postconditions:** valid action-state pair.  
**Edge cases:** invalid transition.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** N/A.  
**Failure behavior:** abort on invalid transition.  
**Dependencies:** state model.

**Operator:** `UML_OS.OS.ResolvePath_v1`  
**Category:** OS  
**Signature:** `(logical_path, namespace -> absolute_path)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** resolves canonical namespace-bound path under `UML_OS_ROOT`.  
**Preconditions / Postconditions:** namespace exists and caller authorized.  
**Edge cases:** invalid traversal (`..`) or missing namespace path.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** lexicographic canonicalization.  
**Failure behavior:** abort.  
**Dependencies:** daemon ACL/namespace state.

**Operator:** `UML_OS.OS.NamespaceEnter_v1`  
**Category:** OS  
**Signature:** `(namespace_path -> active_namespace)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** resolves `namespace_path` via `UML_OS.OS.ResolvePath_v1` then enters namespace and binds filesystem, RNG, and state scopes.  
**Preconditions / Postconditions:** ACL allows access.  
**Edge cases:** non-existent namespace.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** N/A.  
**Failure behavior:** abort.  
**Dependencies:** daemon namespace registry.


**Operator:** `UML_OS.DifferentialPrivacy.Apply_v3`  
**Category:** Security  
**Signature:** `(microbatch_gradients_seq, security.differential_privacy, t -> noisy_gradients, updated_budget)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** If enabled (forced true in regulated mode), consumes deterministic per-step micro-batch gradient sequence, clips per-sample/per-micro-batch gradients to configured norms in binary64, averages in ascending deterministic micro-batch/index order, then adds isotropic Gaussian noise ~ N(0, ÏƒÂ²) using deterministic moments accountant (Î´=1e-5 fixed, exact composition per standard reference implementation). RNG for noise drawn from declared stream. Cumulative privacy loss tracked exactly in binary64. Aborts with PRIVACY_BUDGET_EXCEEDED if cumulative Îµ exceeds target_epsilon. Noise applied to averaged gradients before Update_v1.
**Preconditions / Postconditions:** called only on raw gradients before any optimizer step; `target_epsilon` declared and remaining budget sufficient.  
**Edge cases:** epsilon=0, zero gradients.  
**Numerical considerations:** noise scale computed exactly in binary64.  
**Ordering/tie handling:** N/A.  
**Failure behavior:** abort with `PRIVACY_BUDGET_EXCEEDED`.  
**Dependencies:** regulated mode, 0.Q security fields.

**Operator:** `UML_OS.Symbolic.Augment_v1`
**Category:** Symbolic
**Signature:** `(theta_snapshot, dataset_subset, augment_config -> theta', augment_metadata)`
**Purity class:** STATEFUL
**Determinism:** deterministic (with declared RNG consumption)
**Definition:** Applies sequence of deterministic non-learning transforms declared in augment_config (array of objects `{transform_type: "prune_magnitude" | "quantize_int8" | "sparsify" | "custom", params: dict}`). Operates on frozen theta_snapshot using subset from dataset_key. All operations deterministic (no RNG unless explicitly declared in custom); critical reductions in binary64. Returns theta' and augment_metadata (applied transforms list, activation statistics hashes).
**Preconditions / Postconditions:** stage type "augment"; previous stage completed; `augment_config` declared in stage manifest.
**Edge cases:** empty subset, no rules declared.
**Numerical considerations:** deterministic reductions and ordering in binary64.
**Ordering/tie handling:** rule application order from manifest.
**Failure behavior:** abort per 0.K on contract violation.
**Dependencies:** stage type "augment", manifest `augment_config`.


---

## 6) Procedure

```text
1. UML_OS.OS.Bootstrap_v1(...)
1a. run_id <- hex(SHA-256(CBOR_CANONICAL([manifest.tenant_id, replay_token]))[0:8])  # deterministic 16-char hex run id
1b. namespace_path <- "/" + manifest.tenant_id + "/" + run_id
1c. operator_contracts_root_hash <- manifest.operator_contracts_root_hash
2. UML_OS.OS.NamespaceEnter_v1(namespace_path)
3. UML_OS.Backend.LoadDriver_v1(manifest.backend)
3a. arena_config <- (manifest.memory_arena_config is defined) ? manifest.memory_arena_config : derive_default_arena_config(manifest.hardware_affinity, manifest.backend)
3b. tmmu_context <- UML_OS.TMMU.Init_v1(ir_graph, "train", replay_token, arena_config)
4. WALRecover_v1(manifest.tenant_id, run_id)  // deterministic crash recovery before new run prepare
5. current_step <- 0
6. checkpoint_frequency <- manifest.checkpoint_frequency or 0
7. current_stage <- UML_OS.Pipeline.Dispatch_v1(manifest.pipeline_stages, current_step)  // resolves initial stage
7a. if current_stage.manifest_path exists: stage_manifest <- UML_OS.Data.Manifest_v1(current_stage.manifest_path); UML_OS.Data.ValidateManifest_v1(stage_manifest); manifest <- UML_OS.Config.DeterministicStageMerge_v1(manifest, stage_manifest)
8. wal_prepare_record <- {record_type: "PREPARE"}
8a. WALAppend_v1(manifest.tenant_id, run_id, wal_prepare_record)
9. state <- UML_OS.Transition.SwitchState_v1(S_INIT, current_stage.type)

Loop until Pipeline.Dispatch_v1 returns termination:
- terminated <- UML_OS.Termination.Check_v1(...) (scoped to current stage)
- terminated <- terminated OR check_global_termination_limits(manifest, t, state)
- if terminated: break
- if t == UINT64_MAX: Error.Emit_v1(COUNTER_OVERFLOW, ...); UML_OS.IO.WriteTape_v1(error_record_sync); abort
- t <- t + 1
- UML_OS.Contract.Validate_v1(...)
- if current_stage.type == "augment":
  state <- UML_OS.Transition.SwitchState_v1(state, "train")
  theta, augment_metadata <- UML_OS.Symbolic.Augment_v1(...)
- else:
  dataset_key <- current_stage.dataset_key or default-per-type
  if current_stage.type == "train":
    state <- UML_OS.Transition.SwitchState_v1(state, "train")
    batch, cursor_next <- UML_OS.Data.NextBatch_v2(dataset_key, world_size, rank, current_stage.type, data_cursors[dataset_key])
    data_cursors[dataset_key] <- cursor_next
    if len(batch) == 0:
      UML_OS.IO.WriteTape_v1({t, stage_id: current_stage.step_id, status:"batch_empty", dataset_key})
      continue
    logits <- UML_OS.Model.Forward_v2(theta, batch, ir_graph, replay_token, tmmu_context)
    L_tot <- UML_OS.Objective.TotalLoss_v1(...)
    action <- UML_OS.Policy.Evaluate_v1(...)
    if action == "optimize":
      update_grads <- null
      if manifest.security.differential_privacy.enabled == true:
          # split batch deterministically into contiguous micro-batches of size max_microbatch in original sample order (last chunk may be smaller)
          # DP-enabled path: micro-batch accumulation/noise/accounting are handled inside Apply_v3; manifest.gradient_accumulation_steps is not used directly by this loop.
          micro_seq <- deterministic_split(batch, manifest.security.differential_privacy.max_microbatch)
          micro_grads_seq <- []
          for each micro_batch in micro_seq (deterministic order):
              micro_logits <- UML_OS.Model.Forward_v2(theta, micro_batch, ir_graph, replay_token, tmmu_context)
              micro_loss <- UML_OS.Objective.TotalLoss_v1(...)
              micro_grads, _ <- UML_OS.Model.Backward_v1(micro_loss, theta, ir_graph, replay_token, tmmu_context)  # raw micro-batch gradients
              micro_grads_seq.append(micro_grads)
          noisy_grads, budget <- UML_OS.DifferentialPrivacy.Apply_v3(micro_grads_seq, manifest.security.differential_privacy, t)
          update_grads <- noisy_grads
          cumulative_epsilon <- budget.epsilon
          dp_accountant_state <- budget.accountant_state
      else:
          grads, grad_norm <- UML_OS.Model.Backward_v1(L_tot, theta, ir_graph, replay_token, tmmu_context)
          update_grads <- grads
      theta <- UML_OS.Optimizer.Update_v1(update_grads, ...)
    else if action == "eval" or current_stage.type == "eval":
      state <- UML_OS.Transition.SwitchState_v1(state, "eval")
      UML_OS.Evaluation.Run_v1(theta, dataset_key, ...)
    else if action == "infer":
      state <- UML_OS.Transition.SwitchState_v1(state, "infer")
      UML_OS.Inference.RunBatch_v1(theta, dataset_key, replay_token, tmmu_context)
  else if current_stage.type == "eval":
    state <- UML_OS.Transition.SwitchState_v1(state, "eval")
    UML_OS.Evaluation.Run_v1(theta, dataset_key, ...)
  else if current_stage.type == "infer":
    state <- UML_OS.Transition.SwitchState_v1(state, "infer")
    UML_OS.Inference.RunBatch_v1(theta, dataset_key, replay_token, tmmu_context)
- checkpoint_due <- (checkpoint_frequency > 0 and (t % checkpoint_frequency == 0)) or current_stage.checkpoint_on_exit == true
- if checkpoint_due:
    if world_size == 1 or rank == 0: UML_OS.IO.SaveCheckpoint_v1(...)
    if world_size > 1: UML_OS.Distributed.Barrier_v1()
- if manifest.fingerprint_frequency > 0 and (t % manifest.fingerprint_frequency == 0): StateFingerprint_v1, Fingerprint.Functional_v1(theta, manifest.evaluation.probe_set), Verifiable.CommitFunctional_v1 (if enabled)
- UML_OS.IO.WriteTape_v1(...) (includes stage transition and usage record)
- resource_ledger <- update deterministic per-step resource counters `{flops, bytes_allocated, peak_bytes, gpu_time_ns, cpu_time_ns}` by summing declared per-operator contributions for operators executed in this step (operator resource contributions are defined in operator contract metadata; this version assumes fixed per-operator costs).
  # quota policy schema/semantics are governed by `docs/layer2-specs/Pipeline-Orchestrator.md` (`QuotaPolicy`)
- if resource_ledger exceeds manifest quota policy:
    Error.Emit_v1(CONTRACT_VIOLATION, ...)
    UML_OS.IO.WriteTape_v1(error_record_sync)
    abort
- UML_OS.State.Journal_v1(t, current_stage.step_id, data_cursors, rng_offsets, resource_ledger, dp_accountant_state?, state_fp?)
- current_step <- current_step + 1
- current_stage = UML_OS.Pipeline.Dispatch_v1(manifest.pipeline_stages, current_step)  // advance or terminate
- if current_stage.manifest_path exists: stage_manifest <- UML_OS.Data.Manifest_v1(current_stage.manifest_path); UML_OS.Data.ValidateManifest_v1(stage_manifest); manifest <- UML_OS.Config.DeterministicStageMerge_v1(manifest, stage_manifest)

On full termination:
- state <- UML_OS.Transition.SwitchState_v1(state, "terminate")
- UML_OS.Certificate.EvidenceValidate_v1(manifest, trace, checkpoint, replay_context)  // verify assembled evidence bundle before signing
- execution_certificate <- UML_OS.Certificate.WriteExecutionCertificate_v1(...)
- certificate_hash <- SHA-256(CBOR_CANONICAL(execution_certificate))
- wal_cert_signed_record <- {record_type: "CERT_SIGNED", certificate_tmp_hash: certificate_hash}
- WALAppend_v1(manifest.tenant_id, run_id, wal_cert_signed_record)
- FinalizeRunCommit_v1(manifest.tenant_id, run_id)
- operator_registry_hash <- operator_contracts_root_hash  # same commitment in this contract suite
- wal_finalize_record <- {
    record_type: "FINALIZE",
    trace_final_hash,
    checkpoint_hash,
    lineage_root_hash,
    certificate_hash,
    manifest_hash,
    policy_bundle_hash,
    operator_registry_hash,
    determinism_profile_hash
  }
- WALAppend_v1(manifest.tenant_id, run_id, wal_finalize_record)
- UML_OS.Security.VerifyCertificate_v1(output_certificate_path)  // post-write self-verification of produced certificate
```

---

## 7) Trace & Metrics

### Logging rule
Each iteration must emit one canonical trace record via `UML_OS.IO.WriteTape_v1` with required V.B fields for the active task type.
- `operator_seq` is initialized to `0` at the beginning of each step and incremented for each operator call in procedure order.

### Trace schema (minimum required)
- `run_header`: metadata, hashes, replay_token, task_type, world_size, backend_binary_hash, driver_runtime_fingerprint_hash
- `iter`: `t, stage_id, operator_id, operator_seq, rank, status, loss_total?, grad_norm?, state_fp?, functional_fp?, rng_offset_before?, rng_offset_after?, state?, action?`
- `run_end`: status, final hashes, final fingerprints

### Metric schema
- `loss_total`, `grad_norm`, `functional_fp`, `cumulative_epsilon` (regulated mode)

### Comparability guarantee
Two implementations/runs are comparable if they share identical trace schema, metric schema, replay_token definition, objective preorder, and constraint policy (E0 for bitwise, E1 for metric).
- `state`/`action` are mandatory only for RL task types; optional otherwise.

### Certificate schema
- Signed `training_certificate.cbor` with Merkle root, lineage, fingerprints, manifest/contract hashes, and confidential quote when applicable

---

## 8) Validation
#### VII.A Lint rules (mandatory)
Spec passes: symbol completeness, no hidden globals, total state updates per iteration, stochastic explicitness (RNG only inside operators), edge-case totality, ordering/tie adherence, trace compliance, manifest completeness, purity class for all operators, failure semantics traceable, data provenance declared, global batch independence.
- pipeline DAG acyclic and all stages reference valid manifests; backend driver contracts satisfied.

#### VII.B Operator test vectors (mandatory)
Every operator has deterministic test vectors (input â†’ output within EPS_EQ) and stochastic replay-token verification (seed â†’ exact sequence).

#### VII.C Golden traces (mandatory)
At least one golden run trace per execution_mode for reference seed + any manifest-declared dataset. Regression criteria: exact replay_token, state_fp sequence, functional_fp curve within declared tolerance envelope over 10 seeds (E1).

---

## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- **E0 Trace-equivalent** (bitwise identical trace and certificate)
- **E1 Metric-equivalent** (identical loss/functional_fp curves within tolerance)
- **E2 Distribution-equivalent** (statistical replay over seeds)
- **E3 Invariant-equivalent** (same contracts and state_fp sequence)

Required level for any change: E1 minimum; E0 for kernel, attestation, or RNG contract changes.

#### VIII.B Allowed refactor categories
- algebraic simplification of loss or fingerprint
- numerical stabilization (clamps, ordering)
- vectorization/batching (preserve reduction order)
- parallelization (re-declare 0.R sharding)
- operator replacement via version bump + manifest update
- driver certification (new hardware TEE backend)
- declarative-only entrypoint preservation, kernel-only execution, manifest-driven dispatch, dataset registration immutability, signed certificate portability
- regulated-mode additions (differential-privacy accounting, compliance report generation, electronic signatures)

Breaking observables require trace schema update + MAJOR version bump.

#### VIII.C Equivalence test procedure (mandatory)
- 10 seeds per golden dataset
- metrics: replay_token, state_fp sequence, functional_fp curve, final theta (binary64)
- thresholds: EPS_EQ for scalars, exact Merkle root for certificate
- statistical test for E2: Kolmogorov-Smirnov on loss curves (Î±=0.01, Bonferroni-corrected).
- regulated-mode artefacts: exact cumulative epsilon, signed compliance report, electronic signature validation.

---

## 10) Checkpoint/Restore

### Checkpoint contents
- canonicalized full manifest (including pipeline_stages)
- operator contract hashes
- `theta`, optimizer state
- `loss_hist`, `data_cursors`
- RNG master state + offsets
- `policy_bundle_hash`, `env_manifest_hash`, `replay_token`, `backend_binary_hash`, `driver_runtime_fingerprint_hash`
- latest `state_fp`, `functional_fp`, optional `functional_commitment`
- pipeline lineage state

### Serialization
- deterministic canonical CBOR encoding with fixed field order

### Restore semantics
- restore produces identical subsequent control flow under same manifest/seed/replay token contract
- in confidential mode, attestation must be re-validated before resuming

### Post-termination export
- `theta.pt`
- `inference_manifest.yaml`
- `training_certificate.cbor`
- `model.onnx`
- `model_card.json`

---
## 11) Sealed Execution and Extension Governance (Normative)
- Sealed execution mode:
  - user-provided training/eval loops are forbidden,
  - execution proceeds only via manifest-driven registered operators.
- Extension points:
  - custom behavior allowed only via declared `RegisterCustom_v1` style registry pathways with digest-pinned contracts.
- Governance rule:
  - any extension must preserve deterministic trace/certificate semantics and pass conformance gating for the active profile.

FILE: layer3-tests/Compatibility-Test-Matrix.md
===============================================
# UML_OS Compatibility Test Matrix
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.CompatibilityMatrix_v1`  
**Purpose (1 sentence):** Define deterministic compatibility testing across schema versions, migrations, and runtime profiles.  
**Spec Version:** `UML_OS.Test.CompatibilityMatrix_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Backward/forward compatibility validation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.CompatibilityMatrix_v1`
- **Purpose (1 sentence):** Deterministic compatibility matrix contract.
### 0.A Objective Semantics
- minimize unsupported version pairings and migration regressions.
### 0.B Reproducibility Contract
- matrix verdict reproducible from `(matrix_version, migration_rules_hash, vectors_catalog_hash)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- counters and version indices are exact.
### 0.D Ordering and Tie-Break Policy
- pairings sorted by `(from_version, to_version, artifact_type)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- pairwise tests parallelized; verdict aggregation deterministic.
### 0.F Environment and Dependency Policy
- compatibility runner pinned to deterministic toolchain.
### 0.G Operator Manifest
- `UML_OS.Test.RunCompatibilityCase_v1`
- `UML_OS.Test.VerifyMigrationPath_v1`
- `UML_OS.Test.AggregateCompatibilityVerdict_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Test.*` and migration namespaces.
### 0.I Outputs and Metric Schema
- outputs: `(compatibility_report, compatibility_verdict, unsupported_pairs)`.
### 0.J Spec Lifecycle Governance
- matrix policy changes are MAJOR.
### 0.K Failure and Error Semantics
- missing migration path is deterministic failure.
### 0.L Input/Data Provenance
- all test artifacts are content-addressed.
### 0.Z EQC Mandatory Declarations Addendum
- seed space: `uint64` (only if stochastic fixture generation is enabled by matrix policy).
- PRNG family: `Philox4x32-10` when stochastic generation is enabled; otherwise N/A.
- replay guarantee: same `(matrix_version, migration_rules_hash, vectors_catalog_hash)` yields identical `(compatibility_report, compatibility_verdict, unsupported_pairs)`.
- floating-point format: IEEE-754 binary64; rounding mode `roundTiesToEven`.
- NaN/Inf policy: prohibited in verdict-bearing metrics; encountering either is deterministic failure.
- default tolerances: `abs_tol=EPS_EQ`, `rel_tol=0` unless explicitly overridden by case profile.
- determinism target: E0 for final verdict and unsupported pair identities.

---
## 2) System Model
### I.A Persistent State
- compatibility matrix definition and migration registry.
### I.B Inputs and Hyperparameters
- schema families, version ranges, profile id, and the vectors catalog commitment (`vectors_catalog_hash`) used for fixtures.
### I.C Constraints and Feasible Set
- only declared migration paths are allowed.
### I.D Transient Variables
- per-pair test outcomes.
### I.E Invariants and Assertions
- identical pair input yields identical verdict.

---
## 3) Initialization
1. Load matrix definition and migration rules.
2. Resolve version pair set.
3. Initialize result accumulator.

---
## 4) Operator Manifest
- `UML_OS.Test.RunCompatibilityCase_v1`
- `UML_OS.Test.VerifyMigrationPath_v1`
- `UML_OS.Test.AggregateCompatibilityVerdict_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.RunCompatibilityCase_v1`  
**Signature:** `(artifact_type, from_version, to_version, fixture -> case_result)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** Executes one compatibility test with deterministic pass/fail criteria.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `MIGRATION_PATH_MISSING`, `VECTOR_LOAD_FAILURE`.

**Operator:** `UML_OS.Test.VerifyMigrationPath_v1`
**Signature:** `(artifact_type, from_version, to_version, migration_rules_hash -> migration_report)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** Verifies that a declared deterministic migration path exists and is admissible for the version pair.
**allowed_error_codes:** `MIGRATION_PATH_MISSING`, `CONTRACT_VIOLATION`.

**Operator:** `UML_OS.Test.AggregateCompatibilityVerdict_v1`
**Signature:** `(case_results, migration_reports -> compatibility_report, compatibility_verdict, unsupported_pairs)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** Deterministically aggregates per-pair outcomes into final report, verdict, and unsupported pair list.
**allowed_error_codes:** `CONTRACT_VIOLATION`.

---
## 6) Procedure
```text
1. Enumerate compatibility pairs
2. Validate migration path per pair
3. Execute compatibility case
4. Aggregate matrix verdict and emit `(compatibility_report, compatibility_verdict, unsupported_pairs)`
```

---
## 7) Trace & Metrics
- Metrics: `pairs_total`, `pairs_passed`, `pairs_failed`, `unsupported_count`.
- Trace includes artifact type, from/to versions, case verdict.

---
## 8) Validation
- golden compatibility matrix fixtures.
- migration path edge-case tests.

---
## 9) Refactor & Equivalence
- E0 for matrix verdict and unsupported pair list.

---
## 10) Checkpoint/Restore
- checkpoint stores case cursor and partial matrix hash.
- restore resumes matrix execution deterministically.

---
## 11) Published Compatibility Guarantees (Normative)
- Matrix output MUST include a customer-facing compatibility table by profile:
  - supported version ranges,
  - required migration operators,
  - unsupported pair rationale codes.
- Compatibility table hash:
  - `compatibility_table_hash = SHA-256(CBOR_CANONICAL(compatibility_table))`.
- Release consumers may rely on published compatibility table as normative contract for upgrade planning.

FILE: layer3-tests/Conformance-CI-Pipeline.md
=============================================
# UML_OS Conformance CI Pipeline Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ConformanceCIPipeline_v1`  
**Purpose (1 sentence):** Define deterministic CI pipeline stages for contract linting, conformance suites, replay checks, and release gating.  
**Spec Version:** `UML_OS.Implementation.ConformanceCIPipeline_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** CI/CD conformance governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ConformanceCIPipeline_v1`
- **Purpose (1 sentence):** Deterministic CI gate graph contract.
### 0.A Objective Semantics
- minimize false passes and nondeterministic gate outcomes.
### 0.B Reproducibility Contract
- pipeline verdict reproducible from `(commit_hash, lockfile_hash, ci_policy_hash)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- binary64 for aggregate timing and score metrics.
### 0.D Ordering and Tie-Break Policy
- stage order fixed: lint -> unit -> integration -> replay -> evidence -> gates.
### 0.E Parallel, Concurrency, and Reduction Policy
- intra-stage parallel allowed; stage barriers strict.
### 0.F Environment and Dependency Policy
- CI runtime pinned with runtime_env_hash.
### 0.G Operator Manifest
- `UML_OS.CI.RunStage_v1`
- `UML_OS.CI.AggregateStageResults_v1`
- `UML_OS.CI.EmitGateVerdict_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.CI.*` namespace.
### 0.I Outputs and Metric Schema
- outputs: `(ci_report, gate_verdict, artifact_bundle_hash)`.
### 0.J Spec Lifecycle Governance
- mandatory stage set changes are MAJOR.
### 0.K Failure and Error Semantics
- required stage failure aborts pipeline.
### 0.L Input/Data Provenance
- CI artifacts are content-addressed and hash-bound.
### 0.Z EQC Mandatory Declarations Addendum
- seed space: N/A (pipeline control flow is deterministic and non-stochastic).
- PRNG family: N/A.
- replay guarantee: identical `(commit_hash, lockfile_hash, ci_policy_hash)` yields identical `gate_verdict`.
- floating-point format: IEEE-754 binary64 for informational timing metrics.
- NaN/Inf policy: invalid in gate-affecting metrics.
- default tolerances: `abs_tol=EPS_EQ`, `rel_tol=0` unless stage policy overrides.
- determinism target: E0 for stage pass/fail sequence and gate verdict.

---
## 2) System Model
### I.A Persistent State
- CI policy and stage graph definitions.
### I.B Inputs and Hyperparameters
- commit refs, `lockfile_hash`, target profile, stage toggles.
### I.C Constraints and Feasible Set
- required stages cannot be skipped.
### I.D Transient Variables
- per-stage reports.
### I.E Invariants and Assertions
- gate verdict derived only from frozen stage outputs.

---
## 3) Initialization
1. Load CI pipeline policy.
2. Resolve mandatory stage list.
3. Initialize stage runner context.

---
## 4) Operator Manifest
- `UML_OS.CI.RunStage_v1`
- `UML_OS.CI.AggregateStageResults_v1`
- `UML_OS.CI.EmitGateVerdict_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.CI.RunStage_v1`  
**Signature:** `(stage_id, inputs -> stage_report)`  
**Purity class:** IO  
**Determinism:** deterministic inputs/result schema  
**Definition:** Executes CI stage and emits canonical report object.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `CI_STAGE_FAILURE`, `ARTIFACT_MISSING`.

**Operator:** `UML_OS.CI.AggregateStageResults_v1`
**Signature:** `(stage_reports, ci_policy -> gate_report, artifact_bundle_hash)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** Aggregates stage reports in fixed stage order and computes `artifact_bundle_hash` over canonical artifact manifest.
**allowed_error_codes:** `CONTRACT_VIOLATION`.

**Operator:** `UML_OS.CI.EmitGateVerdict_v1`
**Signature:** `(gate_report, artifact_bundle_hash -> gate_verdict, ci_report)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** Emits canonical gate verdict and finalized CI report.
**allowed_error_codes:** `CONTRACT_VIOLATION`.

---
## 6) Procedure
```text
1. Run required stages in fixed order
2. Collect stage reports
3. Aggregate deterministic gate report and compute `artifact_bundle_hash`
4. Emit deterministic gate verdict and publish report
```

---
## 7) Trace & Metrics
- Metrics: `stages_total`, `stages_passed`, `stages_failed`, `pipeline_duration_s` (informational only; excluded from deterministic gate decision).
- Trace includes stage ids, stage hashes, and final gate decision.

---
## 8) Validation
- golden CI graphs for pass/fail scenarios.
- failure-injection tests for stage interruption/recovery.

---
## 9) Refactor & Equivalence
- E0 for gate verdict and stage result hashes.

---
## 10) Checkpoint/Restore
- checkpoint stores `completed_stage_ids[]`, `stage_cursor`, `partial_stage_reports_hash`, and `artifact_bundle_hash` (if already materialized).
- restore resumes from next unfinished stage deterministically.

FILE: layer3-tests/Conformance-Harness-Guide.md
===============================================
# UML_OS Conformance Harness Guide
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ConformanceHarnessGuide_v1`  
**Purpose (1 sentence):** Define deterministic execution of conformance harness suites that validate contract, replay, and evidence integrity.  
**Spec Version:** `UML_OS.Implementation.ConformanceHarnessGuide_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Test harness execution and conformance gating.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ConformanceHarnessGuide_v1`
- **Purpose (1 sentence):** Canonical conformance harness execution contract.
### 0.A Objective Semantics
- minimize conformance failures and unresolved contract drift.
### 0.B Reproducibility Contract
- same suite set + same inputs produce same verdict.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- binary64 for score aggregation and thresholds.
### 0.D Ordering and Tie-Break Policy
- suite order fixed: schema -> interfaces -> replay -> checkpoint -> security.
### 0.E Parallel, Concurrency, and Reduction Policy
- within-suite tests parallelized; suite verdict reduction deterministic.
### 0.F Environment and Dependency Policy
- harness executes in locked environment.
### 0.G Operator Manifest
- `UML_OS.Test.RunSchemaConformanceSuite_v1`
- `UML_OS.Test.RunInterfaceSuite_v1`
- `UML_OS.Test.RunReplayConformanceSuite_v1`
- `UML_OS.Test.RunCheckpointConformanceSuite_v1`
- `UML_OS.Test.RunSecurityConformanceSuite_v1`
- `UML_OS.Test.RunEvidenceIntegritySuite_v1`
- `UML_OS.Test.AggregateHarnessVerdict_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- under `UML_OS.Test.*` and `UML_OS.Implementation.*`.
### 0.I Outputs and Metric Schema
- outputs: `(suite_reports, harness_verdict, harness_metrics, certification_evidence_bundle_hash)`.
### 0.J Spec Lifecycle Governance
- mandatory suite set changes are MAJOR.
### 0.K Failure and Error Semantics
- mandatory suite failure aborts release gate.
### 0.L Input/Data Provenance
- inputs from test vectors catalog and artifact fixtures.
### 0.Z EQC Mandatory Declarations Addendum
- seed space: `uint64` (suite-level stochastic tests must consume deterministic seeds).
- PRNG family: `Philox4x32-10` for stochastic harness suites.
- replay guarantee: identical `(target_profile, suite_selection, strictness_level)` and identical fixture hashes produce identical `harness_verdict`.
- floating-point format: IEEE-754 binary64; rounding mode `roundTiesToEven`.
- NaN/Inf policy: invalid for verdict-bearing aggregates; emit deterministic failure.
- default tolerances: `abs_tol=EPS_EQ`, `rel_tol=0` unless suite profile specifies stricter/looser bounds.
- determinism target: E0 for `harness_verdict` and failing vector ids.

---
## 2) System Model
### I.A Persistent State
- suite results store and history.
### I.B Inputs and Hyperparameters
- target profile id (`profile_hash`), suite selection, strictness level.
### I.C Constraints and Feasible Set
- required baseline vectors must exist.
### I.D Transient Variables
- per-suite pass/fail and diagnostics.
### I.E Invariants and Assertions
- every required suite produces deterministic verdict.
- certification evidence bundle is reproducible and hash-stable for identical suite inputs.

### II.F Certification Evidence Bundle (Normative)
- Harness MUST produce a canonical certification evidence bundle for adapter/store/vendor publication.
- Bundle minimum contents:
  - suite selection and profile hash,
  - per-suite report hashes,
  - failing vector ids (if any),
  - final `harness_verdict`,
  - fixture catalog hash,
  - harness runtime/environment hash.
- Identity rule:
  - `certification_evidence_bundle_hash = SHA-256(CBOR_CANONICAL(certification_evidence_bundle))`.

### II.G Portable Vendor Package Format (Normative)
- Harness MUST support packaging certification outputs as portable artifact:
  - `conformance_package.cbor`,
  - `fixtures_manifest.json`,
  - `verdicts.json`,
  - `hash_manifest.json`.
- Package identity:
  - `conformance_package_hash = SHA-256(CBOR_CANONICAL(conformance_package))`.
- Third parties MUST be able to verify package integrity with published contract hashes and trust roots only.
- Certification workflow reference:
  - `docs/layer4-implementation/Third-Party-Operator-Certification-Program.md`.

---
## 3) Initialization
1. Load suite catalog.
2. Resolve target profile to required suites.
3. Initialize harness run context.

---
## 4) Operator Manifest
- `UML_OS.Test.RunSchemaConformanceSuite_v1`
- `UML_OS.Test.RunInterfaceSuite_v1`
- `UML_OS.Test.RunReplayConformanceSuite_v1`
- `UML_OS.Test.RunCheckpointConformanceSuite_v1`
- `UML_OS.Test.RunSecurityConformanceSuite_v1`
- `UML_OS.Test.RunEvidenceIntegritySuite_v1`
- `UML_OS.Test.AggregateHarnessVerdict_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.RunSchemaConformanceSuite_v1`
**Signature:** `(schema_vectors, profile -> suite_report)`
**Purity class:** IO
**Definition:** Executes schema conformance vectors in deterministic order.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `VECTOR_LOAD_FAILURE`, `SCHEMA_MISMATCH`.

**Operator:** `UML_OS.Test.RunInterfaceSuite_v1`
**Signature:** `(interface_vectors, profile -> suite_report)`
**Purity class:** IO
**Definition:** Verifies API/signature and interface digest conformance.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `SIGNATURE_MISMATCH`, `INTERFACE_MISMATCH`.

**Operator:** `UML_OS.Test.RunReplayConformanceSuite_v1`  
**Signature:** `(vectors, profile -> suite_report)`  
**Purity class:** IO  
**Definition:** Executes replay vectors and validates E0/E1 policies.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `REPLAY_DIVERGENCE`.

**Operator:** `UML_OS.Test.RunCheckpointConformanceSuite_v1`
**Signature:** `(checkpoint_vectors, profile -> suite_report)`
**Purity class:** IO
**Definition:** Validates checkpoint/restore invariants and replay continuity.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `CHECKPOINT_INTEGRITY_FAILURE`, `RESTORE_IDENTITY_MISMATCH`.

**Operator:** `UML_OS.Test.RunSecurityConformanceSuite_v1`
**Signature:** `(security_vectors, profile -> suite_report)`
**Purity class:** IO
**Definition:** Validates certificate/authz/policy-evidence integrity paths.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `CERTIFICATE_INVALID`, `AUTHZ_CONTEXT_MISSING`.

**Operator:** `UML_OS.Test.RunEvidenceIntegritySuite_v1`
**Signature:** `(evidence_vectors, profile -> suite_report)`
**Purity class:** IO
**Definition:** Validates cross-artifact hash-link and evidence-bundle integrity.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `EVIDENCE_HASH_MISMATCH`.

**Operator:** `UML_OS.Test.AggregateHarnessVerdict_v1`  
**Signature:** `(suite_reports, policy -> verdict)`  
**Purity class:** PURE  
**Definition:** Aggregates suite outcomes into deterministic final verdict.
**allowed_error_codes:** `CONTRACT_VIOLATION`.

---
## 6) Procedure
```text
1. run schema suite
2. run interface/signature suite
3. run replay suite
4. run checkpoint suite
5. run security suite
6. run evidence-integrity suite
7. aggregate deterministic verdict
8. abort on required-suite failure
9. emit certification_evidence_bundle_hash
```

---
## 7) Trace & Metrics
- Metrics: `required_suites_total`, `required_suites_passed`, `optional_suites_passed`, `failure_count`.
- Trace includes suite ids and vector ids.

---
## 8) Validation
- golden harness runs with fixed vectors and expected verdict.
- failure-injection conformance path.

---
## 9) Refactor & Equivalence
- E0 for final harness verdict and failing vector ids.

---
## 10) Checkpoint/Restore
- checkpoint stores: `completed_suite_ids[]`, `pending_suite_queue`, `partial_suite_reports_hash`, `harness_context_hash`.
- restore resumes deterministically at next suite.

FILE: layer3-tests/Coverage-Targets.md
======================================
# UML_OS Coverage Targets Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.CoverageTargets_v1`  
**Purpose (1 sentence):** Define deterministic test coverage targets and enforcement rules by subsystem and test type.  
**Spec Version:** `UML_OS.Test.CoverageTargets_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Test quality governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.CoverageTargets_v1`
- **Purpose (1 sentence):** Deterministic coverage gate contract.
### 0.A Objective Semantics
- Optimization sense: `MAXIMIZE`
- Objective type: `Vector`
- Primary objective: enforce minimum coverage across required test classes.
### 0.B Reproducibility Contract
- Replayable given `(coverage_policy_hash, test_report_hash, source_manifest_hash)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- Coverage percentages use binary64; gate checks use exact threshold comparisons.
### 0.D Ordering and Tie-Break Policy
- Coverage aggregation order fixed by subsystem id.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel test execution allowed; coverage reduction deterministic.
### 0.F Environment and Dependency Policy
- Coverage tools and configs must be pinned.
### 0.G Operator Manifest
- `UML_OS.Test.ComputeCoverage_v1`
- `UML_OS.Test.ValidateCoverageTargets_v1`
- `UML_OS.Test.EmitCoverageVerdict_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Coverage artifacts under `reports/coverage/`.
### 0.I Outputs and Metric Schema
- Outputs: `(coverage_report, coverage_verdict)`
- Metrics: `line_cov`, `branch_cov`, `integration_cov`, `replay_cov`
  - `integration_cov`: coverage over integration-suite-tagged source/test mappings.
  - `replay_cov`: coverage over replay/restore determinism code paths and assertions.
### 0.J Spec Lifecycle Governance
- Required thresholds changes are MAJOR.
### 0.K Failure and Error Semantics
- Missing required coverage class fails gate.
### 0.L Input/Data Provenance
- Coverage reports must reference exact source and test manifests.
### 0.Z EQC Mandatory Declarations Addendum
- seed space: N/A (coverage aggregation is deterministic and non-stochastic).
- PRNG family: N/A.
- replay guarantee: identical `(coverage_policy_hash, test_report_hash, source_manifest_hash)` yields identical `(coverage_report, coverage_verdict)`.
- floating-point format: IEEE-754 binary64; rounding mode `roundTiesToEven`.
- NaN/Inf policy: invalid in coverage metrics; deterministic failure if encountered.
- default tolerances: `abs_tol=EPS_EQ`, `rel_tol=0` for threshold boundary checks.
- determinism target: E0 for coverage verdict and normalized metric set.

---
## 2) System Model
### I.A Persistent State
- Coverage policy and historical snapshots.
### I.B Inputs and Hyperparameters
- Raw coverage reports, thresholds, subsystem map, `test_report_hash` (or deterministic derivation `SHA-256(CBOR_CANONICAL(raw_reports))`), and `source_manifest_hash`.
### I.C Constraints and Feasible Set
- Pass iff all required thresholds pass.
### I.D Transient Variables
- normalized coverage metrics and diagnostics.
### I.E Invariants and Assertions
- No threshold evaluation on incomplete report sets.

---
## 3) Initialization
1. Load coverage policy.
2. Load and validate coverage inputs.
3. Normalize coverage schema.

---
## 4) Operator Manifest
- `UML_OS.Test.ComputeCoverage_v1`
- `UML_OS.Test.ValidateCoverageTargets_v1`
- `UML_OS.Test.EmitCoverageVerdict_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.ComputeCoverage_v1`  
**Signature:** `(raw_reports -> coverage_metrics)`  
**Purity class:** PURE  
**Determinism:** deterministic.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `COVERAGE_REPORT_INVALID`.

**Operator:** `UML_OS.Test.ValidateCoverageTargets_v1`  
**Signature:** `(coverage_metrics, policy -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `COVERAGE_THRESHOLD_INVALID`.

**Operator:** `UML_OS.Test.EmitCoverageVerdict_v1`  
**Signature:** `(validation_report -> coverage_verdict)`  
**Purity class:** IO  
**Determinism:** deterministic.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `COVERAGE_GATE_FAILED`.

---
## 6) Procedure
```text
1. ComputeCoverage_v1
2. ValidateCoverageTargets_v1
3. EmitCoverageVerdict_v1
4. Return coverage_report
```

---
## 7) Trace & Metrics
### Logging rule
- Coverage evaluation emits deterministic metric and gate records.
### Trace schema
- `run_header`: coverage_policy_hash, source_manifest_hash
- `iter`: subsystem_id, metric_name, metric_value
- `run_end`: coverage_verdict
### Metric schema
- `line_cov`, `branch_cov`, `integration_cov`, `replay_cov`
### Comparability guarantee
- Comparable iff same policy and source/test manifests.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Required coverage classes must be present.
#### VII.B Operator test vectors (mandatory)
- Coverage boundary and missing-report fixtures.
#### VII.C Golden traces (mandatory)
- Golden coverage-gate traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for coverage verdict and normalized metrics.
#### VIII.B Allowed refactor categories
- Coverage tooling changes preserving normalized outputs.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare on frozen coverage inputs.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Coverage aggregation cursor, per-subsystem partial reductions, and `partial_coverage_report_hash`.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed evaluation yields identical verdict and report.

FILE: layer3-tests/Data-Contract-Fuzzing-Guide.md
=================================================
# UML_OS Data Contract Fuzzing Guide
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.DataContractFuzzing_v1`  
**Purpose (1 sentence):** Define deterministic fuzzing strategy for contract-critical parsers, validators, and canonicalization paths.  
**Spec Version:** `UML_OS.Test.DataContractFuzzing_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Robustness testing and parser hardening.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.DataContractFuzzing_v1`
- **Purpose (1 sentence):** Deterministic fuzzing contract for data/schema parsers.
### 0.A Objective Semantics
- minimize parser crashes, undefined behavior, and non-deterministic parse outcomes.
### 0.B Reproducibility Contract
- fuzz outcomes reproducible from `(fuzz_seed, harness_version, target_schema_hash)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- exact counters for crashes and unique findings.
### 0.D Ordering and Tie-Break Policy
- findings sorted by `(target, signature, first_seen_input_hash)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- fuzz workers parallelized; findings de-duplicated deterministically.
### 0.F Environment and Dependency Policy
- fuzz runtime pinned with sanitizer profile.
### 0.G Operator Manifest
- `UML_OS.Test.GenerateFuzzInput_v1`
- `UML_OS.Test.RunFuzzTarget_v1`
- `UML_OS.Test.DeduplicateFindings_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Test.*` namespace.
### 0.I Outputs and Metric Schema
- outputs: `(fuzz_report, findings_catalog_hash)`.
### 0.J Spec Lifecycle Governance
- target set changes are MAJOR.
### 0.K Failure and Error Semantics
- crash or sanitizer violation is a deterministic failing finding.
### 0.L Input/Data Provenance
- fuzz corpora and generated inputs are hash-addressed.
### 0.Z EQC Mandatory Declarations Addendum
- seed space: `uint64`.
- PRNG family: `Philox4x32-10`.
- replay guarantee: identical `(fuzz_seed, harness_version, target_schema_hash, iteration_budget)` yields identical `findings_catalog_hash` and deterministic finding identities.
- floating-point format: IEEE-754 binary64 only for summary metrics; verdict path is hash/counter based.
- NaN/Inf policy: prohibited in metric outputs; deterministic failure if produced.
- default tolerances: N/A for crash/violation verdicts.
- determinism target: E0 for `findings_catalog_hash` and unique finding set.

---
## 2) System Model
### I.A Persistent State
- fuzz corpus index and findings registry.
### I.B Inputs and Hyperparameters
- fuzz seed, target list, iteration budget.
### I.C Constraints and Feasible Set
- all targets must expose deterministic parse/validate API.
### I.D Transient Variables
- generated input bytes and target outputs.
### I.E Invariants and Assertions
- same input bytes must yield same target verdict.

---
## 3) Initialization
1. Load fuzz target inventory.
2. Initialize corpus and seed.
3. Initialize findings store.

---
## 4) Operator Manifest
- `UML_OS.Test.GenerateFuzzInput_v1`
- `UML_OS.Test.RunFuzzTarget_v1`
- `UML_OS.Test.DeduplicateFindings_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.GenerateFuzzInput_v1`
**Signature:** `(target_id, fuzz_seed, corpus_cursor -> input_bytes, corpus_cursor_next)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** deterministically generates fuzz input bytes from seed+corpus state.
**allowed_error_codes:** `CONTRACT_VIOLATION`.

**Operator:** `UML_OS.Test.RunFuzzTarget_v1`  
**Signature:** `(target_id, input_bytes -> target_result)`  
**Purity class:** IO  
**Determinism:** deterministic for identical input bytes  
**Definition:** Executes one fuzz target invocation and records verdict/crash metadata.
**Preconditions / Postconditions:** target exists; input bytes are bounded by target contract.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `FUZZ_TARGET_CRASH`, `SANITIZER_VIOLATION`.

**Operator:** `UML_OS.Test.DeduplicateFindings_v1`
**Signature:** `(findings -> deduped_findings, findings_catalog_hash)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** deduplicates findings by canonical key and emits `findings_catalog_hash`.
**allowed_error_codes:** `CONTRACT_VIOLATION`.

---
## 6) Procedure
```text
1. Generate deterministic fuzz inputs
2. Execute selected target(s)
3. Capture crashes/violations
4. Deduplicate findings and compute `findings_catalog_hash`
5. Emit report `(fuzz_report, findings_catalog_hash)`
```

---
## 7) Trace & Metrics
- Metrics: `inputs_tested`, `crashes`, `violations`, `unique_findings`.
- Trace includes target id, input hash, verdict signature.

---
## 8) Validation
- fuzz harness self-tests with known crash fixtures.
- deterministic deduplication tests.

---
## 9) Refactor & Equivalence
- E0 for unique finding set and findings catalog hash.

---
## 10) Checkpoint/Restore
- checkpoint stores `corpus_cursor`, `iterations_completed`, `dedup_state_hash`, and current `findings_catalog_hash`.
- restore resumes fuzzing deterministically.

FILE: layer3-tests/Failure-Injection-Index.md
=============================================
# UML_OS Failure Injection Scenario Index
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.FailureInjectionIndex_v1`
**Purpose (1 sentence):** Provide a deterministic index from mandatory chaos scenarios to invariants, recovery procedures, and proof-pack expectations.
**Spec Version:** `UML_OS.Test.FailureInjectionIndex_v1` | 2026-02-21 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.FailureInjectionIndex_v1`
- **Purpose (1 sentence):** Deterministic failure-injection scenario index.
- **Spec Version:** `UML_OS.Test.FailureInjectionIndex_v1` | 2026-02-21 | Authors: Olejar Damir
- **Domain / Problem Class:** resilience verification index.
### 0.A Objective Semantics
- Ensure each mandatory scenario has explicit invariant + proof-pack mapping.
### 0.B Reproducibility Contract
- Replayable given `(scenario_registry_hash, invariant_catalog_hash, recovery_policy_hash)`.
### 0.C Numeric Policy
- N/A.
### 0.D Ordering and Tie-Break Policy
- Scenarios ordered by `scenario_id`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Independent scenarios may run in parallel; verdict set merged deterministically.
### 0.F Environment and Dependency Policy
- Scenario execution references fixed fixture/environment hashes.
### 0.G Operator Manifest
- `UML_OS.Test.InjectFault_v1`
- `UML_OS.Test.RunRecovery_v1`
- `UML_OS.Test.ValidateRecoveryOutcome_v1`
### 0.H Namespacing and Packaging
- Scenario index namespace: `tests/failure_injection/index/`.
### 0.I Outputs and Metric Schema
- Outputs: `(scenario_index_report, scenario_index_hash)`.
### 0.J Spec Lifecycle Governance
- Required scenario set updates are MAJOR-governed.
### 0.K Failure and Error Semantics
- Missing invariant/proof-pack mapping is deterministic failure.
### 0.L Input/Data Provenance
- Sources: `Failure-Injection-Scenarios.md`, recovery runbooks, release gates.

## 2) Scenario Mapping Table (Normative)
| scenario_id | invariants | recovery_procedure_refs | proof_pack_fields | acceptable_outcomes_by_profile |
|---|---|---|---|---|
| `network_partition_primary_quorum` | quorum restored, no committed-state fork | `docs/layer4-implementation/Distributed-Failure-Recovery-Guide.md` | `scenario_id,recovery_transcript_hash,invariant_results,final_verdict` | core: pass/fail logged; enterprise/regulated: pass required |
| `artifact_store_partial_unavailable` | no data loss, deterministic retry semantics | `docs/layer4-implementation/Disaster-Recovery-Operations-Runbook.md` | same as above + artifact consistency summary hash | core: pass/fail logged; enterprise/regulated: pass required |
| `wal_corruption_truncated_tail` | deterministic rollback or finalize path | `docs/layer2-specs/Run-Commit-WAL.md` | same as above + wal_recovery_hash | regulated requires proof-pack pass |
| `wal_corruption_checksum_mismatch` | chain integrity detection and deterministic abort | `docs/layer2-specs/Run-Commit-WAL.md` | same as above + wal_chain_validation_hash | regulated requires proof-pack pass |

## 3) Index Hash
- `scenario_index_hash = SHA-256(CBOR_CANONICAL(["failure_index_v1", rows]))`.

## 6) Procedure
```text
1. Load mandatory scenario set from Failure-Injection-Scenarios.
2. Resolve invariant and recovery procedure mappings.
3. Validate required proof-pack field coverage.
4. Emit scenario_index_report and scenario_index_hash.
```

FILE: layer3-tests/Failure-Injection-Scenarios.md
=================================================
# UML_OS Failure Injection Scenarios Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.FailureInjection_v1`  
**Purpose (1 sentence):** Define deterministic fault-injection scenarios and expected recovery outcomes across core runtime and governance paths.  
**Spec Version:** `UML_OS.Test.FailureInjection_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Resilience and recovery verification.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.FailureInjection_v1`
- **Purpose (1 sentence):** Deterministic fault-injection contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: verify deterministic recovery under defined fault classes.
### 0.B Reproducibility Contract
- Replayable given `(scenario_id, injection_point, seed, evidence_bundle_hash)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- Scenario timing and counters use exact deterministic tick values.
### 0.D Ordering and Tie-Break Policy
- Injection sequence order is fixed by scenario definition.
### 0.E Parallel, Concurrency, and Reduction Policy
- Multi-fault scenarios allowed only when deterministic ordering is declared.
### 0.F Environment and Dependency Policy
- Faults must not alter contract definitions; only runtime behavior under test.
### 0.G Operator Manifest
- `UML_OS.Test.InjectFault_v1`
- `UML_OS.Test.RunRecovery_v1`
- `UML_OS.Test.ValidateRecoveryOutcome_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `tests/failure_injection/` suites.
### 0.I Outputs and Metric Schema
- Outputs: `(fault_report, recovery_verdict)`
- Metrics: `scenarios_total`, `recovery_passed`, `recovery_failed`
### 0.J Spec Lifecycle Governance
- Required scenario set changes are MAJOR.
### 0.K Failure and Error Semantics
- Unexpected recovery outcomes are deterministic failures.
### 0.L Input/Data Provenance
- Scenario definitions and expected outcomes must be hash-addressed.
### 0.Z EQC Mandatory Declarations Addendum
- seed space: `uint64`.
- PRNG family: `Philox4x32-10` for stochastic fault payload generation.
- replay guarantee: identical `(scenario_id, injection_point, seed, evidence_bundle_hash, runtime_profile)` yields identical `(fault_report, recovery_verdict)`.
- floating-point format: IEEE-754 binary64 for informational metrics only.
- NaN/Inf policy: invalid in recorded metrics.
- default tolerances: N/A for pass/fail recovery verdicts.
- determinism target: E0 for `recovery_verdict` and evidence identities.

---
## 2) System Model
### I.A Persistent State
- Scenario registry and expected recovery matrix.
### I.B Inputs and Hyperparameters
- scenario id, fault point, `seed`, runtime profile, and evidence bundle (with `evidence_bundle_hash` commitment).
### I.C Constraints and Feasible Set
- Valid iff scenario has declared expected deterministic outcome.
### I.D Transient Variables
- injection logs and recovery diagnostics.
### I.E Invariants and Assertions
- First divergence and final verdict must be deterministic.

### II.F Mandatory Chaos Scenarios and Recovery Proof Packs (Normative)
- Mandatory baseline chaos scenarios:
  - `network_partition_primary_quorum`
  - `artifact_store_partial_unavailable`
  - `wal_corruption_truncated_tail`
  - `wal_corruption_checksum_mismatch`
- Regulated-mode requirement:
  - each mandatory scenario MUST emit a `recovery_proof_pack`.
- Recovery proof pack minimum contents:
  - `scenario_id`,
  - injected fault descriptor hash,
  - recovery transcript hash,
  - invariant check results,
  - final recovery verdict.
- Identity rule:
  - `recovery_proof_pack_hash = SHA-256(CBOR_CANONICAL(recovery_proof_pack))`.

---
## 3) Initialization
1. Load scenario definitions.
2. Validate environment and fixture preconditions.
3. Initialize deterministic injection controller.

---
## 4) Operator Manifest
- `UML_OS.Test.InjectFault_v1`
- `UML_OS.Test.RunRecovery_v1`
- `UML_OS.Test.ValidateRecoveryOutcome_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.InjectFault_v1`  
**Signature:** `(scenario_id, runtime_state -> faulted_state)`  
**Purity class:** IO  
**Determinism:** deterministic.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `FAULT_POINT_INVALID`.

**Operator:** `UML_OS.Test.RunRecovery_v1`  
**Signature:** `(faulted_state, recovery_policy -> recovery_state)`  
**Purity class:** IO  
**Determinism:** deterministic.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `RECOVERY_FAILURE`.

**Operator:** `UML_OS.Test.ValidateRecoveryOutcome_v1`  
**Signature:** `(recovery_state, expected_outcome -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `RECOVERY_OUTCOME_MISMATCH`.

---
## 6) Procedure
```text
1. InjectFault_v1
2. RunRecovery_v1
3. ValidateRecoveryOutcome_v1
4. Emit fault_report
```

---
## 7) Trace & Metrics
### Logging rule
- Fault and recovery paths emit deterministic scenario records.
### Trace schema
- `run_header`: scenario_id, profile_hash
- `iter`: injection_point, status
- `run_end`: recovery_verdict, outcome_hash
### Metric schema
- `scenarios_total`, `recovery_passed`, `recovery_failed`, `recovery_time_ms` (informational only; excluded from deterministic verdict logic)
### Comparability guarantee
- Comparable iff same scenario and profile.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Every required scenario has expected deterministic outcome.
#### VII.B Operator test vectors (mandatory)
- Fault/recovery vectors for WAL, checkpoint, replay, and pipeline.
#### VII.C Golden traces (mandatory)
- Golden failure-injection traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for scenario verdict and recovery evidence hashes.
#### VIII.B Allowed refactor categories
- Harness/runtime refactors preserving outcome semantics.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of validation reports.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- `scenario_cursor`, `injection_log_hash`, `partial_recovery_diagnostics_hash`, `current_outcome_hash`.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed scenario must produce identical recovery verdict.

## 13) Failure Injection Index Reference (Normative)
- `docs/layer3-tests/Failure-Injection-Index.md` is the authoritative mapping index from mandatory scenarios to invariants, recovery procedures, and proof-pack field expectations.

FILE: layer3-tests/Game-Day-Scenarios.md
========================================
# UML_OS Game Day Scenarios
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.GameDayScenarios_v1`  
**Purpose (1 sentence):** Define mandatory integrated chaos scenarios that validate whole-system resilience under realistic compound failures.  
**Spec Version:** `UML_OS.Test.GameDayScenarios_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) Mandatory Scenarios
- simultaneous network partition + storage backend outage during checkpoint write.
- WAL corruption + partial replay artifact availability.
- backend adapter mismatch during release-gate phase.

## 2) Required Outputs
- `game_day_report`
- `recovery_proof_pack_hash`
- `invariant_verdicts`

## 3) Deterministic Success Criteria
- no data loss in committed artifacts.
- deterministic recovery plan hash.
- deterministic final verdict for identical scenario inputs.

## 4) Evidence Binding
- Game day results MUST be linkable into release evidence bundle for enterprise/regulated profiles.

## 5) Related Contracts
- `docs/layer3-tests/Failure-Injection-Scenarios.md`
- `docs/layer2-specs/Run-Commit-WAL.md`
- `docs/layer4-implementation/Release-Evidence-Assembler.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Game Day Scenarios" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer3-tests/Integration-Test-Matrix.md
=============================================
# UML_OS Integration Test Matrix Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.IntegrationMatrix_v1`  
**Purpose (1 sentence):** Define deterministic cross-module integration suites and pass/fail semantics for end-to-end UML_OS correctness.  
**Spec Version:** `UML_OS.Test.IntegrationMatrix_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** System integration verification.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.IntegrationMatrix_v1`
- **Purpose (1 sentence):** Deterministic integration coverage contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: maximize deterministic end-to-end contract coverage.
### 0.B Reproducibility Contract
- Replayable given `(integration_matrix_hash, test_manifest_hash, seeds)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- Result comparisons use E0/E1 policy declared per suite.
### 0.D Ordering and Tie-Break Policy
- Suites execute in fixed matrix order.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel suite runs allowed; verdict merge deterministic.
### 0.F Environment and Dependency Policy
- Same environment constraints as release CI.
### 0.G Operator Manifest
- `UML_OS.Test.RunIntegrationCase_v1`
- `UML_OS.Test.CompareIntegrationOutputs_v1`
- `UML_OS.Test.EvaluateIntegrationMatrix_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `tests/integration/<suite>/<case>`
### 0.I Outputs and Metric Schema
- Outputs: `(integration_report, matrix_verdict)`
- Metrics: `cases_total`, `cases_passed`, `cases_failed`
### 0.J Spec Lifecycle Governance
- Required suite changes are MAJOR.
### 0.K Failure and Error Semantics
- Any required case failure fails matrix.
### 0.L Input/Data Provenance
- Each case must bind fixture and expected digest refs.
### 0.Z EQC Mandatory Declarations Addendum
- seed space: `uint64` (per-case seeds are part of fixtures).
- PRNG family: `Philox4x32-10` for stochastic case fixtures.
- replay guarantee: identical `(integration_matrix_hash, test_manifest_hash, seeds)` and fixture digests yield identical `matrix_verdict`.
- floating-point format: IEEE-754 binary64; rounding mode `roundTiesToEven`.
- NaN/Inf policy: invalid for verdict-bearing comparisons unless explicitly declared by case profile.
- default tolerances: `abs_tol=EPS_EQ`, `rel_tol=0` for E1 when omitted.
- determinism target: E0 for required-case pass/fail and matrix verdict.

---
## 2) System Model
### I.A Persistent State
- Integration matrix definition and golden outputs.
### I.B Inputs and Hyperparameters
- `integration_matrix_hash`, `test_manifest_hash`, case fixtures (including deterministic `seeds`), expected outputs, tolerances, modes.
### I.C Constraints and Feasible Set
- Valid iff all required cases execute and compare successfully.
- `required` means cases marked `mandatory=true` in the matrix definition.
### I.D Transient Variables
- case outputs and diff diagnostics.
### I.E Invariants and Assertions
- Every interface boundary appears in at least one integration case.

---
## 3) Initialization
1. Load matrix and fixtures.
2. Validate case signatures against registry.
3. Initialize deterministic suite order.

---
## 4) Operator Manifest
- `UML_OS.Test.RunIntegrationCase_v1`
- `UML_OS.Test.CompareIntegrationOutputs_v1`
- `UML_OS.Test.EvaluateIntegrationMatrix_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.RunIntegrationCase_v1`  
**Signature:** `(case_id, fixture -> case_output)`  
**Purity class:** IO  
**Determinism:** deterministic with fixed seeds.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `CASE_FIXTURE_MISSING`, `EXECUTION_FAILURE`.

**Operator:** `UML_OS.Test.CompareIntegrationOutputs_v1`  
**Signature:** `(case_output, expected_output, comparison_profile -> compare_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.
`comparison_profile` schema: `{equivalence_class: "E0"|"E1", abs_tol?: float64, rel_tol?: float64}` with deterministic defaults `abs_tol=EPS_EQ`, `rel_tol=0` when omitted.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `COMPARE_PROFILE_INVALID`, `OUTPUT_MISMATCH`.

**Operator:** `UML_OS.Test.EvaluateIntegrationMatrix_v1`  
**Signature:** `(case_reports, matrix_policy -> matrix_verdict)`  
**Purity class:** PURE  
**Determinism:** deterministic.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `REQUIRED_CASE_MISSING`.

---
## 6) Procedure
```text
1. RunIntegrationCase_v1 for each case
2. CompareIntegrationOutputs_v1
3. EvaluateIntegrationMatrix_v1
4. Emit integration_report
```

---
## 7) Trace & Metrics
### Logging rule
- Integration suites emit deterministic case records.
### Trace schema
- `run_header`: matrix_hash, fixture_set_hash
- `iter`: case_id, status, output_hash
- `run_end`: matrix_verdict
### Metric schema
- `cases_total`, `cases_passed`, `cases_failed`
### Comparability guarantee
- Comparable iff same matrix, fixtures, and profile.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Required cross-module boundaries covered.
#### VII.B Operator test vectors (mandatory)
- Case-run/compare/evaluate vectors.
#### VII.C Golden traces (mandatory)
- Golden integration matrix traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for matrix verdict and required case hashes.
#### VIII.B Allowed refactor categories
- Harness/runtime changes preserving case outputs.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of required case reports.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- `case_cursor`, `completed_case_ids[]`, `partial_case_reports_hash`, `current_matrix_accumulator_hash`.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed integration run must preserve final verdict.

FILE: layer3-tests/Performance-Plan.md
======================================
# UML_OS Performance Governance
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.PerformanceGovernance_v1`  
**Purpose (1 sentence):** Define deterministic performance measurement, thresholds, and regression-gating for core UML_OS operators.  
**Spec Version:** `UML_OS.Implementation.PerformanceGovernance_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Reproducible performance benchmarking and policy enforcement.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.PerformanceGovernance_v1`
- **Purpose (1 sentence):** Deterministic benchmark governance.
- **Spec Version:** `UML_OS.Implementation.PerformanceGovernance_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Performance policy contract.

### 0.A Objective Semantics
- Optimization sense: `MINIMIZE` p95 latency and memory peak regressions.
- Objective type: `Vector` with deterministic lexicographic order: `(regression_failures, p95_latency_delta, memory_delta)`.

### 0.B Reproducibility Contract
- Seed space: `seed âˆˆ {0..2^64-1}` for stochastic workloads.
- PRNG family: inherited from tested operators.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
- Randomness locality: benchmark harness does not sample except workload generation operators.
- Replay guarantee: benchmark replayable given `(workload_manifest, runtime_env_hash, seeds, commit_hash)`.
- Determinism scope: metric sampling is physical-world variable; aggregation and verdict are deterministic given a frozen metric snapshot hash.

### 0.C Numeric Policy
- Timing and memory metrics stored in binary64/integer nanoseconds and bytes.
- Quantile method: nearest-rank (`k = ceil(p*n)` on sorted ascending samples, 1-indexed); ties resolved by stable input order.
- NaN/Inf metrics are invalid and fail the run.
- Approx-equality: threshold-based comparisons.

### 0.D Ordering and Tie-Break Policy
- Benchmarks run in deterministic workload order.
- Tie-break by workload id.

### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel benchmark execution allowed with deterministic metric merge order.

### 0.F Environment and Dependency Policy
- Pinned benchmark runtime image and dependency lockfile required.
- Determinism level: deterministic analysis/verdict over frozen samples (E0 on analysis), tolerance-based policy on raw metrics.

### 0.G Operator Manifest
- `UML_OS.Perf.RunBenchmark_v1`
- `UML_OS.Perf.AggregateMetrics_v1`
- `UML_OS.Perf.EvaluateRegressionPolicy_v1`
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- Fully-qualified performance operators required.

### 0.I Outputs and Metric Schema
- Outputs: `(perf_report, gate_verdict, metric_snapshot_hash)`.
- Metrics: `p50`, `p95`, `p99`, `peak_memory`, `throughput`, `regression_count`, `peak_memory_bytes`, `tmmu_fragmentation_ratio`.
- Completion status: `success | failed`.

### 0.J Spec Lifecycle Governance
- Threshold or metric definition changes require version bump and migration notes.

### 0.K Failure and Error Semantics
- Deterministic abort on invalid benchmark artifacts.

### 0.L Input/Data Provenance
- Workloads and baselines must be hash-addressed with provenance metadata.

---

### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: inherited from tested operators (must match each operator contractâ€™s declared PRNG family).
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model

### I.A Persistent State
- benchmark baseline registry and threshold policy.

### I.B Inputs and Hyperparameters
- workload set, hardware profile, seeds, thresholds.

### I.C Constraints and Feasible Set
- Unconstrained; gate verdict determined by policy thresholds.

### I.D Transient Variables
- per-workload metric samples and aggregate stats.

### I.E Invariants and Assertions
- deterministic run order and complete metric emission.

### II.F Regression Guards (Normative)
- `peak_memory_bytes` ceiling is mandatory per workload/profile; exceeding ceiling is a hard failure.
- `tmmu_fragmentation_ratio` is computed deterministically as `1 - (largest_free_block_bytes / total_free_bytes)` at measurement point.
- Division-by-zero rule: if `total_free_bytes == 0`, set `tmmu_fragmentation_ratio = 1` and emit `memory_pressure_state = "EXHAUSTED"`.
- Fragmentation regression beyond declared threshold is a hard failure.
- Gate verdict is computed on frozen snapshot samples only.

### II.G Resource Ledger Gate Inputs (Normative)
- Performance gates must ingest deterministic resource-ledger counters:
  - `bytes_allocated`, `peak_bytes`, `io_bytes_read`, `io_bytes_written`, `gpu_time_ms`, `cpu_time_ms`.
- Quota policy decisions must be reproducible from frozen snapshots and bound to `quota_policy_hash`.
- Any quota overrun gate failure must emit deterministic diagnostics and failure code.

### II.H Metric Snapshot Hash (Normative)
- Benchmark verdicts must be computed from a frozen metric snapshot object:
  - `MetricSnapshot = {snapshot_id, workload_ids_sorted, samples_by_workload, warmup_discard_count, quantile_method, runtime_env_hash, baseline_hash, threshold_hash}`.
- Canonical serialization: `CBOR_CANONICAL`.
- Snapshot hash:
  - `metric_snapshot_hash = SHA-256(CBOR_CANONICAL(MetricSnapshot))`.
- Gate verdict record must include `metric_snapshot_hash`; comparisons and audits must use this hash as the authoritative metric evidence identity.

### II.I Baseline Commitment (Normative)
- `baseline_hash = SHA-256(CBOR_CANONICAL(["perf_baseline_v1", workload_manifest_hash, runtime_env_hash, driver_runtime_fingerprint_hash, hardware_fingerprint_hash, sample_policy_hash]))`.
- Performance comparisons are valid only when baseline and candidate share compatible workload and environment commitment sets.

---

## 3) Initialization

1. Load baseline metrics and thresholds.
2. Validate workload manifests.
3. Initialize deterministic execution order.

---

## 4) Operator Manifest

- `UML_OS.Perf.RunBenchmark_v1`
- `UML_OS.Perf.AggregateMetrics_v1`
- `UML_OS.Perf.EvaluateRegressionPolicy_v1`
- `UML_OS.Error.Emit_v1`

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

**Operator:** `UML_OS.Perf.RunBenchmark_v1`  
**Category:** IO  
**Signature:** `(workload, env -> metric_samples)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic under fixed env/workload seeds  
**Definition:** executes one workload and records latency/memory/throughput samples.  
**Preconditions / Postconditions:** workload/env validated.  
**Edge cases:** warmup-only short runs.  
**Numerical considerations:** metrics in ns/bytes with stable aggregators.  
**Ordering/tie handling:** deterministic sample ordering.  
**Complexity note:** workload-dependent.  
**Failure behavior:** deterministic benchmark failure record.  
**Dependencies:** benchmark harness.  
**Test vectors:** synthetic workload performance fixtures.

**Operator:** `UML_OS.Perf.AggregateMetrics_v1`  
**Category:** IO  
**Signature:** `(metric_samples -> aggregate_metrics)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** computes p50/p95/p99/peaks/throughput in deterministic order using nearest-rank quantiles on stably sorted samples.  
**Preconditions / Postconditions:** sufficient samples.  
**Edge cases:** low-sample run.  
**Numerical considerations:** stable percentile computation policy.  
**Ordering/tie handling:** sorted sample values, stable tie handling.  
**Complexity note:** O(n log n).  
**Failure behavior:** abort on invalid sample values.  
**Dependencies:** percentile calculator.  
**Test vectors:** fixed sample -> fixed aggregates.

**Operator:** `UML_OS.Perf.EvaluateRegressionPolicy_v1`  
**Category:** IO  
**Signature:** `(aggregate_metrics, baselines, thresholds -> gate_verdict)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** applies regression policy and emits pass/fail verdict.  
**Preconditions / Postconditions:** baselines exist for workload profile.  
**Edge cases:** missing baseline path.  
**Numerical considerations:** tolerance thresholds applied in binary64.  
**Ordering/tie handling:** deterministic workload merge and policy order.  
**Complexity note:** O(workloads).  
**Failure behavior:** deterministic policy failure report.  
**Dependencies:** policy config and baseline registry.  
**Test vectors:** pass/fail threshold boundary cases.

---

## 6) Procedure

```text
1. RunBenchmark_v1 for each workload
2. AggregateMetrics_v1
3. EvaluateRegressionPolicy_v1
4. Return perf_report + gate_verdict
```

---

## 7) Trace & Metrics

### Logging rule
Each workload emits deterministic benchmark records.

### Trace schema
- `run_header`: runtime_env_hash, baseline_hash, replay_token
- `iter`: workload_id, sample_stats
- `run_end`: aggregate_metrics, metric_snapshot_hash, gate_verdict

### Metric schema
- `p50`, `p95`, `p99`, `peak_memory`, `throughput`, `regression_count`

### Comparability guarantee
Comparable iff workloads, env, baselines, and threshold policies are identical.

---

## 8) Validation

#### VII.A Lint rules (mandatory)
Passes deterministic ordering, explicit thresholds, trace compliance.

#### VII.B Operator test vectors (mandatory)
Benchmark, aggregation, and policy-evaluation vectors.

#### VII.C Golden traces (mandatory)
Golden aggregate metrics for canonical workloads.

---

## 9) Refactor & Equivalence

#### VIII.A Equivalence levels
- E0 for gate verdict and aggregate metrics under same samples.

#### VIII.B Allowed refactor categories
- harness optimization preserving metrics/verdict semantics.

#### VIII.C Equivalence test procedure (mandatory)
Compare aggregate metrics and verdicts exactly/tolerance as declared.

---

## 10) Checkpoint/Restore

### Checkpoint contents
- partial benchmark samples and deterministic run cursor.

### Serialization
- deterministic canonical CBOR.

### Restore semantics
- resumed run yields identical aggregate metrics and verdict.

---
## 11) Performance-as-Contract Baseline Tiers (Normative)
- Official benchmark tiers:
  - `cpu_tier`
  - `single_gpu_tier`
  - `multi_gpu_tier`
- For each tier, release evidence MUST include:
  - `env_manifest_hash`,
  - ordered `workload_ids`,
  - `baseline_hash`,
  - regression gate verdict and diagnostics hash.
- Baseline identity:
  - `tier_baseline_hash = SHA-256(CBOR_CANONICAL([tier_id, env_manifest_hash, workload_ids_sorted, baseline_metrics]))`.
- External comparability requirement:
  - performance claims are externally valid only when tier id + environment fingerprint + workload set match.

## 13) Benchmark Evidence Specification Reference (Normative)
- `docs/layer4-implementation/Benchmark-Evidence-Spec.md` defines required benchmark evidence fields and release-gate identity bindings.

FILE: layer3-tests/Release-Gates.md
===================================
# UML_OS Release Gates Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ReleaseGates_v1`  
**Purpose (1 sentence):** Define deterministic merge/release gating criteria across correctness, replay, security, and performance evidence.  
**Spec Version:** `UML_OS.Implementation.ReleaseGates_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Release readiness governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ReleaseGates_v1`
- **Purpose (1 sentence):** Deterministic release decision contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: prevent non-compliant builds from release/promotion.
### 0.B Reproducibility Contract
- Replayable given `(release_manifest_hash, gate_policy_hash, evidence_bundle_hash)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- Threshold checks use deterministic binary64/integer rules.
### 0.D Ordering and Tie-Break Policy
- Gate evaluation order is fixed and versioned.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel evidence gathering allowed; verdict reduction deterministic.
### 0.F Environment and Dependency Policy
- Release gate requires valid env/lock/profile bindings.
### 0.G Operator Manifest
- `UML_OS.Release.CollectEvidence_v1`
- `UML_OS.Release.EvaluateGates_v1`
- `UML_OS.Release.EmitVerdict_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Release.*`
### 0.I Outputs and Metric Schema
- Outputs: `(release_verdict, release_gate_report)`
- Metrics: `gates_total`, `gates_passed`, `gates_failed`
### 0.J Spec Lifecycle Governance
- Gate set changes are MAJOR.
### 0.K Failure and Error Semantics
- Any required gate failure is deterministic release block.
### 0.L Input/Data Provenance
- Release decision must cite all evidence hashes.
### 0.Z EQC Mandatory Declarations Addendum
- seed space: N/A (gate evaluation is deterministic and non-stochastic).
- PRNG family: N/A.
- replay guarantee: identical `(release_manifest_hash, gate_policy_hash, evidence_bundle_hash)` yields identical `release_verdict`.
- floating-point format: IEEE-754 binary64 for threshold math; rounding mode `roundTiesToEven`.
- NaN/Inf policy: invalid in gate metrics; deterministic failure.
- default tolerances: `abs_tol=EPS_EQ`, `rel_tol=0` unless gate policy overrides.
- determinism target: E0 for `release_verdict` and failing gate ids.

---
## 2) System Model
### I.A Persistent State
- Release gate policy and historical verdict ledger.
### I.B Inputs and Hyperparameters
- CI report, test report, replay report, cert report, perf report, security report, and derived `evidence_bundle_hash`.
### I.C Constraints and Feasible Set
- Release allowed iff all required gates pass.
### I.D Transient Variables
- gate diagnostics and final verdict object.
### I.E Invariants and Assertions
- No unbound evidence accepted.

---
## 3) Initialization
1. Load gate policy.
2. Resolve evidence refs.
3. Validate evidence integrity.

---
## 4) Operator Manifest
- `UML_OS.Release.CollectEvidence_v1`
- `UML_OS.Release.EvaluateGates_v1`
- `UML_OS.Release.EmitVerdict_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Release.CollectEvidence_v1`  
**Signature:** `(release_candidate_id -> evidence_bundle, evidence_bundle_hash)`  
**Purity class:** IO  
**Determinism:** deterministic.
**Definition:** Collects canonical release evidence and emits deterministic `evidence_bundle_hash`.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `EVIDENCE_MISSING`, `ARTIFACT_MISSING`.

**Operator:** `UML_OS.Release.EvaluateGates_v1`  
**Signature:** `(evidence_bundle, gate_policy -> gate_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `GATE_POLICY_INVALID`.

**Operator:** `UML_OS.Release.EmitVerdict_v1`  
**Signature:** `(gate_report -> release_verdict)`  
**Purity class:** IO  
**Determinism:** deterministic.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `RELEASE_BLOCKED`.

---
## 6) Procedure
```text
1. CollectEvidence_v1
2. EvaluateGates_v1
3. EmitVerdict_v1
4. Return release_verdict
```

---
## 7) Trace & Metrics
### Logging rule
- Release-gate pipeline emits deterministic gate records.
### Trace schema
- `run_header`: release_candidate_id, gate_policy_hash
- `iter`: gate_id, status, evidence_hash
- `run_end`: release_verdict, report_hash
### Metric schema
- `gates_total`, `gates_passed`, `gates_failed`
### Comparability guarantee
- Comparable iff gate policy and evidence bundle are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- All required gates present and evaluated.
#### VII.B Operator test vectors (mandatory)
- Gate pass/fail boundary vectors.
#### VII.C Golden traces (mandatory)
- Golden release-gate traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for release verdict and report hash.
#### VIII.B Allowed refactor categories
- Tooling/aggregation changes preserving gate semantics.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of gate reports on fixed evidence.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- `gate_cursor`, `completed_gate_ids[]`, `partial_gate_report_hash`, and `evidence_bundle_hash`.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed gate evaluation must produce identical verdict.

---
## 11) External Verification Gate Extensions (Normative)
- For `enterprise` and `regulated` release profiles, release gates MUST include:
  - backend certification evidence bundle verification,
  - artifact-store certification evidence bundle verification,
  - observability mapping hash verification,
  - platform-tier performance baseline verification.
- For `regulated` profile, release gates MUST additionally include:
  - mandatory chaos/recovery proof-pack verification.
- Missing any required external-verification artifact is deterministic release block.

---
## 12) Conformance Coverage Gate (Normative)
- Conformance coverage is a hard release requirement (not advisory).
- Minimum required coverage by profile:
  - `core`: `coverage_pct >= 95.0` and zero `required_operator` blockers.
  - `enterprise`: `coverage_pct >= 98.0` and zero blockers.
  - `regulated`: `coverage_pct == 100.0` and zero blockers.
- Coverage source of truth:
  - `docs/layer4-implementation/Operator-Conformance-Matrix.md` output bundle.
- Any unresolved blocker in required operator sets MUST produce deterministic `RELEASE_BLOCKED`.

- External-auditor references:
  - `docs/layer4-implementation/Evidence-Catalog.md`
  - `docs/layer4-implementation/Benchmark-Evidence-Spec.md`
  - `docs/layer4-implementation/Security-Case-Template.md`

## 13) Pinned Gate Fixture Inputs (Normative)
- Release-gate dry-run pin set:
  - `contracts/catalog-manifest.json`
  - `fixtures/hello-core/fixture-manifest.json`
  - `goldens/hello-core/golden-manifest.json`
  - `vectors/hello-core/vectors-manifest.json`
- Deterministic verification command:
  - `python tools/verify_doc_artifacts.py`

FILE: layer3-tests/Storage-Recovery-Test-Matrix.md
==================================================
# UML_OS Storage Recovery Test Matrix
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.StorageRecoveryMatrix_v1`  
**Purpose (1 sentence):** Define deterministic storage crash-recovery tests for WAL segments, commit pointers, and artifact integrity.  
**Spec Version:** `UML_OS.Test.StorageRecoveryMatrix_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Storage reliability testing.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.StorageRecoveryMatrix_v1`
- **Purpose (1 sentence):** Deterministic storage recovery test contract.
### 0.A Objective Semantics
- minimize unrecoverable commit states.
### 0.B Reproducibility Contract
- scenario verdict reproducible from `(scenario_id, backend_profile_hash, fixtures_hash)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- sequence ids and counters as uint64.
### 0.D Ordering and Tie-Break Policy
- scenarios ordered by `(backend, scenario_id)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- scenarios parallelizable with deterministic report merge.
### 0.F Environment and Dependency Policy
- backend adapter versions pinned.
### 0.G Operator Manifest
- `UML_OS.Test.InjectStorageFault_v1`
- `UML_OS.Test.RunRecoveryProcedure_v1`
- `UML_OS.Test.VerifyRecoveryInvariants_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Test.*` and `UML_OS.Storage.*`.
### 0.I Outputs and Metric Schema
- outputs: `(scenario_reports, matrix_verdict)`.
### 0.J Spec Lifecycle Governance
- scenario semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- unrecoverable states are deterministic failures.
### 0.L Input/Data Provenance
- fixtures and expected results are hash-addressed.
### 0.Z EQC Mandatory Declarations Addendum
- seed space: `uint64` (for deterministic fault schedule selection).
- PRNG family: `Philox4x32-10` when stochastic scenario expansion is enabled.
- replay guarantee: identical `(scenario_id, backend_profile_hash, fixtures_hash)` yields identical scenario verdict.
- floating-point format: IEEE-754 binary64 for informational metrics only.
- NaN/Inf policy: invalid in recorded metrics.
- default tolerances: N/A for invariant pass/fail.
- determinism target: E0 for per-scenario verdict and invariant failure ids.

---
## 2) System Model
### I.A Persistent State
- scenario catalog and backend capability matrix.
### I.B Inputs and Hyperparameters
- backend id, scenario set, strictness profile, fixtures set hash (`fixtures_hash`).
### I.C Constraints and Feasible Set
- commit pointer logic required for all backends.
### I.D Transient Variables
- injected fault records and recovery outputs.
### I.E Invariants and Assertions
- committed runs must remain verifiable after recovery.

---
## 3) Initialization
1. Load scenario matrix and backend profile.
2. Initialize isolated test storage namespace.
3. Seed deterministic fault injector.

---
## 4) Operator Manifest
- `UML_OS.Test.InjectStorageFault_v1`
- `UML_OS.Test.RunRecoveryProcedure_v1`
- `UML_OS.Test.VerifyRecoveryInvariants_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.InjectStorageFault_v1`
**Signature:** `(scenario_id, backend_id, storage_state -> faulted_storage_state)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** Injects the declared deterministic storage fault for the scenario.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `SCENARIO_INVALID`, `BACKEND_UNSUPPORTED`.

**Operator:** `UML_OS.Test.RunRecoveryProcedure_v1`
**Signature:** `(faulted_storage_state, recovery_policy -> recovery_result)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** Runs deterministic recovery procedure (WAL scan/replay/rollback as declared).
**allowed_error_codes:** `CONTRACT_VIOLATION`, `RECOVERY_FAILURE`, `WAL_CORRUPTION`.

**Operator:** `UML_OS.Test.VerifyRecoveryInvariants_v1`  
**Signature:** `(recovery_result, expected_invariants -> verdict)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Verifies WAL chain integrity, pointer correctness, and artifact hash coherence.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `INVARIANT_VIOLATION`.

---
## 6) Procedure
```text
1. InjectStorageFault_v1
2. RunRecoveryProcedure_v1
3. VerifyRecoveryInvariants_v1
4. Record scenario verdict
```

---
## 7) Trace & Metrics
- Metrics: `scenarios_total`, `scenarios_failed`, `recovery_time_ms` (informational only; excluded from deterministic verdict logic).
- Trace includes scenario id, backend id, invariant failures.

---
## 8) Validation
- baseline scenarios for local fs, s3-compatible, gcs-compatible adapters.
- deterministic fault replay tests.

---
## 9) Refactor & Equivalence
- E0 for per-scenario verdicts and invariant failure identities.

---
## 10) Checkpoint/Restore
- checkpoint stores `scenario_cursor`, `completed_scenarios[]`, `partial_matrix_report_hash`, and `backend_profile_hash`.
- restore resumes matrix deterministically.

FILE: layer3-tests/Test-Plan.md
===============================
# UML_OS Validation and Test Plan
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.TestPlanOrchestrator_v1`  
**Purpose (1 sentence):** Execute deterministic validation suites that certify EQC invariants, operator behavior, and replay correctness.  
**Spec Version:** `UML_OS.Implementation.TestPlanOrchestrator_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Deterministic verification and regression control.

---

## 1) Header & Global Semantics

### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.TestPlanOrchestrator_v1`
- **Purpose (1 sentence):** Deterministic test orchestration.
- **Spec Version:** `UML_OS.Implementation.TestPlanOrchestrator_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Reproducible validation execution.

### 0.A Objective Semantics
- Optimization sense: `MINIMIZE` failures.
- Objective type: `Scalar` (`failed_tests`).
- Comparison: fewer failures is better; ties by lower p95 regression.

### 0.B Reproducibility Contract
- Seed space: `seed âˆˆ {0..2^64-1}` for stochastic tests.
- PRNG family: Philox4x32-10.
- Randomness locality: only stochastic test operators.
- Replay guarantee: replayable given `(test_manifest_hash, seed_set, runtime_env_hash)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.

### 0.C Numeric Policy
- Critical verdicts are boolean/integer exact.
- Performance thresholds use binary64 comparisons.
- Approx-equality: threshold-defined tolerance for performance metrics.

### 0.D Ordering and Tie-Break Policy
- Test order is deterministic by suite then test_id.
- Tie-break for flaky-equivalent outcomes: lowest test_id.

### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel test execution allowed only with deterministic merge of reports.
- Aggregate counts reduced in deterministic order.

### 0.F Environment and Dependency Policy
- Reference runtime: pinned CI image.
- Determinism level: `BITWISE` for pass/fail reports; `TOLERANCE` for perf metrics.

### 0.G Operator Manifest
- `UML_OS.Test.RunUnitSuite_v1`
- `UML_OS.Test.RunIntegrationSuite_v1`
- `UML_OS.Test.RunGoldenTraceSuite_v1`
- `UML_OS.Test.RunReplaySuite_v1`
- `UML_OS.Test.AggregateResults_v1`
- `UML_OS.Error.Emit_v1`

### 0.H Namespacing and Packaging
- Fully-qualified test operators required.

### 0.I Outputs and Metric Schema
- Outputs: `(test_report, verdict)`.
- Metrics: `passed`, `failed`, `skipped`, `p95_regression`, `determinism_failures`.
- Completion status: `success | failed`.

### 0.J Spec Lifecycle Governance
- Threshold/policy changes require version bump and migration note.

### 0.K Failure and Error Semantics
- Abort-only on infrastructure failures; per-test failures recorded deterministically.

### 0.L Input/Data Provenance
- Test fixtures and golden traces must be hash-addressed.

---

### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model

### I.A Persistent State
- `test_registry`, `golden_registry`.

### I.B Inputs and Hyperparameters
- suites, thresholds, seed sets, environment metadata.

### I.C Constraints and Feasible Set
- Unconstrained; validity determined by threshold policies.

### I.D Transient Variables
- per-suite reports, aggregate counters.

### I.E Invariants and Assertions
- deterministic ordering and complete report emission.

### II.F Test Manifest and Golden Inventory (Concrete)
- Test manifest required fields:
  - `manifest_version:string`
  - `suites:array<string>`
  - `seed_set:array<uint64>`
  - `thresholds:object`
  - `golden_ids:array<string>`
- Golden inventory (minimum):
  - `golden_kernel_train_v1` -> `sha256:aa01aa01aa01aa01aa01aa01aa01aa01aa01aa01aa01aa01aa01aa01aa01aa01`
  - `golden_data_nextbatch_v2` -> `sha256:bb02bb02bb02bb02bb02bb02bb02bb02bb02bb02bb02bb02bb02bb02bb02bb02`
  - `golden_modelir_exec_v1` -> `sha256:cc03cc03cc03cc03cc03cc03cc03cc03cc03cc03cc03cc03cc03cc03cc03cc03`
  - `golden_dp_apply_v3` -> `sha256:dd04dd04dd04dd04dd04dd04dd04dd04dd04dd04dd04dd04dd04dd04dd04dd04`
- Deterministic pass/fail rule: pass iff all required suites pass and no E0 field mismatch against referenced golden IDs.
- Required hardening suites:
  - property/fuzz tests for IR validation, schema parsing, checkpoint decode, and TMMU planner invariants,
  - distributed chaos tests (rank loss, network partition, delayed collective),
  - replay divergence minimization tests at scale (multi-rank long-horizon).

### II.G Property Invariants (Normative)
- IR invariants: DAG acyclic, edge typing valid, shape constraints satisfied, gradient dependency graph consistent.
- Schema invariants: normalization idempotent, unknown key handling follows `schema_mode`.
- TMMU invariants: no overlap on reused live intervals, alias/in-place constraints enforced, replan triggers deterministic.
- DP invariants: epsilon monotonicity, delta bounds respected, no negative budgets, stable accountant state hash under replay.

### II.H Fuzz Harness Inventory (Normative)
- Manifest parser fuzzer (`max_input_bytes` declared, crash=fail).
- IR ingestion fuzzer (`max_nodes` declared, crash=fail).
- Checkpoint loader fuzzer (`max_blob_bytes` declared, crash=fail).
- Trace parser fuzzer (`max_record_bytes` declared, crash=fail).
- Sanitizer baseline: memory/UB sanitizers required in fuzz CI profile.

### II.I Registry Completeness Lint (Normative)
- Parse all docs for `Failure codes:` and `allowed_error_codes`.
- Fail build if any referenced code is absent from `docs/layer1-foundation/Error-Codes.md`.

### II.J Determinism Regression Matrix (Normative)
- Required replay matrices:
  - same machine / same driver (E0 required),
  - same GPU class / different driver patch (E1 policy),
  - cross-GPU class (E1 only, explicit tolerances).
- Pass/fail policy:
  - E0 fields must be bitwise equal.
  - E1 fields must remain within declared per-field tolerance bands.

### II.K Spec Lint Gate (Normative)
- `tools/spec_lint.py` is a mandatory pre-test CI gate and must run before unit/integration/replay/performance suites.
- `spec_lint` must verify at minimum:
  - operator reference completeness across kernel/orchestrator/reference docs against canonical operator registry artifact,
  - interface digest completeness (`request_schema_digest`, `response_schema_digest`, `signature_digest`, `side_effects`, `allowed_error_codes`, `required_capabilities`),
  - error-code closure (all referenced codes must exist in `docs/layer1-foundation/Error-Codes.md` with valid severity enum),
  - no placeholder digests in normative fields (must be 64-hex where declared),
  - contract-critical hash primitive and domain-separation consistency.
- CI must fail deterministically on any `spec_lint` violation before running other suites.

---

## 3) Initialization

1. Load test manifest.
2. Validate fixture hashes.
3. Initialize deterministic run order.

---

## 4) Operator Manifest

- `UML_OS.Test.RunUnitSuite_v1`
- `UML_OS.Test.RunIntegrationSuite_v1`
- `UML_OS.Test.RunGoldenTraceSuite_v1`
- `UML_OS.Test.RunReplaySuite_v1`
- `UML_OS.Test.AggregateResults_v1`
- `UML_OS.Error.Emit_v1`

---

## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

**Operator:** `UML_OS.Test.RunUnitSuite_v1`  
**Category:** IO  
**Signature:** `(suite_config -> suite_report)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** executes ordered unit tests and records outcomes.  
**Preconditions / Postconditions:** fixtures available.  
**Edge cases:** skipped tests.  
**Numerical considerations:** threshold comparisons in binary64 where needed.  
**Ordering/tie handling:** test_id ascending.  
**Complexity note:** O(number_of_tests).  
**Failure behavior:** deterministic failure logs.  
**Dependencies:** test runner backend.  
**Test vectors:** synthetic pass/fail suites.

**Operator:** `UML_OS.Test.RunGoldenTraceSuite_v1`  
**Category:** IO  
**Signature:** `(golden_config -> golden_report)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** compares produced traces against golden references.  
**Preconditions / Postconditions:** golden artifacts present.  
**Edge cases:** missing optional trace fields.  
**Numerical considerations:** exact for E0 fields; tolerance for E1 fields.  
**Ordering/tie handling:** trace step order strict.  
**Complexity note:** O(trace_size).  
**Failure behavior:** deterministic mismatch reports.  
**Dependencies:** trace comparator.  
**Test vectors:** known golden mismatch/pass cases.

**Operator:** `UML_OS.Test.AggregateResults_v1`  
**Category:** IO  
**Signature:** `(suite_reports -> test_report, verdict)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** deterministic aggregation and verdict computation.  
**Preconditions / Postconditions:** all suite reports available.  
**Edge cases:** empty suite set.  
**Numerical considerations:** deterministic reduction order.  
**Ordering/tie handling:** suite-name lexical merge.  
**Complexity note:** O(total_cases).  
**Failure behavior:** abort on malformed report.  
**Dependencies:** suite schemas.  
**Test vectors:** aggregate snapshots.

---

**Operator:** `UML_OS.Test.RunIntegrationSuite_v1`  
**Category:** Test  
**Signature:** `(integration_manifest -> integration_report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** Executes deterministic integration scenarios across kernel, data, model, memory, and DP boundaries.
**Preconditions / Postconditions:** integration fixtures and dependency contracts are available; output report includes per-scenario status and hashes.  
**Edge cases:** optional components disabled by profile.  
**Numerical considerations:** E0 fields exact; E1 metrics use declared tolerances only.  
**Ordering/tie handling:** scenario_id ascending deterministic execution.  
**Complexity note:** O(number_of_integration_scenarios).  
**Failure behavior:** abort on malformed integration manifest; otherwise deterministic failure records in report.  
**Dependencies:** kernel/component contracts and trace schema.  
**Test vectors:** mixed pass/fail integration matrices.
`integration_manifest` schema (normative): `{suite_id:string, scenarios:array<string>, fixtures_hash:bytes32, comparison_profile:object}`.

**Operator:** `UML_OS.Test.RunReplaySuite_v1`  
**Category:** Test  
**Signature:** `(replay_manifest -> replay_report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** Validates replay-token determinism, RNG locality, and checkpoint-restore replay guarantees.
**Preconditions / Postconditions:** replay traces/checkpoints and token definitions are available; output report includes replay equivalence verdicts.  
**Edge cases:** missing intermediate checkpoint segments.  
**Numerical considerations:** replay-critical comparisons are bitwise for E0 fields.  
**Ordering/tie handling:** replay-case order is deterministic by replay_case_id ascending.  
**Complexity note:** O(total_replayed_steps).  
**Failure behavior:** abort on invalid replay manifest; deterministic mismatch reports otherwise.  
**Dependencies:** Replay-Determinism and Checkpoint-Schema contracts.  
**Test vectors:** fixed-token replay pass/mismatch scenarios.

## 6) Procedure

```text
1. RunUnitSuite_v1(suite_config)
2. RunIntegrationSuite_v1(integration_manifest)
3. RunGoldenTraceSuite_v1(golden_config)
4. RunReplaySuite_v1(replay_manifest)
5. AggregateResults_v1(suite_reports)
6. Return report + verdict
```

---

## 7) Trace & Metrics

### Logging rule
Every executed test emits deterministic result records.

### Trace schema
- `run_header`: manifest_hash, runtime_env_hash, replay_token
- `iter`: suite, test_id, result
- `run_end`: verdict, aggregate counts

### Metric schema
- `passed`, `failed`, `skipped`, `p95_regression`, `determinism_failures`

### Comparability guarantee
Comparable iff same suites, fixtures, thresholds, and merge policy.

---

## 8) Validation

#### VII.A Lint rules (mandatory)
Covers symbol completeness, no hidden globals, deterministic order, trace compliance.
- Namespace hygiene rule: fail if any operator token matches flat form `UML_OS\\.[A-Za-z0-9_]+_v\\d+`; only `UML_OS.<subsystem>.<name>_v<integer>` is allowed.

#### VII.B Operator test vectors (mandatory)
Includes suite-runner and aggregator vectors.
Includes orchestrator idempotency vectors: duplicate dispatch/ack events must commit exactly once and return the same transition record for identical `idempotency_key`.
Includes deterministic fault-injection recovery vectors:
- crash after trace write but before checkpoint,
- crash after checkpoint write but before certificate,
- duplicate dispatch/retry storms,
- partial shard write and interrupted commit.
Each fault-injection vector must assert deterministic recovery, exactly-once visible commit semantics, and certificate/artifact hash coherence.

#### VII.C Golden traces (mandatory)
Golden report snapshots for canonical test manifests.

---

## 9) Refactor & Equivalence

#### VIII.A Equivalence levels
- E0 for verdict and aggregate counters.

#### VIII.B Allowed refactor categories
- Runner implementation changes preserving outputs.

#### VIII.C Equivalence test procedure (mandatory)
Exact report diff against golden baseline.

---

## 10) Checkpoint/Restore

### Checkpoint contents
- partial suite reports and deterministic run cursor.

### Serialization
- deterministic canonical CBOR.

### Restore semantics
- resume yields identical final report and verdict.

FILE: layer3-tests/Test-Vectors-Catalog.md
==========================================
# UML_OS Test Vectors Catalog Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.VectorsCatalog_v1`  
**Purpose (1 sentence):** Define authoritative operator-level input/output vectors and expected hashes/errors for deterministic conformance testing.  
**Spec Version:** `UML_OS.Test.VectorsCatalog_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Golden-vector governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.VectorsCatalog_v1`
- **Purpose (1 sentence):** Canonical test vector registry.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize ambiguous test expectations across implementations.
### 0.B Reproducibility Contract
- vectors and expected outputs are content-addressed and immutable.
- replayable given `(vector_id, operator_id, implementation_version)`.
- hash policy: all hashes are `SHA-256(CBOR_CANONICAL(...))` unless explicitly overridden.
### 0.C Numeric Policy
- expected numeric outputs include explicit dtype and tolerance class.
### 0.D Ordering and Tie-Break Policy
- vectors are ordered by `(operator_id, vector_id)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- suite merge order is deterministic lexical order.
### 0.F Environment and Dependency Policy
- vector files use canonical serialization and hashes.
### 0.G Operator Manifest
- `UML_OS.Test.VectorLoad_v1`
- `UML_OS.Test.VectorExecute_v1`
- `UML_OS.Test.VectorVerify_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `vectors/<operator>/<vector_id>.cbor`.
### 0.I Outputs and Metric Schema
- outputs: `(verification_report)` and mismatch diagnostics.
### 0.J Spec Lifecycle Governance
- vector content changes are MAJOR unless additive new vector IDs.
### 0.K Failure and Error Semantics
- mismatch emits deterministic error records.
### 0.L Input/Data Provenance
- each vector stores source-spec hash and operator signature digest.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- vector registry and golden hash index.
### I.B Inputs and Hyperparameters
- operator_id, vector_id, implementation target.
### I.C Constraints and Feasible Set
- vector must match declared operator signature digest.
### I.D Transient Variables
- run outputs, diff report.
### I.E Invariants and Assertions
- exact expected outputs for E0 fields.

### II.F Vector Record Schema (Normative)
- `operator_id:string`
- `vector_id:string`
- `input_payload_hash:bytes32`
- `expected_output_hash:bytes32`
- `expected_error_code?:string`
- `determinism_class: "E0" | "E1"`
- `signature_digest:bytes32`
- `canonical_encoding_version:string` (`CanonicalSerialization_v1`)

### II.G Canonical Encoding Vector Set (Normative)
- Catalog must include vectors for canonical serialization and hashing:
  - canonical CBOR map key ordering,
  - float64 encoding edge cases,
  - fixed-length digest validation (`bytes32`),
  - domain-separated hash tuple examples.
- These vectors are mandatory for conformance of hashing/signature-related operators.

### II.H `vectors_catalog.cbor` Schema (Normative)
- Authoritative machine-readable artifact: `contracts/vectors_catalog.cbor`.
- Schema:
  - `catalog_version:string`
  - `operators: map<string, array<map>>`, where each vector map contains:
    - `vector_id:string`
    - `input_digest:digest_ref`
    - `expected_output_digest:digest_ref`
    - `expected_error_code?:string`
    - `determinism_class: "E0" | "E1"`
    - `signature_digest:digest_ref`
    - `notes?:string`
- Catalog hash:
  - `vectors_catalog_hash = SHA-256(CBOR_CANONICAL(vectors_catalog_map))`.

### II.I Minimum Baseline Vector Set (Normative)
- Required baseline vectors:
  - canonical CBOR map ordering edge cases (`len-first` ordering),
  - trace hash-chain over a 3-record sequence (`trace_chain_v1`),
  - WAL chain plus terminal `FINALIZE` commit record hash,
  - `digest_ref` resolution (`sha256:<hex64>` inline and `sha256:<label>` lookup),
  - `NextBatch_v2` deterministic sampling on at least two small datasets and one distributed shard case.

---
## 3) Initialization
1. Load vector registry.
2. Validate hash/index integrity.
3. Bind operator executor.

---
## 4) Operator Manifest
- `UML_OS.Test.VectorLoad_v1`
- `UML_OS.Test.VectorExecute_v1`
- `UML_OS.Test.VectorVerify_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.VectorLoad_v1`
**Category:** Test
**Signature:** `(operator_id, vector_id -> expected_vector)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** loads canonical vector payload and expected outputs/errors by id.
**allowed_error_codes:** `VECTOR_NOT_FOUND`, `CONTRACT_VIOLATION`.

**Operator:** `UML_OS.Test.VectorExecute_v1`
**Category:** Test
**Signature:** `(implementation, input_payload -> actual_output)`
**Purity class:** IO
**Determinism:** deterministic for identical implementation+input payload
**Definition:** executes the implementation against vector input payload.
**allowed_error_codes:** `CONTRACT_VIOLATION`, `PRIMITIVE_UNSUPPORTED`, `EXECUTION_FAILURE`.

**Operator:** `UML_OS.Test.VectorVerify_v1`  
**Category:** Test  
**Signature:** `(actual_output, expected_vector -> verify_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** verifies outputs/errors against canonical vector expectations.
**allowed_error_codes:** `VECTOR_MISMATCH`, `EXPECTED_ERROR_MISMATCH`, `CONTRACT_VIOLATION`.

---
## 6) Procedure
```text
1. VectorLoad_v1(operator_id, vector_id)
2. VectorExecute_v1(implementation, input_payload)
3. VectorVerify_v1(actual, expected)
4. Emit verify_report
```

---
## 7) Trace & Metrics
### Logging rule
- every vector execution emits deterministic verification records.
### Trace schema
- `run_header`: operator_id, vector_id
- `iter`: step, status
- `run_end`: verify_status, mismatch_hash?
### Metric schema
- `passed`, `failed`, `mismatch_count`
### Comparability guarantee
- comparable iff vector payloads and signature digests match.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- no duplicate vector IDs per operator; required fields complete.
#### VII.B Operator test vectors (mandatory)
- self-test vectors for loader/executor/verifier.
#### VII.C Golden traces (mandatory)
- golden verify traces for representative vectors.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for verifier verdict and mismatch report.
#### VIII.B Allowed refactor categories
- storage/indexing changes preserving vector contents and IDs.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare of verify_report on golden vectors.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- vector-run cursor and partial batch verification state.
### Serialization
- deterministic CBOR.
### Restore semantics
- resumed vector run yields identical final verify report.

FILE: layer4-implementation/API-Lifecycle-and-Deprecation-Policy.md
===================================================================
# UML_OS API Lifecycle and Deprecation Policy
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.API.LifecyclePolicy_v1`  
**Purpose (1 sentence):** Define customer-facing API compatibility, deprecation windows, and migration obligations.  
**Spec Version:** `UML_OS.API.LifecyclePolicy_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) Compatibility Tiers
- `stable`: backwards-compatible within MAJOR line.
- `lts`: extended support window.
- `experimental`: no long-term stability guarantee.

## 2) Deprecation Windows
- Minimum support after deprecation announcement: 18 months.
- API migration operators must be available for at least 2 MAJOR releases from announcement.

## 3) Breaking Change Requirements
- MAJOR version bump.
- migration operator and migration vectors.
- customer-facing migration guide and compatibility table update.

## 4) Service Interface Guarantees
- OpenAPI/Protobuf artifacts are normative surfaces and versioned.
- generated SDKs must remain compatible within declared window.

## 5) Normative Example
- `NextBatch_v1 -> NextBatch_v2` transitions must declare migration operator and support window in release notes and compatibility matrix.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS API Lifecycle and Deprecation Policy" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Architecture-Decisions-Log.md
=========================================================
# UML_OS Architecture Decisions Log Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Architecture.DecisionLog_v1`  
**Purpose (1 sentence):** Define deterministic recording, hashing, and lifecycle of architecture decisions (ADR-style) for implementation governance.  
**Spec Version:** `UML_OS.Architecture.DecisionLog_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Architecture governance and traceability.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Architecture.DecisionLog_v1`
- **Purpose (1 sentence):** Deterministic architecture decision contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: prevent undocumented architecture divergence.
### 0.B Reproducibility Contract
- Replayable given `(decision_log_hash, decision_id, context_hash)`.
- `context_hash = SHA-256(CBOR_CANONICAL(context_scope))`, where `context_scope` contains repository root hash, active policy profile id, and affected subsystem set.
### 0.C Numeric Policy
- Decision version and sequence fields are exact integers.
### 0.D Ordering and Tie-Break Policy
- Decision records sorted by `(decision_seq, decision_id)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Concurrent proposals allowed; accept/reject merge deterministic.
### 0.F Environment and Dependency Policy
- Decisions that affect contracts must link affected contract hashes.
### 0.G Operator Manifest
- `UML_OS.Arch.DecisionCreate_v1`
- `UML_OS.Arch.DecisionSupersede_v1`
- `UML_OS.Arch.DecisionValidateLinks_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `adr/` and `decision_log.cbor` canonical roots.
### 0.I Outputs and Metric Schema
- Outputs: `(decision_report, decision_log_hash)`
- Metrics: `decisions_total`, `superseded_total`
### 0.J Spec Lifecycle Governance
- Decision schema changes are MAJOR.
### 0.K Failure and Error Semantics
- Broken links or duplicate ids fail deterministically.
### 0.L Input/Data Provenance
- Decision records must reference author, context, and affected artifacts.

---
## 2) System Model
### I.A Persistent State
- Architecture decision log.
### I.B Inputs and Hyperparameters
- Decision proposal records and supersession links.

### II.F Decision Record Schema (Normative)
- `decision_record = {`
  - `decision_id:string`,
  - `decision_seq:uint64`,
  - `title:string`,
  - `author:string`,
  - `created_at_utc:string`,
  - `context_scope:map`,
  - `affected_artifacts:array<string>`,
  - `status:enum("PROPOSED","ACCEPTED","REJECTED","SUPERSEDED")`,
  - `supersedes?:string`,
  - `rationale_hash:bytes32`
- `}`
- `created_at_utc` must be ISO 8601 UTC (`YYYY-MM-DDTHH:MM:SSZ`), no fractional seconds.
### I.C Constraints and Feasible Set
- Valid iff decision ids unique and links resolvable.
### I.D Transient Variables
- validation diagnostics and link graph.
### I.E Invariants and Assertions
- Decision history is append-only.

---
## 3) Initialization
1. Load decision log.
2. Validate schema and link graph.
3. Build canonical ordered view.

---
## 4) Operator Manifest
- `UML_OS.Arch.DecisionCreate_v1`
- `UML_OS.Arch.DecisionSupersede_v1`
- `UML_OS.Arch.DecisionValidateLinks_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Arch.DecisionCreate_v1`  
**Signature:** `(decision_record -> decision_id)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.Arch.DecisionSupersede_v1`  
**Signature:** `(old_decision_id, new_decision_id -> supersede_record)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.Arch.DecisionValidateLinks_v1`  
**Signature:** `(decision_log -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. DecisionCreate_v1
2. DecisionValidateLinks_v1
3. Optional DecisionSupersede_v1
4. Build canonical decision report
5. decision_log_hash <- SHA-256(CBOR_CANONICAL(decision_log))
6. return (decision_report, decision_log_hash)
```

---
## 7) Trace & Metrics
### Logging rule
- Decision operations emit deterministic governance records.
### Trace schema
- `run_header`: decision_log_version
- `iter`: decision_id, action, status
- `run_end`: decision_log_hash
### Metric schema
- `decisions_total`, `superseded_total`
### Comparability guarantee
- Comparable iff same decision set and order.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Unique ids and valid supersession graph.
#### VII.B Operator test vectors (mandatory)
- Create/supersede/link-validation vectors.
#### VII.C Golden traces (mandatory)
- Golden decision-log traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for decision log hash and validation report.
#### VIII.B Allowed refactor categories
- Storage/index refactors preserving log semantics.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of canonical decision log output.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Decision cursor and log hash.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed operations preserve identical log state.

FILE: layer4-implementation/Artifact-Store-Adapter-Guide.md
===========================================================
# UML_OS Artifact Store Adapter Guide
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Storage.ArtifactStoreAdapterGuide_v1`  
**Purpose (1 sentence):** Define deterministic adapter behavior for local/object-store artifact persistence, commit pointers, and recovery-safe semantics.  
**Spec Version:** `UML_OS.Storage.ArtifactStoreAdapterGuide_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Storage adapter implementation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Storage.ArtifactStoreAdapterGuide_v1`
- **Purpose (1 sentence):** Deterministic storage adapter contract.
### 0.A Objective Semantics
- minimize commit inconsistency and recovery ambiguity.
### 0.B Reproducibility Contract
- storage outcomes reproducible from `(object_keys, object_hashes, commit_policy_hash)`.
- `object_keys` must be canonicalized as lexicographically sorted UTF-8 strings before any hash/plan computation.
### 0.C Numeric Policy
- byte counts and sequence ids are uint64 exact.
### 0.D Ordering and Tie-Break Policy
- object writes ordered by deterministic key order.
### 0.E Parallel, Concurrency, and Reduction Policy
- data objects can upload in parallel; commit-pointer publish is single-writer.
### 0.F Environment and Dependency Policy
- adapter must declare backend type and consistency model.
### 0.G Operator Manifest
- `UML_OS.Storage.PutImmutableObject_v1`
- `UML_OS.Storage.PublishCommitPointer_v1`
- `UML_OS.Storage.ValidateCommittedRun_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Storage.*` namespace.
### 0.I Outputs and Metric Schema
- outputs: `(storage_report, commit_status, recovery_report)`.
### 0.J Spec Lifecycle Governance
- commit-pointer semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- partial commit states must fail closed deterministically.
### 0.L Input/Data Provenance
- all objects referenced by content hash.

---
## 2) System Model
### I.A Persistent State
- object index and commit-pointer map.
### I.B Inputs and Hyperparameters
- object set, run id, tenant id, backend mode.
### I.C Constraints and Feasible Set
- COMMITTED pointer publish must be conditional create-if-absent.
### I.D Transient Variables
- upload status and pointer payload.
### I.E Invariants and Assertions
- immutable objects never overwritten.

---
## 3) Initialization
1. Resolve backend adapter policy.
2. Initialize object index.
3. Validate write preconditions.

---
## 4) Operator Manifest
- `UML_OS.Storage.PutImmutableObject_v1`
- `UML_OS.Storage.PublishCommitPointer_v1`
- `UML_OS.Storage.ValidateCommittedRun_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Storage.PutImmutableObject_v1`
**Signature:** `(object_key, object_bytes, expected_hash -> put_status)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** Writes object exactly once under immutable semantics; validates `SHA-256(object_bytes) == expected_hash` before commit.

**Operator:** `UML_OS.Storage.PublishCommitPointer_v1`  
**Signature:** `(tenant_id, run_id, pointer_payload -> publish_status)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** Publishes COMMITTED pointer atomically using conditional semantics.

**Operator:** `UML_OS.Storage.ValidateCommittedRun_v1`
**Signature:** `(tenant_id, run_id, pointer_payload, object_index -> recovery_report, commit_status)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** Verifies that all pointer-linked objects exist and hashes match; returns deterministic `commit_status`.

External operator reference: `UML_OS.Error.Emit_v1` is defined in `docs/layer1-foundation/Error-Codes.md`.

---
## 6) Procedure
```text
1. Sort `object_keys` canonically
2. For each key: PutImmutableObject_v1
3. Publish COMMITTED pointer via conditional create
4. ValidateCommittedRun_v1
5. return (storage_report, commit_status, recovery_report)
```

---
## 7) Trace & Metrics
- Metrics: `objects_written`, `bytes_written`, `pointer_publish_attempts`, `recovery_events`.
- Trace includes pointer payload hash and commit status.

---
## 8) Validation
- backend matrix tests (local fs, s3-compatible, gcs-compatible).
- crash-recovery tests for partial upload states.

### VIII.D External Certification Program (Normative)
- Certification label format:
  - `UML_OS Certified Artifact Store v<adapter_contract_version>`.
- Required vendor-publishable evidence bundle:
  - backend matrix suite reports,
  - crash-recovery report hash,
  - commit-pointer integrity report hash,
  - `storage_report`, `commit_status`, `recovery_report`,
  - signed certification statement hash.
- Certification evidence must be independently verifiable through:
  - `docs/layer3-tests/Conformance-Harness-Guide.md`
  - `docs/layer4-implementation/Release-Evidence-Assembler.md`.

---
## 9) Refactor & Equivalence
- E0 for commit-pointer payload and committed artifact linkage.

---
## 10) Checkpoint/Restore
- checkpoint stores upload cursor and pending pointer payload hash.
- restore resumes upload/commit deterministically.

FILE: layer4-implementation/Backend-Adapter-Guide.md
====================================================
# UML_OS Backend Adapter Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Backend.AdapterContract_v1`  
**Purpose (1 sentence):** Define required backend adapter primitives, determinism guarantees, and certification checks for UML_OS driver integration.  
**Spec Version:** `UML_OS.Backend.AdapterContract_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Driver integration and compliance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Backend.AdapterContract_v1`
- **Purpose (1 sentence):** Deterministic backend adapter requirements.
- **Spec Version:** `UML_OS.Backend.AdapterContract_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Backend certification.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize contract violations and reproducibility drift.
### 0.B Reproducibility Contract
- Replayable given `(backend_binary_hash, driver_runtime_fingerprint_hash, adapter_version, test_manifest_hash)`.
### 0.C Numeric Policy
- Critical operations must satisfy binary64 deterministic requirements.
### 0.D Ordering and Tie-Break Policy
- Primitive dispatch order follows ModelIR execution order.
### 0.E Parallel, Concurrency, and Reduction Policy
- Deterministic collective ordering and reductions required.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for critical paths; `TOLERANCE` where declared.
### 0.G Operator Manifest
- `UML_OS.Backend.ValidatePrimitiveCoverage_v1`
- `UML_OS.Backend.RunReproducibilitySuite_v1`
- `UML_OS.Backend.VerifyDriverHash_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Backend operators fully-qualified and versioned.
### 0.I Outputs and Metric Schema
- Outputs: `(adapter_report, certification_status)`.
- Metrics: `covered_primitives`, `e0_pass_rate`, `e1_pass_rate`.
- Completion status: `success | failed`.
- `adapter_report` must include `primitive_semantics_hash` and `determinism_compliance_report_hash`.
### 0.J Spec Lifecycle Governance
- Primitive contract changes require MAJOR bump.
### 0.K Failure and Error Semantics
- Abort on coverage gap, determinism failure, hash mismatch.
### 0.L Input/Data Provenance
- Driver binary, manifest, and test artifacts must be hash-addressed.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.


## 2) System Model
### I.A Persistent State
- driver certification registry.
### I.B Inputs and Hyperparameters
- driver binaries, primitive tables, test manifests.
### I.C Constraints and Feasible Set
- Valid if coverage + reproducibility criteria pass.
### I.D Transient Variables
- per-test verdicts and mismatch diagnostics.
### I.E Invariants and Assertions
- declared primitives map 1:1 to implemented dispatch handlers.

### II.F Required Primitive Catalog
| primitive | determinism_tier_required | allowed_algorithms | required_flags | required_tests |
|---|---|---|---|---|
| `matmul` | E0 same-build / E1 cross-hw | deterministic GEMM kernel set | fast-math off | exact tiny-graph gradient tests |
| `softmax` | E0 | stable log-sum-exp | deterministic reduction | overflow/underflow golden traces |
| `layernorm` | E0 | fixed-order reductions | deterministic accumulation | epsilon sensitivity vectors |
| `rng_gaussian` | E2 with deterministic offsets | Philox-based | declared stream ownership | replay offset tests |
| `all_reduce_sum` | E0 in class | fixed ring/tree order | stable rank order | multi-rank reproducibility suite |

### II.G GPU Determinism Profile (Required)
- TF32 policy must be explicitly declared (`enabled` or `disabled`) and captured in run metadata.
- cuDNN/cuBLAS algorithm selection must use deterministic allow-list only.
- Atomic reduction kernels are forbidden for E0 paths unless deterministic ordering is proven.
- NCCL/all-reduce ordering must be fixed and rank-stable; environment variables affecting ordering must be pinned and captured.
- Effective profile must be exported as `determinism_profile_hash` and bound into replay token context.

### II.H Backend Signature Lock (Normative)
- Backend-exposed syscall/primitive bindings must publish `signature_digest`:
- `signature_digest` rule is defined normatively in `docs/layer1-foundation/Operator-Registry-Schema.md` (`sig_v1` preimage over resolved digest values); backend adapter manifests must match exactly.
- Cross-file invariant:
  - `API-Interfaces.signature_digest(op) == Code-Generation-Mapping.signature_digest(op) == Backend-Adapter-Guide.signature_digest(op)` for every backend-exposed operator.
- Minimum backend-exposed digest set:
  - `UML_OS.Model.Forward_v2 -> sha256:17d85435fe2e601fe522b614938ea7853b9c36be14c8feb84f4e70e1e253bc74`
  - `UML_OS.Model.ModelIR_Executor_v1 -> sha256:ce1ec3e5cead31a92f46e79847332d3db0fdd824f2f3b6608987c77450a6de70`
  - `UML_OS.Backend.LoadDriver_v1 -> sha256:708fd111f6fc0a8f85853a4218ff9eba82ffc3da285266b15f6714a450728056`
- Proof-carrying backend requirements:
  - each primitive declares `primitive_semantics_hash`,
  - backend emits `determinism_compliance_report_hash`,
  - execution is forbidden when backend semantics hash set mismatches approved IR operator set hash.

### II.I Backend/Driver Identity Naming (Normative)
- Canonical identities:
  - `backend_binary_hash:bytes32` = hash of adapter binary/package artifact.
  - `driver_runtime_fingerprint_hash:bytes32` = hash of canonical runtime/driver fingerprint map.
- Multi-backend runs:
  - `backend_binary_hashes: map<string,bytes32>` with canonical key ordering.
- Deprecated aliases:
  - `driver_hash` and `backend_hash` are non-authoritative aliases and must not be used for checkpoint/certificate commitments.

### II.J External Certification Program (Normative)
- Certification label format:
  - `UML_OS Certified Backend v<adapter_contract_version>`.
- Mandatory publishable evidence bundle for certification:
  - `adapter_report`,
  - `primitive_semantics_hash`,
  - `determinism_compliance_report_hash`,
  - `backend_binary_hash`,
  - `driver_runtime_fingerprint_hash`,
  - conformance harness report hashes,
  - signed certification statement hash.
- Vendor-facing verification requirement:
  - published evidence must be independently verifiable using `docs/layer4-implementation/Release-Evidence-Assembler.md` and `docs/layer3-tests/Conformance-Harness-Guide.md`.

---
## 3) Initialization
1. Load driver metadata.
2. Verify signatures/hashes.
3. Build primitive coverage map.

---
## 4) Operator Manifest
- `UML_OS.Backend.ValidatePrimitiveCoverage_v1`
- `UML_OS.Backend.RunReproducibilitySuite_v1`
- `UML_OS.Backend.VerifyDriverHash_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

Template conformance note (III.A): each operator definition in this section is interpreted with the full EQC operator template fields. When a field is not repeated inline, the section-level defaults are: explicit typed signatures, deterministic ordering/tie handling, declared numerical policy inheritance, deterministic failure semantics (0.K), explicit dependencies, and VII.B test-vector coverage.

**Operator:** `UML_OS.Backend.ValidatePrimitiveCoverage_v1`  
**Category:** IO  
**Signature:** `(required_primitives, adapter_table -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** validates primitive coverage and signature compatibility.

**Operator:** `UML_OS.Backend.RunReproducibilitySuite_v1`  
**Category:** IO  
**Signature:** `(driver, test_manifest -> adapter_report)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic suite orchestration and deterministic report reduction order  
**Definition:** runs E0/E1 reproducibility checks vs reference backend and returns:
- `adapter_report.repro_report`
- `adapter_report.primitive_semantics_hash`
- `adapter_report.determinism_compliance_report_hash`.

**Operator:** `UML_OS.Backend.VerifyDriverHash_v1`  
**Category:** IO  
**Signature:** `(driver_binary, registry -> ok)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** verifies driver hash against trusted registry.

---
## 6) Procedure
```text
1. VerifyDriverHash_v1
2. ValidatePrimitiveCoverage_v1
3. adapter_report <- RunReproducibilitySuite_v1
4. Emit certification_status from deterministic policy reduction over adapter_report
5. return (adapter_report, certification_status)
```

---
## 7) Trace & Metrics
### Logging rule
Certification emits deterministic per-test records.
### Trace schema
- `run_header`: backend_binary_hash, driver_runtime_fingerprint_hash, adapter_version
- `iter`: test_id, result
- `run_end`: certification_status
### Metric schema
- `covered_primitives`, `e0_pass_rate`, `e1_pass_rate`
### Comparability guarantee
Comparable iff test manifests and reference backend version match.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
Ensures completeness, deterministic ordering, and declared failure semantics.
#### VII.B Operator test vectors (mandatory)
Coverage/mismatch and hash validation fixtures.
#### VII.C Golden traces (mandatory)
Golden certification reports for approved drivers.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for certification verdict and critical test outputs.
#### VIII.B Allowed refactor categories
- test harness optimization preserving verdicts.
#### VIII.C Equivalence test procedure (mandatory)
Exact certification report comparison.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- certification progress and per-test outputs.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- resumed certification yields identical final verdict.

FILE: layer4-implementation/Backend-Feature-Matrix.md
=====================================================
# UML_OS Backend Feature Matrix Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Backend.FeatureMatrix_v1`  
**Purpose (1 sentence):** Define deterministic capability matrix for backend adapters across primitives, determinism tiers, and operational limits.  
**Spec Version:** `UML_OS.Backend.FeatureMatrix_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Backend capability governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Backend.FeatureMatrix_v1`
- **Purpose (1 sentence):** Deterministic backend capability contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: prevent unsupported backend paths at runtime.
### 0.B Reproducibility Contract
- Replayable given `(backend_binary_hash, feature_matrix_hash, determinism_profile_hash)`.
### 0.C Numeric Policy
- Capability flags are exact boolean/enum fields.
### 0.D Ordering and Tie-Break Policy
- Matrix rows sorted by `(backend_id, feature_id)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Multi-backend verification merge is deterministic.
### 0.F Environment and Dependency Policy
- Matrix must align with `docs/layer4-implementation/Backend-Adapter-Guide.md` and operator registry.
### 0.G Operator Manifest
- `UML_OS.Backend.ValidateFeatureMatrix_v1`
- `UML_OS.Backend.ResolveCapability_v1`
- `UML_OS.Backend.EvaluateCompatibility_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `backend/features.cbor` canonical artifact.
### 0.I Outputs and Metric Schema
- Outputs: `(capability_report, compatibility_verdict)`
- Metrics: `features_supported`, `features_missing`
### 0.J Spec Lifecycle Governance
- Required feature semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- Missing required feature is deterministic failure.
### 0.L Input/Data Provenance
- Every feature record must bind adapter and profile hashes.

---
## 2) System Model
### I.A Persistent State
- Backend feature matrix registry.
### I.B Inputs and Hyperparameters
- Backend ids, feature records, workload requirements.
### I.C Constraints and Feasible Set
- Compatible iff all required workload features are supported.
### I.D Transient Variables
- feature diff diagnostics.
### I.E Invariants and Assertions
- No ambiguous feature states.

---
## 3) Initialization
1. Load feature matrix.
2. Validate schema and uniqueness.
3. Resolve workload required feature set.

---
## 4) Operator Manifest
- `UML_OS.Backend.ValidateFeatureMatrix_v1`
- `UML_OS.Backend.ResolveCapability_v1`
- `UML_OS.Backend.EvaluateCompatibility_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Backend.ValidateFeatureMatrix_v1`  
**Signature:** `(feature_matrix -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Backend.ResolveCapability_v1`  
**Signature:** `(backend_id, feature_id -> capability_state)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Backend.EvaluateCompatibility_v1`  
**Signature:** `(backend_id, workload_requirements -> compatibility_verdict)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. ValidateFeatureMatrix_v1
2. ResolveCapability_v1 for required features
3. EvaluateCompatibility_v1
4. Emit capability report
```

---
## 7) Trace & Metrics
### Logging rule
- Feature checks emit deterministic capability records.
### Trace schema
- `run_header`: backend_id, feature_matrix_hash
- `iter`: feature_id, status
- `run_end`: compatibility_verdict
### Metric schema
- `features_supported`, `features_missing`
### Comparability guarantee
- Comparable iff same matrix and backend identity.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Required features complete and non-ambiguous.
#### VII.B Operator test vectors (mandatory)
- Support/missing feature fixtures.
#### VII.C Golden traces (mandatory)
- Golden backend capability traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for compatibility verdict.
#### VIII.B Allowed refactor categories
- Storage/index optimizations preserving matrix semantics.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of compatibility outcomes.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Matrix hash and capability resolution cursor.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed capability checks must produce identical verdicts.

FILE: layer4-implementation/Benchmark-Evidence-Spec.md
======================================================
# UML_OS Benchmark Evidence Specification
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Perf.BenchmarkEvidenceSpec_v1`
**Purpose (1 sentence):** Define deterministic benchmark evidence artifacts and regression-verdict input identity.
**Spec Version:** `UML_OS.Perf.BenchmarkEvidenceSpec_v1` | 2026-02-21 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Perf.BenchmarkEvidenceSpec_v1`
- **Purpose (1 sentence):** Deterministic performance evidence contract.
- **Spec Version:** `UML_OS.Perf.BenchmarkEvidenceSpec_v1` | 2026-02-21 | Authors: Olejar Damir
- **Domain / Problem Class:** performance gate evidence standardization.
### 0.A Objective Semantics
- Make performance claims externally reproducible and profile-gate enforceable.
### 0.B Reproducibility Contract
- Replayable given `(workload_ids, env_manifest_hash, baseline_hash, threshold_hash, metric_snapshot_hash)`.
### 0.C Numeric Policy
- Quantiles and threshold checks inherit `docs/layer3-tests/Performance-Plan.md`.
### 0.D Ordering and Tie-Break Policy
- Workload IDs sorted ascending.
### 0.E Parallel, Concurrency, and Reduction Policy
- Sample collection may parallelize; snapshot assembly deterministic.
### 0.F Environment and Dependency Policy
- Environment lock (`env_manifest_hash`) mandatory.
### 0.G Operator Manifest
- `UML_OS.Perf.RunBenchmark_v1`
- `UML_OS.Perf.AggregateMetrics_v1`
- `UML_OS.Perf.EvaluateRegressionPolicy_v1`
### 0.H Namespacing and Packaging
- `perf/evidence/<tier>/<release_id>/`.
### 0.I Outputs and Metric Schema
- Outputs: `(benchmark_evidence_report, benchmark_evidence_hash, gate_verdict)`.
### 0.J Spec Lifecycle Governance
- Evidence schema is MAJOR-governed.
### 0.K Failure and Error Semantics
- Missing baseline or env binding is deterministic failure.
### 0.L Input/Data Provenance
- Inputs from `Performance-Plan` + release gates.

## 2) Required Evidence Fields (Normative)
- `platform_tier` (`cpu_tier|single_gpu_tier|multi_gpu_tier`)
- `env_manifest_hash`
- `workload_ids[]`
- `baseline_hash`
- `threshold_hash`
- `metric_snapshot_hash`
- `regression_verdict`

## 3) Evidence Identity (Normative)
- `benchmark_evidence_hash = SHA-256(CBOR_CANONICAL(["benchmark_evidence_v1", evidence_object]))`.

## 4) Cross-References
- `docs/layer3-tests/Performance-Plan.md`
- `docs/layer3-tests/Release-Gates.md`

## 6) Procedure
```text
1. Collect benchmark metrics and build metric snapshot.
2. Bind snapshot to workload IDs, baseline, thresholds, and env hash.
3. Evaluate deterministic regression verdict.
4. Emit benchmark_evidence_hash and report.
```

FILE: layer4-implementation/Brownfield-Deployment-Guide.md
==========================================================
# UML_OS Brownfield Deployment Guide
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.BrownfieldAdoption_v1`  
**Purpose (1 sentence):** Define deterministic patterns for incremental UML_OS adoption in existing ML infrastructures without big-bang rewrites.  
**Spec Version:** `UML_OS.Implementation.BrownfieldAdoption_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) Adoption Patterns
- Pattern A: wrap existing trainer with trace + certificate only.
- Pattern B: replace data path with NextBatch contract first.
- Pattern C: migrate operator-by-operator with registry certification.

## 2) Anti-Patterns
- introducing non-canonical serialization in adapter glue code.
- bypassing evidence assembly and manually stitching release artifacts.
- mixing unmanaged loops in sealed execution profile.

## 3) Incremental Milestones
- M1: deterministic manifest + environment lock.
- M2: trace sidecar + replay comparator.
- M3: checkpoint + WAL atomic commit.
- M4: certificate + release gate integration.

## 4) Exit Criteria
- migrated subsystem passes conformance profile requirements with zero required blockers.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Brownfield Deployment Guide" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Build-and-CI-Matrix.md
==================================================
# UML_OS Build and CI Matrix Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.BuildCIMatrix_v1`  
**Purpose (1 sentence):** Define deterministic build targets, CI gates, and matrix validation rules for UML_OS implementation.  
**Spec Version:** `UML_OS.Implementation.BuildCIMatrix_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Build orchestration and CI gate governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.BuildCIMatrix_v1`
- **Purpose (1 sentence):** Deterministic CI matrix contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: eliminate non-deterministic build/test outcomes.
### 0.B Reproducibility Contract
- Replayable given `(commit_hash, lockfile_hash, matrix_hash, env_manifest_hash)`.
### 0.C Numeric Policy
- Gate thresholds use binary64/integer deterministic comparisons.
### 0.D Ordering and Tie-Break Policy
- Matrix jobs ordered by `(profile, backend, mode)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Jobs run in parallel; gate verdict reduction order fixed.
### 0.F Environment and Dependency Policy
- CI workers must satisfy `docs/layer1-foundation/Environment-Manifest.md` and lock policy.
### 0.G Operator Manifest
- `UML_OS.CI.RunBuild_v1`
- `UML_OS.CI.RunTestSuite_v1`
- `UML_OS.CI.EvaluateGates_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.CI.*`
### 0.I Outputs and Metric Schema
- Outputs: `(ci_report, gate_verdict)`
- Metrics: `jobs_total`, `jobs_passed`, `jobs_failed`
### 0.J Spec Lifecycle Governance
- Gate changes are MAJOR.
### 0.K Failure and Error Semantics
- Any required gate failure is deterministic fail.
### 0.L Input/Data Provenance
- All job inputs must be content-addressed.

---
## 2) System Model
### I.A Persistent State
- CI matrix definition and historical gate snapshots.
### I.B Inputs and Hyperparameters
- commit, matrix definition, thresholds, test manifests.
### I.C Constraints and Feasible Set
- Valid iff all required jobs complete and required gates pass.
### I.D Transient Variables
- job outputs, logs, normalized verdicts.
### I.E Invariants and Assertions
- No skipped required jobs.

---
## 3) Initialization
1. Load matrix definition.
2. Validate worker environment.
3. Resolve required job graph.

---
## 4) Operator Manifest
- `UML_OS.CI.RunBuild_v1`
- `UML_OS.CI.RunTestSuite_v1`
- `UML_OS.CI.EvaluateGates_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.CI.RunBuild_v1`  
**Signature:** `(build_target, env -> build_result)`  
**Purity class:** IO  
**Determinism:** deterministic with pinned toolchain.

**Operator:** `UML_OS.CI.RunTestSuite_v1`  
**Signature:** `(suite_id, artifact -> test_result)`  
**Purity class:** IO  
**Determinism:** deterministic with fixed seeds and fixtures.

**Operator:** `UML_OS.CI.EvaluateGates_v1`  
**Signature:** `(job_results, gate_policy -> gate_verdict)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. RunBuild_v1 for required targets
2. RunTestSuite_v1 per matrix job
3. EvaluateGates_v1
4. Emit ci_report
```

---
## 7) Trace & Metrics
### Logging rule
- CI emits deterministic job and gate records.
### Trace schema
- `run_header`: matrix_hash, commit_hash
- `iter`: job_id, status, artifact_hash
- `run_end`: gate_verdict, report_hash
### Metric schema
- `jobs_total`, `jobs_passed`, `jobs_failed`
### Comparability guarantee
- Comparable iff matrix, policy, and inputs are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Required jobs declared and reachable.
#### VII.B Operator test vectors (mandatory)
- Matrix reduction and gate boundary tests.
#### VII.C Golden traces (mandatory)
- Golden CI matrix traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for gate verdict and report hash.
#### VIII.B Allowed refactor categories
- CI backend changes preserving normalized outputs.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of verdicts on frozen job outputs.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Job cursor and partial result map.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed CI run must produce same final verdict.

---
## 11) Related Contracts
- `docs/layer4-implementation/EQC-CI-Policy.md`
- `docs/layer4-implementation/Spec-Lint-Rules.md`

FILE: layer4-implementation/CLI-Command-Profiles.md
===================================================
# UML_OS CLI Command Profiles
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.CLICommandProfiles_v1`  
**Purpose (1 sentence):** Define deterministic CLI command profiles for local development, CI, replay, and release workflows.  
**Spec Version:** `UML_OS.Implementation.CLICommandProfiles_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Developer operations and automation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.CLICommandProfiles_v1`
- **Purpose (1 sentence):** Canonical command profiles for deterministic execution.
### 0.A Objective Semantics
- minimize command ambiguity and environment drift.
### 0.B Reproducibility Contract
- same profile + same inputs must produce same command plan.
### 0.C Numeric Policy
- N/A except deterministic metric reporting in binary64.
### 0.D Ordering and Tie-Break Policy
- command steps ordered by declared sequence id.
### 0.E Parallel, Concurrency, and Reduction Policy
- explicit profile flags for serial vs parallel execution.
### 0.F Environment and Dependency Policy
- command profiles require lockfile-verified environment.
### 0.G Operator Manifest
- `UML_OS.Implementation.ResolveCLIProfile_v1`
- `UML_OS.Implementation.ExecuteCLIProfile_v1`
- `UML_OS.Implementation.VerifyCLIOutcome_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- command profile operators under `UML_OS.Implementation.*`.
### 0.I Outputs and Metric Schema
- `(execution_plan, command_results, outcome_verdict)`.
### 0.J Spec Lifecycle Governance
- profile step changes are MINOR; gate semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- failing required command step aborts profile.
### 0.L Input/Data Provenance
- profile id and resolved command list hash logged.

---
## 2) System Model
### I.A Persistent State
- command profile catalog.
### I.B Inputs and Hyperparameters
- profile id (`dev`, `ci`, `replay`, `release`), workspace path.
### I.C Constraints and Feasible Set
- all required tools must be available.
### I.D Transient Variables
- per-step exit status and stdout/stderr hash.
### I.E Invariants and Assertions
- required steps cannot be skipped.

---
## 3) Initialization
1. Load profile catalog.
2. Resolve selected profile.
3. Initialize execution context.

---
## 4) Operator Manifest
- `UML_OS.Implementation.ResolveCLIProfile_v1`
- `UML_OS.Implementation.ExecuteCLIProfile_v1`
- `UML_OS.Implementation.VerifyCLIOutcome_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Implementation.ResolveCLIProfile_v1`  
**Signature:** `(profile_id, catalog -> plan)`  
**Purity class:** PURE  
**Definition:** Produces deterministic command plan.

**Operator:** `UML_OS.Implementation.ExecuteCLIProfile_v1`  
**Signature:** `(plan, env -> results)`  
**Purity class:** IO  
**Definition:** Executes command steps in declared order.

**Operator:** `UML_OS.Implementation.VerifyCLIOutcome_v1`
**Signature:** `(results, profile_policy -> outcome_verdict)`
**Purity class:** PURE
**Definition:** Applies deterministic required-step and exit-code policy to emit `PASS/FAIL`.

---
## 6) Procedure
```text
1. plan <- ResolveCLIProfile_v1(...)
2. results <- ExecuteCLIProfile_v1(plan)
3. verdict <- VerifyCLIOutcome_v1(results)
4. if verdict == FAIL: Error.Emit_v1(CONTRACT_VIOLATION)
5. return (execution_plan, command_results, outcome_verdict)
```

---
## 7) Trace & Metrics
- Metrics: `steps_total`, `steps_passed`, `steps_failed`, `runtime_seconds`.
- Trace includes profile id and plan hash.

---
## 8) Validation
- Golden profile plans for each profile id.
- deterministic stdout/stderr hashing checks.

---
## 9) Refactor & Equivalence
- E0 for plan hash and step order.
- E1 for runtime duration only.

---
## 10) Checkpoint/Restore
- execution checkpoint stores completed step index and result hashes.
- restore resumes at next step deterministically.

---
## 11) Deterministic Diagnostics Bundle (Normative)
- `quickstart` and `doctor` profile flows MUST support emitting a deterministic diagnostics bundle:
  - `env_manifest_hash`,
  - compatibility report hash,
  - key contract hashes (registry/config/trace profile),
  - first-failure digest when present.
- Bundle identity:
  - `diagnostics_bundle_hash = SHA-256(CBOR_CANONICAL(diagnostics_bundle))`.
- Output stability:
  - identical inputs produce byte-identical diagnostics bundle.
- Tooling suite reference:
  - `docs/layer4-implementation/Tooling-and-Automation-Suite.md`.

FILE: layer4-implementation/Canonical-Hashing-Reference.md
==========================================================
# UML_OS Canonical Hashing Reference
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Serialization.CanonicalHashingReference_v1`  
**Purpose (1 sentence):** Provide canonical implementation formulas and preimages for all contract-critical hashes.  
**Spec Version:** `UML_OS.Serialization.CanonicalHashingReference_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Deterministic commitment hashing.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Serialization.CanonicalHashingReference_v1`
- **Purpose (1 sentence):** Single reference for commitment hash formulas.
### 0.A Objective Semantics
- minimize hashing drift across implementations.
### 0.B Reproducibility Contract
- hashes reproducible from canonical preimages only.
### 0.C Numeric Policy
- fixed `bytes32` digest outputs.
### 0.D Ordering and Tie-Break Policy
- all map/list orderings explicit and deterministic.
### 0.E Parallel, Concurrency, and Reduction Policy
- hash computation can parallelize only when preimage order remains fixed.
### 0.F Environment and Dependency Policy
- SHA-256 over `CBOR_CANONICAL` only.
### 0.G Operator Manifest
- `UML_OS.Serialization.ComputeDigest_v1`
- `UML_OS.Serialization.ValidateDigestInputs_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Serialization.*` namespace.
### 0.I Outputs and Metric Schema
- outputs: `(digest_table, validation_report)`.
### 0.J Spec Lifecycle Governance
- preimage change is MAJOR.
### 0.K Failure and Error Semantics
- invalid preimage fields/types fail deterministically.
### 0.L Input/Data Provenance
- each digest tied to schema version and domain tag.

---
## 2) System Model
### I.A Persistent State
- formula registry keyed by digest id.
### I.B Inputs and Hyperparameters
- digest id and preimage fields.
### I.C Constraints and Feasible Set
- all required fields must be present and typed.
### I.D Transient Variables
- normalized preimage tuples.
### I.E Invariants and Assertions
- same preimage -> same bytes32 digest.

### II.F Domain Tag and Digest Table (Normative)
- `domain_tag` is a fixed UTF-8 string bound to `digest_id` in the formula registry.
- `ComputeDigest_v1` must prepend this exact `domain_tag` to the canonical preimage tuple.
- `digest_table` output is a canonical map: `map<digest_id:string, digest_bytes32>`, sorted lexicographically by `digest_id` before serialization.

---
## 3) Initialization
1. Load formula registry.
2. Validate digest id uniqueness.
3. Initialize computation context.

---
## 4) Operator Manifest
- `UML_OS.Serialization.ComputeDigest_v1`
- `UML_OS.Serialization.ValidateDigestInputs_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Serialization.ValidateDigestInputs_v1`
**Signature:** `(digest_id, preimage -> validation_report)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** Validates required fields/types/order for the given `digest_id` using the formula registry.

**Operator:** `UML_OS.Serialization.ComputeDigest_v1`  
**Signature:** `(digest_id, normalized_preimage -> digest_bytes32)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Computes `SHA-256(CBOR_CANONICAL([domain_tag, ...]))` where `domain_tag` is loaded from the formula registry for `digest_id`.

---
## 6) Procedure
```text
1. ValidateDigestInputs_v1
2. Normalize preimage deterministically
3. Compute digest
4. Emit digest table entry
```

---
## 7) Trace & Metrics
- Metrics: `digests_computed`, `invalid_preimages`.
- Trace includes `digest_id`, `domain_tag`, `digest_value`.

---
## 8) Validation
- vector tests for replay/checkpoint/trace/WAL/certificate digest ids.
- cross-impl byte-for-byte digest comparison vectors.

---
## 9) Refactor & Equivalence
- E0 for all digest outputs.

---
## 10) Checkpoint/Restore
- checkpoint stores formula-registry hash and last digest cursor.
- restore must produce identical digests.

FILE: layer4-implementation/Change-Control-Playbook.md
======================================================
# UML_OS Change Control Playbook
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ChangeControlPlaybook_v1`
**Purpose (1 sentence):** Define deterministic coding/document change workflow from proposal through merge and release evidence.
**Spec Version:** `UML_OS.Implementation.ChangeControlPlaybook_v1` | 2026-02-19 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Engineering change governance.

---
## 1) Scope
This playbook governs any code or specification change affecting documents, sidecars, schemas, traces, checkpoints, certificates, or operator contracts.

---
## 2) Deterministic Workflow (Normative)
1. Create branch and declare change scope (DocIDs and modules).
2. Apply edits in target docs/code.
3. Run impact analysis:
   - `eqc-es impact --change DOCID@vX.Y.Z`
4. Run lint and wiring verification:
   - `eqc-es validate`
   - `python3 tools/spec_lint.py` (or equivalent contract linter)
5. Update sidecars:
   - `eqc-es regenerate-sidecars`
6. Re-run deterministic hard pass checks.
7. Update `ecosystem-validation-log.md`.
8. Prepare release evidence bundle and merge atomically.

---
## 3) Mandatory Gate Checklist
- No broken markdown references.
- No missing graph edges for discovered references.
- No stale reference edges.
- Registry/graph/node/path parity is complete.
- No layer violations for `IMPORTS/EXTENDS`.
- No undeclared edge type usage.
- Reachability from `CORE-MASTER-001` passes.

---
## 4) Versioning + Migration Rules
- PATCH: wording/trace-neutral and non-breaking contract clarifications.
- MINOR: additive fields/rules with backward compatibility.
- MAJOR: breaking schema/rule/operator behavior changes.
- MAJOR changes require migration note and updated test vectors.

---
## 5) Evidence and Audit Artifacts
Required artifacts for merge:
- updated docs
- updated sidecars (`ecosystem-registry.yaml`, `ecosystem-graph.yaml`)
- validation log entry
- deterministic diff summary

---
## 6) Wiring References
- `ecosystem.md`
- `docs/layer4-implementation/Spec-Lint-Implementation.md`
- `docs/layer4-implementation/Spec-Lint-Rules.md`
- `docs/layer4-implementation/EQC-CI-Policy.md`
- `docs/layer4-implementation/Implementation-Roadmap.md`
- `docs/layer4-implementation/Repo-Layout-and-Interfaces.md`
- `docs/layer3-tests/Test-Plan.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Change Control Playbook" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Code-Generation-Mapping.md
======================================================
# UML_OS Code Generation Mapping
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.CodeGenerationMapping_v1`  
**Purpose (1 sentence):** Define deterministic mappings from EQC operators to concrete code modules, files, and generated stubs.  
**Spec Version:** `UML_OS.Implementation.CodeGenerationMapping_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Build-time operator-to-code realization.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.CodeGenerationMapping_v1`
- **Purpose (1 sentence):** Deterministic code generation mapping.
- **Spec Version:** `UML_OS.Implementation.CodeGenerationMapping_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Source layout and stub generation.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize unmapped operators and ambiguous ownership.
### 0.B Reproducibility Contract
- Replayable given `(mapping_version, operator_manifest_hash, template_hash)`.
### 0.C Numeric Policy
- N/A except deterministic indexing/counting of mappings.
### 0.D Ordering and Tie-Break Policy
- Mapping order by namespace then operator name then version.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel codegen allowed with deterministic output merge order.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for generated file set and stub signatures.
### 0.G Operator Manifest
- `UML_OS.Implementation.ResolveOperatorTargets_v1`
- `UML_OS.Implementation.GenerateStub_v1`
- `UML_OS.Implementation.ValidateGeneratedLayout_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Generated modules preserve EQC namespace segments.
### 0.I Outputs and Metric Schema
- Outputs: `(mapping_table, generated_artifacts)`.
- Metrics: `operators_mapped`, `stubs_generated`, `conflicts`.
- Completion status: `success | failed`.
### 0.J Spec Lifecycle Governance
- Breaking folder/module layout change requires MAJOR bump.
### 0.K Failure and Error Semantics
- Abort on unresolved operator mapping or path conflict.
### 0.L Input/Data Provenance
- Source manifests/templates are hash-addressed.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.


## 2) System Model
### I.A Persistent State
- mapping registry (`operator -> file/module/symbol`).
### I.B Inputs and Hyperparameters
- operator manifests, language target, template set.
### I.C Constraints and Feasible Set
- Valid if every operator resolves to exactly one concrete target.
### I.D Transient Variables
- pending stub list and conflict diagnostics.
### I.E Invariants and Assertions
- unique symbol per mapped operator.

### II.F Mapping Table (Concrete)
| operator | module_path | symbol_name | stub_template | ownership | side_effects | signature_digest |
|---|---|---|---|---|---|---|
| `UML_OS.Data.NextBatch_v2` | `src/data/next_batch.py` | `next_batch_v2` | `py_operator_stub_v1` | data team | `["NONE"]` | `sha256:67069ace699a580ed23a01168b46d0242002d82f8d429266b195d3a459eb972f` |
| `UML_OS.Model.ModelIR_Executor_v1` | `src/model/modelir_executor.py` | `modelir_executor_v1` | `py_operator_stub_v1` | model team | `["ALLOCATES_MEMORY"]` | `sha256:ce1ec3e5cead31a92f46e79847332d3db0fdd824f2f3b6608987c77450a6de70` |
| `UML_OS.DifferentialPrivacy.Apply_v3` | `src/dp/apply.py` | `dp_apply_v3` | `py_operator_stub_v1` | privacy team | `["ADVANCES_RNG","MUTATES_ACCOUNTANT"]` | `sha256:df574eb8b39a83a8107bce17dbcddbd3c1751aa51ccd6f9dcdd0e95ddab6b52f` |
| `UML_OS.TMMU.PrepareMemory_v2` | `src/tmmu/prepare_memory.py` | `prepare_memory_v2` | `py_operator_stub_v1` | runtime team | `["ALLOCATES_MEMORY"]` | `sha256:87ad2acf49cc0081824d67a2b0838d03d3bd2f3f2d3ae19a9b07af50bc264b09` |
| `UML_OS.Trace.ComputeTraceHash_v1` | `src/trace/compute_trace_hash.py` | `compute_trace_hash_v1` | `py_operator_stub_v1` | trace team | `["NONE"]` | `sha256:688952452590da608369e8ce224f014a053ccf9ec0b0f1d58766a6433d62c6bb` |
| `UML_OS.IO.SaveCheckpoint_v1` | `src/io/save_checkpoint.py` | `save_checkpoint_v1` | `py_operator_stub_v1` | runtime team | `["PERFORMS_IO"]` | `sha256:7500cd45013f340439c196a8119f1da650f325f9b9fb22567574df80a78c5d77` |
| `UML_OS.Certificate.EvidenceValidate_v1` | `src/cert/evidence_validate.py` | `evidence_validate_v1` | `py_operator_stub_v1` | security team | `["NONE"]` | `sha256:9d55661802f55dacd9695031acfeed3745f9a501b7db5606b814ad546116d5b1` |
| `UML_OS.Tracking.MetricLog_v1` | `src/tracking/metric_log.py` | `metric_log_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:2bfc26d97f932a7f4dc99529872f54dcee07c1f37fa160dc1f09d4bbc0052553` |
| `UML_OS.Backend.LoadDriver_v1` | `src/backend/load_driver.py` | `load_driver_v1` | `py_operator_stub_v1` | backend team | `["PERFORMS_IO","NETWORK_COMM"]` | `sha256:708fd111f6fc0a8f85853a4218ff9eba82ffc3da285266b15f6714a450728056` |
| `UML_OS.Checkpoint.CheckpointMigrate_v1` | `src/checkpoint/migrate_checkpoint.py` | `checkpoint_migrate_v1` | `py_operator_stub_v1` | runtime team | `["PERFORMS_IO"]` | `sha256:ea0f1f735948058cd9893fe6f9c661ca578097c83c93780c624c4245dc576c59` |
| `UML_OS.Checkpoint.Restore_v1` | `src/checkpoint/restore.py` | `checkpoint_restore_v1` | `py_operator_stub_v1` | runtime team | `["PERFORMS_IO","MUTATES_MODEL_STATE"]` | `sha256:2ad8fce88d166dfbfd042dfd9e91e1e282e4f549cea088b141872d53a863ef89` |
| `UML_OS.Config.ManifestMigrate_v1` | `src/config/migrate_manifest.py` | `manifest_migrate_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:29695a8e891b995033fc2508204991bb8cb28067965ebac7bfbe26478b40cc89` |
| `UML_OS.Model.Forward_v2` | `src/model/forward.py` | `forward_v2` | `py_operator_stub_v1` | model team | `["ADVANCES_RNG"]` | `sha256:17d85435fe2e601fe522b614938ea7853b9c36be14c8feb84f4e70e1e253bc74` |
| `UML_OS.Monitor.DriftCompute_v1` | `src/monitor/drift_compute.py` | `drift_compute_v1` | `py_operator_stub_v1` | platform team | `["NONE"]` | `sha256:901881d54845698125611c9d87d11e7fa5419248a4caf8dbb839465dccfe25fb` |
| `UML_OS.Monitor.Emit_v1` | `src/monitor/emit.py` | `monitor_emit_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:eb4d0698028761a1d5f75b66d7a67a758045aa33846d50296990722b30156550` |
| `UML_OS.Monitor.Register_v1` | `src/monitor/register.py` | `monitor_register_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:0a5e9373bfba01ba4bbeddba689074a704d538e7ebe4e072a139cef99bbd4440` |
| `UML_OS.Registry.StageTransition_v1` | `src/registry/stage_transition.py` | `registry_stage_transition_v1` | `py_operator_stub_v1` | governance team | `["PERFORMS_IO"]` | `sha256:df171fad79b74e99a5cf98c98c0dd0d99891c6e28d2b21de21de12e797db46af` |
| `UML_OS.Registry.VersionCreate_v1` | `src/registry/version_create.py` | `registry_version_create_v1` | `py_operator_stub_v1` | governance team | `["PERFORMS_IO"]` | `sha256:5690d2ee8d34c3407e33f14f25198d35af170150c663b5290f9f6460003a8f0e` |
| `UML_OS.Trace.TraceMigrate_v1` | `src/trace/migrate_trace.py` | `trace_migrate_v1` | `py_operator_stub_v1` | trace team | `["PERFORMS_IO"]` | `sha256:fe3709bad090dcd8f5f190649a7694bd26ca059e9a47b3eaf784d0268bf442ee` |
| `UML_OS.Import.LegacyFramework_v1` | `src/import/legacy_framework.py` | `legacy_framework_import_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:20c8da5d2c5565476edc1c59ba209b14f19e0f4f3e71be86f4854f28abea0839` |
| `UML_OS.Tracking.ArtifactTombstone_v1` | `src/tracking/artifact_tombstone.py` | `artifact_tombstone_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:668e41817d89f2aeb2af4e9394302cb935425450e4595c5db1965ed5d3f9ea22` |
| `UML_OS.Tracking.ArtifactGet_v1` | `src/tracking/artifact_get.py` | `artifact_get_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:89c470402948fd7717c7a89074e466ccaa731270b28bd798c8ef4b3905521d83` |
| `UML_OS.Tracking.ArtifactList_v1` | `src/tracking/artifact_list.py` | `artifact_list_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:a02167e5e2a3f785190069b65127032dd2841544af82da03dd1d237fbdc38f40` |
| `UML_OS.Tracking.ArtifactPut_v1` | `src/tracking/artifact_put.py` | `artifact_put_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:4c83219b6825bbbb8b64254328e6fa7d64e4eb04065f32e214ba7576fe0c3621` |
| `UML_OS.Tracking.RunCreate_v1` | `src/tracking/run_create.py` | `run_create_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:f9912032a083a24960b3fce71bef84b6b6669bd4f1455143b793abd46c61d979` |
| `UML_OS.Tracking.RunEnd_v1` | `src/tracking/run_end.py` | `run_end_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:61cffc6435589391694727d1950e9b897ecb4a9a1678ad318b7cb4863762bd8a` |
| `UML_OS.Tracking.RunStart_v1` | `src/tracking/run_start.py` | `run_start_v1` | `py_operator_stub_v1` | platform team | `["PERFORMS_IO"]` | `sha256:3bbc23354e81d350087a3eb11f45db4202d35b2c3a0d789917ce250c67d604ad` |

Signature lock invariant:
- For each operator `op`, `signature_digest` must match `docs/layer1-foundation/API-Interfaces.md` and (for backend-exposed ops/primitives) `docs/layer4-implementation/Backend-Adapter-Guide.md`.
- Client surface split (normative):
  - `syscalls/*` generated for `surface=SYSCALL` interfaces (no network transport).
  - `services/*` generated for `surface=SERVICE` interfaces (network/auth/retry/idempotency policy applied).
- Digest generation invariant:
  - request/response schema digests and signature digests are derived from canonical schema AST files (`schemas/*`) using `SchemaDigest_v1` and `SignatureDigest_v1` from `docs/layer1-foundation/API-Interfaces.md`; placeholders are forbidden in generated artifacts.

Canonical registry consumption invariant:
- `contracts/operator_registry.cbor` is the authoritative input for mapping resolution and stub generation.
- Codegen must hard-fail if any operator record lacks `surface`, schema digests, signature digest, side effects, allowed error codes, purity class, or required capabilities.
- Generated enforcement wrappers must include capability checks for `required_capabilities` and emit deterministic authorization diagnostics.

Deterministic mapping commitments (normative):
- `template_hash = SHA-256(template_bytes)` (or canonical template bundle bytes).
- `operator_manifest_hash = SHA-256(CBOR_CANONICAL(["operator_manifest_v1", operators_sorted]))`.
- `mapping_hash = SHA-256(CBOR_CANONICAL(["codegen_mapping_v1", mapping_version, operator_manifest_hash, template_hash, rules_sorted]))`.
- If generated code participates in release commitments, include `codegen_output_hash = SHA-256(CBOR_CANONICAL(generated_file_hashes_sorted))` in evidence binding.

---
## 3) Initialization
1. Load operator manifests.
2. Load template library.
3. Initialize deterministic target registry.

---
## 4) Operator Manifest
- `UML_OS.Implementation.ResolveOperatorTargets_v1`
- `UML_OS.Implementation.GenerateStub_v1`
- `UML_OS.Implementation.ValidateGeneratedLayout_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

Template conformance note (III.A): each operator definition in this section is interpreted with the full EQC operator template fields. When a field is not repeated inline, the section-level defaults are: explicit typed signatures, deterministic ordering/tie handling, declared numerical policy inheritance, deterministic failure semantics (0.K), explicit dependencies, and VII.B test-vector coverage.

**Operator:** `UML_OS.Implementation.ResolveOperatorTargets_v1`  
**Category:** IO  
**Signature:** `(operator_manifest, conventions -> mapping_table)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** resolves canonical code targets for each operator.

**Operator:** `UML_OS.Implementation.GenerateStub_v1`  
**Category:** IO  
**Signature:** `(mapping_entry, template -> source_file)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** generates typed stub with signature and deterministic default behavior.
Default unimplemented-stub behavior (normative):
- validate input schema deterministically,
- then emit deterministic `PRIMITIVE_UNSUPPORTED` error payload,
- no placeholder TODO behavior is allowed in generated contract stubs.

**Operator:** `UML_OS.Implementation.ValidateGeneratedLayout_v1`  
**Category:** IO  
**Signature:** `(generated_artifacts, mapping_table -> report)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** validates that all required files/symbols exist and match signatures.

---
## 6) Procedure
```text
1. ResolveOperatorTargets_v1
2. GenerateStub_v1 for each mapping entry
3. ValidateGeneratedLayout_v1
4. Emit mapping table + generation report
```

---
## 7) Trace & Metrics
### Logging rule
Each generated artifact emits deterministic mapping and validation records.
### Trace schema
- `run_header`: mapping_version, template_hash
- `iter`: operator, target_path, status
- `run_end`: generated_count, conflict_count
### Metric schema
- `operators_mapped`, `stubs_generated`, `conflicts`
### Comparability guarantee
Comparable iff manifest, templates, and mapping conventions are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
Passes symbol completeness, deterministic ordering, manifest completeness.
#### VII.B Operator test vectors (mandatory)
Includes manifest->mapping and mapping->stub vectors.
#### VII.C Golden traces (mandatory)
Golden generated-file inventories and signatures.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for mapping table and generated signatures.
#### VIII.B Allowed refactor categories
- template engine implementation changes preserving generated outputs.
#### VIII.C Equivalence test procedure (mandatory)
Exact compare of mapping and generated signatures.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- mapping registry and generation cursor.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- resumed generation yields identical artifact set.

FILE: layer4-implementation/Coding-Standards.md
===============================================
# UML_OS Coding Standards Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.CodingStandards_v1`  
**Purpose (1 sentence):** Define deterministic coding standards for implementation quality, consistency, and contract-safe behavior.  
**Spec Version:** `UML_OS.Implementation.CodingStandards_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Engineering style and quality governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.CodingStandards_v1`
- **Purpose (1 sentence):** Deterministic coding standards contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: reduce implementation ambiguity and runtime drift.
### 0.B Reproducibility Contract
- Replayable given `(code_commit_hash, lockfile_hash, standards_version)`.
### 0.C Numeric Policy
- Numeric comparisons in contract paths must use declared tolerances only.
### 0.D Ordering and Tie-Break Policy
- Deterministic iteration and reduction ordering required in contract-critical code.
### 0.E Parallel, Concurrency, and Reduction Policy
- Concurrency patterns must preserve deterministic visible outputs.
### 0.F Environment and Dependency Policy
- Must align with `docs/layer1-foundation/Dependency-Lock-Policy.md` and `docs/layer1-foundation/Determinism-Profiles.md`.
### 0.G Operator Manifest
- `UML_OS.Code.ValidateStyle_v1`
- `UML_OS.Code.ValidateDeterminismPatterns_v1`
- `UML_OS.Code.ValidateErrorMapping_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Fully-qualified operator naming rules apply.
### 0.I Outputs and Metric Schema
- Outputs: `(style_report, determinism_report)`
- Metrics: `violations_total`, `critical_violations`
### 0.J Spec Lifecycle Governance
- Rule changes are MAJOR for required checks.
### 0.K Failure and Error Semantics
- Contract-critical violations block merge.
### 0.L Input/Data Provenance
- Reports must cite file path and rule IDs.

---
## 2) System Model
### I.A Persistent State
- Coding rule registry and severity map.
### I.B Inputs and Hyperparameters
- Source files, rule profiles, operator metadata.
### I.C Constraints and Feasible Set
- Valid iff required rule set passes.
### I.D Transient Variables
- Lint findings and normalized diagnostics.
### I.E Invariants and Assertions
- No hidden globals in contract-critical paths.

---
## 3) Initialization
1. Load coding rule set.
2. Resolve contract-critical file scope.
3. Prepare deterministic lint order.

---
## 4) Operator Manifest
- `UML_OS.Code.ValidateStyle_v1`
- `UML_OS.Code.ValidateDeterminismPatterns_v1`
- `UML_OS.Code.ValidateErrorMapping_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Code.ValidateStyle_v1`  
**Signature:** `(source_tree, rule_set -> style_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Code.ValidateDeterminismPatterns_v1`  
**Signature:** `(source_tree, determinism_profile -> determinism_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Code.ValidateErrorMapping_v1`  
**Signature:** `(source_tree, error_registry -> error_mapping_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. ValidateStyle_v1
2. ValidateDeterminismPatterns_v1
3. ValidateErrorMapping_v1
4. Build merged standards report for diagnostics only
5. return (style_report, determinism_report)
```

---
## 7) Trace & Metrics
### Logging rule
- Standards checks emit deterministic findings.
### Trace schema
- `run_header`: standards_version, source_hash
- `iter`: rule_id, file_path, status
- `run_end`: verdict
### Metric schema
- `violations_total`, `critical_violations`
### Comparability guarantee
- Comparable iff same rules and source hash.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Enforce deterministic ordering and explicit error mappings.
#### VII.B Operator test vectors (mandatory)
- Style and determinism anti-pattern fixtures.
#### VII.C Golden traces (mandatory)
- Golden standards-check traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for violation set and verdict.
#### VIII.B Allowed refactor categories
- Lint engine internals preserving findings.
#### VIII.C Equivalence test procedure (mandatory)
- Exact finding set compare.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Rule cursor and partial finding set.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed checks must produce identical final findings.

FILE: layer4-implementation/Command-Reference.md
================================================
# UML_OS Command Reference Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.CommandReference_v1`  
**Purpose (1 sentence):** Define canonical command entrypoints and deterministic invocation patterns for development, testing, replay, and release workflows.  
**Spec Version:** `UML_OS.Implementation.CommandReference_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Operational command governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.CommandReference_v1`
- **Purpose (1 sentence):** Canonical command contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: eliminate command ambiguity across environments.
### 0.B Reproducibility Contract
- Replayable given `(command_id, args_hash, env_manifest_hash, toolchain_hash)`.
### 0.C Numeric Policy
- Exit codes and counters are exact integers.
### 0.D Ordering and Tie-Break Policy
- Multi-step command workflows execute in fixed sequence.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel command groups must define deterministic result merge.
### 0.F Environment and Dependency Policy
- Commands must run under validated setup.
### 0.G Operator Manifest
- `UML_OS.CLI.ValidateCommand_v1`
- `UML_OS.CLI.ExecuteCommand_v1`
- `UML_OS.CLI.ReportCommandResult_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `umlos <subcommand>` canonical form.
### 0.I Outputs and Metric Schema
- Outputs: `(command_report, exit_code)`
- Metrics: `commands_run`, `commands_failed`
### 0.J Spec Lifecycle Governance
- Required command signature changes are MAJOR.
### 0.K Failure and Error Semantics
- Invalid command forms fail deterministically.
### 0.L Input/Data Provenance
- Command inputs and outputs must be traceable by hashes.

---
## 2) System Model
### I.A Persistent State
- Command registry and help schema.
### I.B Inputs and Hyperparameters
- command id, args, env, profile.
### I.C Constraints and Feasible Set
- Valid iff command matches registered signature.
### I.D Transient Variables
- execution diagnostics.
### I.E Invariants and Assertions
- Command docs and actual signatures must match.

---
## 3) Initialization
1. Load command registry.
2. Parse invocation.
3. Validate against command schema.

---
## 4) Operator Manifest
- `UML_OS.CLI.ValidateCommand_v1`
- `UML_OS.CLI.ExecuteCommand_v1`
- `UML_OS.CLI.ReportCommandResult_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.CLI.ValidateCommand_v1`  
**Signature:** `(argv, command_registry -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.CLI.ExecuteCommand_v1`  
**Signature:** `(validated_command -> command_result)`  
**Purity class:** IO  
**Determinism:** deterministic under fixed inputs.

**Operator:** `UML_OS.CLI.ReportCommandResult_v1`  
**Signature:** `(command_result -> command_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. ValidateCommand_v1
2. ExecuteCommand_v1
3. ReportCommandResult_v1
4. Return (command_report, exit_code)
```

---
## 7) Trace & Metrics
### Logging rule
- Commands emit deterministic invocation/result records.
### Trace schema
- `run_header`: command_id, args_hash
- `iter`: step_id, status
- `run_end`: exit_code, result_hash
### Metric schema
- `commands_run`, `commands_failed`
### Comparability guarantee
- Comparable iff same command id, args, and env hash.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Every documented command has a valid schema.
#### VII.B Operator test vectors (mandatory)
- Valid/invalid invocation vectors.
#### VII.C Golden traces (mandatory)
- Golden command execution traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for exit code and report hash.
#### VIII.B Allowed refactor categories
- CLI parser/runtime refactors preserving command semantics.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare for frozen command fixtures.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Command workflow cursor and partial outputs.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed command workflow yields same final exit and report.

FILE: layer4-implementation/Common-Pitfalls-Guide.md
====================================================
# UML_OS Common Pitfalls and How to Avoid Them
**Spec Version:** v1.0.0 | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**EQC Compliance:** Informational companion; normative behavior remains in contract docs.

## 1) Pitfall: Mixing Non-Canonical Serialization
- Symptom: hash mismatches for apparently identical objects.
- Why it happens: non-canonical map ordering or string encoding drift.
- Avoidance: always use canonical CBOR paths defined in layer1/layer2 contracts.

## 2) Pitfall: Reusing Tensor State Outside TMMU Rules
- Symptom: replay divergence in backward/optimizer paths.
- Why it happens: hidden aliasing and non-declared memory lifecycle.
- Avoidance: obey TMMU allocation/liveness contracts and explicit ownership rules.

## 3) Pitfall: Treating Timing as Deterministic Verdict Input
- Symptom: flaky gate outcomes near thresholds.
- Why it happens: wall-clock metrics vary naturally.
- Avoidance: keep timing informational unless contractually thresholded with explicit tolerance policy.

## 4) Pitfall: Incomplete Evidence Linkage
- Symptom: certificate validation failure despite successful run.
- Why it happens: missing hash-link fields in evidence bundle.
- Avoidance: assemble evidence only through release evidence assembler contract.

## 5) Pitfall: Skipping Replay Before Promotion
- Symptom: production-only nondeterminism discovered late.
- Why it happens: missing deterministic replay check in release workflow.
- Avoidance: make replay conformance mandatory before release gate evaluation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Common Pitfalls and How to Avoid Them" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Community-Governance-Model.md
=========================================================
# UML_OS Community Governance Model
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Governance.CommunityModel_v1`  
**Purpose (1 sentence):** Define open governance and contribution processes for deterministic evolution of UML_OS specifications and tooling.  
**Spec Version:** `UML_OS.Governance.CommunityModel_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) RFC Process
- Stages:
  - draft,
  - review,
  - final comment period,
  - acceptance/rejection.
- Mandatory RFC evidence:
  - migration impact,
  - compatibility impact,
  - test vectors,
  - release-gate implications.

## 2) Technical Steering Committee Charter
- Rotating representatives from major contributor organizations.
- Responsibilities:
  - resolve disputes,
  - approve MAJOR releases,
  - arbitrate compatibility policy conflicts.

## 3) Versioning and Backport Policy
- Major versions supported for 2 years.
- Critical security fixes backported to last 2 major lines.
- Minor lines receive bugfixes until superseded by 2 newer minors.

## 4) Contribution Ladder
- issue reporter -> doc contributor -> contract maintainer -> reviewer -> steward.
- Promotion criteria are deterministic and evidence-based.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Community Governance Model" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Contracts-Artifact-Lifecycle.md
===========================================================
# UML_OS Contracts Artifact Lifecycle
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ContractsArtifactLifecycle_v1`
**Purpose (1 sentence):** Define deterministic build, sign, publish, verify, deprecate, and retire lifecycle rules for machine-readable contract artifacts.
**Spec Version:** `UML_OS.Implementation.ContractsArtifactLifecycle_v1` | 2026-02-19 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Artifact governance for contract integrity.

---
## 1) Scope
Applies to contract artifacts including:
- `contracts/operator_registry.cbor`
- `contracts/digest_catalog.cbor`
- `contracts/determinism_profiles.cbor`
- versioned migration and compatibility sidecar artifacts.

---
## 2) Lifecycle States (Normative)
- `DRAFT`
- `VALIDATED`
- `SIGNED`
- `PUBLISHED`
- `DEPRECATED`
- `RETIRED`

Transitions are deterministic and append-only in audit logs.

---
## 3) Deterministic Lifecycle Procedure
1. Build artifact from authoritative specs.
2. Canonicalize (CBOR canonical profile).
3. Compute root hash and schema hash.
4. Validate against lint + conformance rules.
5. Sign artifact manifest.
6. Publish immutable artifact by content hash.
7. Record publication event in trace/audit log.
8. Deprecate/retire only through explicit policy transition.

---
## 4) Required Metadata
Every artifact manifest entry must include:
- `artifact_id`
- `artifact_type`
- `artifact_version`
- `artifact_hash` (bytes32)
- `schema_hash` (bytes32)
- `signature_key_id`
- `signature_hash`
- `published_at_utc`
- `status`

---
## 5) Integrity and Retention Rules
- Artifacts are immutable once `PUBLISHED`.
- Hash mismatch is a deterministic `CONTRACT_VIOLATION`.
- `RETIRED` artifacts remain verifiable via retained manifest and signature chain.

---
## 6) Wiring References
- `docs/layer4-implementation/Operator-Registry-CBOR-Contract.md`
- `docs/layer4-implementation/Release-Evidence-Assembler.md`
- `docs/layer2-specs/Execution-Certificate.md`
- `docs/layer2-specs/Run-Commit-WAL.md`
- `docs/layer1-foundation/Digest-Catalog.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Contracts Artifact Lifecycle" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Contributing-Workflow.md
====================================================
# UML_OS Contributing Workflow Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ContributingWorkflow_v1`  
**Purpose (1 sentence):** Define deterministic contribution lifecycle from branch creation to merge with mandatory evidence gates.  
**Spec Version:** `UML_OS.Implementation.ContributingWorkflow_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Engineering collaboration and merge governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ContributingWorkflow_v1`
- **Purpose (1 sentence):** Deterministic contribution workflow contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: prevent unverified changes from entering mainline.
### 0.B Reproducibility Contract
- Replayable given `(pr_id, commit_set_hash, ci_report_hash, review_decision_hash)`.
### 0.C Numeric Policy
- Gate thresholds and counts use exact deterministic comparisons.
### 0.D Ordering and Tie-Break Policy
- Workflow transitions are strictly ordered and append-only.
### 0.E Parallel, Concurrency, and Reduction Policy
- Multiple reviewers allowed; merge verdict uses deterministic reduction policy.
### 0.F Environment and Dependency Policy
- Contributor environments must pass `Developer-Setup.md` checks.
### 0.G Operator Manifest
- `UML_OS.Contrib.OpenPR_v1`
- `UML_OS.Contrib.RunRequiredChecks_v1`
- `UML_OS.Contrib.RecordReview_v1`
- `UML_OS.Contrib.MergePR_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Contrib.*`
### 0.I Outputs and Metric Schema
- Outputs: `(workflow_report, merge_verdict)`
- Metrics: `checks_passed`, `reviews_approved`
### 0.J Spec Lifecycle Governance
- Required check/review policy changes are MAJOR.
### 0.K Failure and Error Semantics
- Missing required checks or approvals blocks merge.
### 0.L Input/Data Provenance
- Decisions must reference immutable check/review artifacts.

---
## 2) System Model
### I.A Persistent State
- PR state machine and review ledger.
### I.B Inputs and Hyperparameters
- PR metadata, required checks, review policy.
### I.C Constraints and Feasible Set
- Merge valid iff all required conditions are met.
### I.D Transient Variables
- Check outputs and review diagnostics.
### I.E Invariants and Assertions
- No direct merge bypass for protected branches.

---
## 3) Initialization
1. Validate PR metadata.
2. Resolve required checks/reviews.
3. Initialize transition ledger.

---
## 4) Operator Manifest
- `UML_OS.Contrib.OpenPR_v1`
- `UML_OS.Contrib.RunRequiredChecks_v1`
- `UML_OS.Contrib.RecordReview_v1`
- `UML_OS.Contrib.MergePR_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Contrib.OpenPR_v1`
**Signature:** `(pr_metadata -> pr_id)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** Creates canonical PR record and returns immutable `pr_id`.

**Operator:** `UML_OS.Contrib.RunRequiredChecks_v1`  
**Signature:** `(pr_id, check_policy -> check_report)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.Contrib.RecordReview_v1`  
**Signature:** `(pr_id, reviewer_id, verdict, notes_hash -> review_record)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.Contrib.MergePR_v1`  
**Signature:** `(pr_id, check_report, review_records -> merge_verdict)`  
**Purity class:** IO  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. OpenPR_v1
2. RunRequiredChecks_v1
3. RecordReview_v1 (one or more)
4. MergePR_v1
5. return (workflow_report, merge_verdict)
```

---
## 7) Trace & Metrics
### Logging rule
- Workflow steps emit deterministic PR transition events.
### Trace schema
- `run_header`: pr_id, base_branch
- `iter`: transition_id, status
- `run_end`: merge_verdict
### Metric schema
- `checks_passed`, `reviews_approved`
### Comparability guarantee
- Comparable iff same PR commit set and policy.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Required transitions/checks/reviews enforced.
#### VII.B Operator test vectors (mandatory)
- Pass/fail workflow scenarios.
#### VII.C Golden traces (mandatory)
- Golden PR lifecycle traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for merge verdict and transition log.
#### VIII.B Allowed refactor categories
- Tooling integration changes preserving decisions.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of workflow outcomes.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- PR workflow cursor and pending actions.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed workflow must preserve final merge verdict.

FILE: layer4-implementation/Debugging-Playbook.md
=================================================
# UML_OS Debugging Playbook Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.DebuggingPlaybook_v1`  
**Purpose (1 sentence):** Define deterministic debugging workflows for replay divergences, hash mismatches, and contract failures.  
**Spec Version:** `UML_OS.Implementation.DebuggingPlaybook_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Incident triage and deterministic diagnostics.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.DebuggingPlaybook_v1`
- **Purpose (1 sentence):** Deterministic debugging/triage contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: minimize time-to-root-cause with reproducible diagnostics.
### 0.B Reproducibility Contract
- Replayable given `(replay_token, trace_final_hash, checkpoint_hash, env_manifest_hash)`.
### 0.C Numeric Policy
- Diff comparisons use declared E0/E1 profile only.
### 0.D Ordering and Tie-Break Policy
- Triage steps follow fixed deterministic order.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel probes allowed; final diagnosis path deterministic.
### 0.F Environment and Dependency Policy
- Debugging must preserve original artifact identities.
### 0.G Operator Manifest
- `UML_OS.Debug.LoadEvidence_v1`
- `UML_OS.Debug.FindFirstDivergence_v1`
- `UML_OS.Debug.ClassifyRootCause_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Debug.*`
### 0.I Outputs and Metric Schema
- Outputs: `(debug_report, root_cause_class)`
- Metrics: `divergence_step`, `signals_collected`
### 0.J Spec Lifecycle Governance
- Root-cause class taxonomy changes are MAJOR.
### 0.K Failure and Error Semantics
- Missing evidence yields deterministic diagnostic failure.
### 0.L Input/Data Provenance
- All debug conclusions must cite evidence hashes.

---
## 2) System Model
### I.A Persistent State
- Debug taxonomy and known failure signatures.
### I.B Inputs and Hyperparameters
- Trace/checkpoint/certificate/WAL evidence, replay mode.
### I.C Constraints and Feasible Set
- Valid iff evidence tuple is complete and hash-consistent.
### I.D Transient Variables
- divergence diff maps and ranked suspects.
### I.E Invariants and Assertions
- First divergence location must be deterministic.

---
## 3) Initialization
1. Load evidence tuple.
2. Validate hash/cert coherence.
3. Select replay comparator profile.

---
## 4) Operator Manifest
- `UML_OS.Debug.LoadEvidence_v1`
- `UML_OS.Debug.FindFirstDivergence_v1`
- `UML_OS.Debug.ClassifyRootCause_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Debug.LoadEvidence_v1`  
**Signature:** `(run_id -> evidence_bundle)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.Debug.FindFirstDivergence_v1`  
**Signature:** `(trace_a, trace_b, compare_profile -> divergence_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Debug.ClassifyRootCause_v1`  
**Signature:** `(divergence_report, evidence_bundle -> root_cause_class, debug_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. LoadEvidence_v1
2. FindFirstDivergence_v1
3. ClassifyRootCause_v1
4. Emit debug_report
```

---
## 7) Trace & Metrics
### Logging rule
- Debug runs emit deterministic triage events.
### Trace schema
- `run_header`: debug_profile, source_run_id
- `iter`: step_id, check_id, status
- `run_end`: root_cause_class, debug_report_hash
### Metric schema
- `divergence_step`, `signals_collected`
### Comparability guarantee
- Comparable iff same evidence and profile.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Every conclusion references committed evidence hashes.
#### VII.B Operator test vectors (mandatory)
- Divergence and root-cause classification fixtures.
#### VII.C Golden traces (mandatory)
- Golden debug triage traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for divergence location and root cause class.
#### VIII.B Allowed refactor categories
- Tooling implementation changes preserving verdicts.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of debug reports on fixed evidence.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Triage cursor and intermediate diagnosis state.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed debug session must preserve final diagnosis.

FILE: layer4-implementation/Determinism-Audit-Playbook.md
=========================================================
# UML_OS Determinism Audit Playbook
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Replay.DeterminismAuditPlaybook_v1`
**Purpose (1 sentence):** Consolidate determinism verification rules, evidence bindings, and failure taxonomy for external audits.
**Spec Version:** `UML_OS.Replay.DeterminismAuditPlaybook_v1` | 2026-02-21 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Replay.DeterminismAuditPlaybook_v1`
- **Purpose (1 sentence):** Determinism evidence audit playbook.
- **Spec Version:** `UML_OS.Replay.DeterminismAuditPlaybook_v1` | 2026-02-21 | Authors: Olejar Damir
- **Domain / Problem Class:** reproducibility auditing.
### 0.A Objective Semantics
- Map determinism profile rules to observable evidence and deterministic failures.
### 0.B Reproducibility Contract
- Replayable given `(replay_token, determinism_profile_hash, trace_final_hash, checkpoint_hash, certificate_hash)`.
### 0.C Numeric Policy
- E1 tolerances from active profile; default fallback from replay contract.
### 0.D Ordering and Tie-Break Policy
- First divergence is earliest by `(t, operator_seq, field_path)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Multi-run comparison allowed; summaries reduce deterministically.
### 0.F Environment and Dependency Policy
- Requires env/toolchain hash lock and registry root lock.
### 0.G Operator Manifest
- `UML_OS.Replay.CompareTrace_v1`
- `UML_OS.Replay.VerifyReplayToken_v1`
- `UML_OS.Certificate.VerifyBoundHashes_v1`
### 0.H Namespacing and Packaging
- Audit package path: `audit/determinism/<run_id>/`.
### 0.I Outputs and Metric Schema
- Outputs: `(determinism_audit_report, failure_digest_hash)`.
### 0.J Spec Lifecycle Governance
- Failure digest schema is MAJOR-governed.
### 0.K Failure and Error Semantics
- Determinism violations emit deterministic failure digest.
### 0.L Input/Data Provenance
- Inputs from replay, trace, checkpoint, certificate, error-code contracts.

## 2) Profile-to-Evidence Mapping (Normative)
| profile_rule | evidence_fields | verifier |
|---|---|---|
| `E0 bitwise identity` | `trace_final_hash`, `checkpoint_hash`, critical field bytes | `UML_OS.Replay.CompareTrace_v1` |
| `E1 tolerance` | field-level tolerances + compared values | `UML_OS.Replay.CompareTrace_v1` |
| replay token binding | `replay_token`, `manifest_hash`, `env_manifest_hash` | `UML_OS.Replay.VerifyReplayToken_v1` |
| certificate consistency | bound hashes in signed payload | `UML_OS.Security.VerifyCertificate_v1` |

## 3) Failure Digest (Normative)
- `failure_digest = {failure_code, first_divergence_operator, first_divergence_path, trace_hash_lhs, trace_hash_rhs, evidence_refs}`.
- `failure_digest_hash = SHA-256(CBOR_CANONICAL(["failure_digest_v1", failure_digest]))`.

## 4) Error Taxonomy Reference
- Authoritative codes: `docs/layer1-foundation/Error-Codes.md`.

## 6) Procedure
```text
1. Verify replay-token and environment/registry bindings.
2. Compare trace/checkpoint/certificate commitments by profile rule.
3. Locate first deterministic divergence.
4. Emit determinism_audit_report and failure_digest_hash.
```

FILE: layer4-implementation/Determinism-Debug-Checklist.md
==========================================================
# UML_OS Determinism Debug Checklist
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.DeterminismDebugChecklist_v1`  
**Purpose (1 sentence):** Define deterministic debugging workflow to localize and resolve replay divergence sources across data, model, DP, backend, and runtime layers.  
**Spec Version:** `UML_OS.Implementation.DeterminismDebugChecklist_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Replay debugging and incident triage.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.DeterminismDebugChecklist_v1`
- **Purpose (1 sentence):** Deterministic divergence triage.
### 0.A Objective Semantics
- minimize time-to-root-cause for determinism failures.
### 0.B Reproducibility Contract
- checklist verdict reproducible from artifacts and profile hash.
### 0.C Numeric Policy
- comparator math in binary64.
### 0.D Ordering and Tie-Break Policy
- triage sequence fixed: config -> data -> RNG -> backend -> DP -> model.
### 0.E Parallel, Concurrency, and Reduction Policy
- checks may run parallel, findings merged in fixed order.
### 0.F Environment and Dependency Policy
- must compare lockfile + env manifest before other checks.
### 0.G Operator Manifest
- `UML_OS.Replay.CheckArtifactLinkage_v1`
- `UML_OS.Replay.CheckRNGProgression_v1`
- `UML_OS.Replay.CheckBackendProfile_v1`
- `UML_OS.Replay.LocalizeFirstDivergence_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- replay/debug operators under `UML_OS.Replay.*`.
### 0.I Outputs and Metric Schema
- `(debug_report, root_cause, remediation_actions)`.
### 0.J Spec Lifecycle Governance
- checklist ordering changes are MINOR; acceptance criteria changes MAJOR.
### 0.K Failure and Error Semantics
- inability to localize emits deterministic fallback code.
### 0.L Input/Data Provenance
- uses run artifacts and trace chain.

---
## 2) System Model
### I.A Persistent State
- debug session state and finding registry.
### I.B Inputs and Hyperparameters
- baseline run refs, candidate run refs, replay mode.
### I.C Constraints and Feasible Set
- both runs must be artifact-complete.
### I.D Transient Variables
- per-stage check results.
### I.E Invariants and Assertions
- first divergence index monotonic once found.

---
## 3) Initialization
1. Load evidence bundles.
2. Verify shared schema versions.
3. Initialize check pipeline.

---
## 4) Operator Manifest
- `UML_OS.Replay.CheckArtifactLinkage_v1`
- `UML_OS.Replay.CheckRNGProgression_v1`
- `UML_OS.Replay.CheckBackendProfile_v1`
- `UML_OS.Replay.LocalizeFirstDivergence_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Replay.CheckArtifactLinkage_v1`  
**Signature:** `(baseline_refs, candidate_refs -> linkage_report)`  
**Purity class:** PURE  
**Definition:** Verifies hash-chain and artifact binding coherence.

**Operator:** `UML_OS.Replay.LocalizeFirstDivergence_v1`  
**Signature:** `(trace_a, trace_b -> divergence_location)`  
**Purity class:** PURE  
**Definition:** Finds first mismatched record by comparator profile.

---
## 6) Procedure
```text
1. linkage <- CheckArtifactLinkage_v1(...)      # config/data linkage stage
2. rng_check <- CheckRNGProgression_v1(...)     # RNG stage
3. backend_check <- CheckBackendProfile_v1(...) # backend stage
4. loc <- LocalizeFirstDivergence_v1(linkage, rng_check, backend_check, ...)
5. return debug_report with deterministic remediation ordering
```

---
## 7) Trace & Metrics
- Metrics: `first_divergence_t`, `first_divergence_operator`, `failed_checks_count`.
- Trace logs each checklist stage result.

---
## 8) Validation
- golden divergence cases for data/RNG/backend/DP.
- deterministic root-cause ranking test.

---
## 9) Refactor & Equivalence
- E0 for root-cause category and first divergence location.

---
## 10) Checkpoint/Restore
- debug checkpoint includes completed stage ids and localized divergence cursor.

FILE: layer4-implementation/Deterministic-RNG-Implementation-Guide.md
=====================================================================
# UML_OS Deterministic RNG Implementation Guide
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.DeterministicRNGGuide_v1`  
**Purpose (1 sentence):** Define deterministic RNG implementation rules across kernel, data, model, and DP operators.  
**Spec Version:** `UML_OS.Implementation.DeterministicRNGGuide_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** RNG determinism and replay.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.DeterministicRNGGuide_v1`
- **Purpose (1 sentence):** Deterministic RNG implementation contract.
### 0.A Objective Semantics
- minimize RNG divergence and ownership violations.
### 0.B Reproducibility Contract
- reproducible given `(seed, rng_policy_hash, operator_id, rng_offsets)`.
### 0.C Numeric Policy
- counters and offsets are uint64 exact.
### 0.D Ordering and Tie-Break Policy
- RNG draws ordered by canonical operator execution sequence.
### 0.E Parallel, Concurrency, and Reduction Policy
- substreams deterministic by `(rank, operator_seq, tensor_index)`.
### 0.F Environment and Dependency Policy
- pinned PRNG implementation and version.
### 0.G Operator Manifest
- `UML_OS.Random.InitializePRNG_v1`
- `UML_OS.Random.DeriveSubstream_v1`
- `UML_OS.Random.ConsumeDeterministic_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Random.*` namespace.
### 0.I Outputs and Metric Schema
- outputs: `(rng_report, offset_audit)`.
### 0.J Spec Lifecycle Governance
- PRNG family change is MAJOR.
### 0.K Failure and Error Semantics
- unauthorized RNG consumption is fatal.
### 0.L Input/Data Provenance
- RNG state transitions must be trace-bound.

---
## 2) System Model
### I.A Persistent State
- RNG root state and per-operator offset table.
### I.B Inputs and Hyperparameters
- seed, operator id, rank, stream id.
### I.C Constraints and Feasible Set
- stochastic ops only; pure ops must not consume RNG.
### I.D Transient Variables
- substream keys and counters.
### I.E Invariants and Assertions
- monotonic offset progression per stream.

---
## 3) Initialization
1. Initialize root RNG state.
2. Bind deterministic substream policy.
3. Initialize offset audit log.

---
## 4) Operator Manifest
- `UML_OS.Random.InitializePRNG_v1`
- `UML_OS.Random.DeriveSubstream_v1`
- `UML_OS.Random.ConsumeDeterministic_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Random.DeriveSubstream_v1`  
**Signature:** `(root_state, operator_id, rank, operator_seq -> substream_state)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Derives deterministic substream state by canonical tuple hashing.

---
## 6) Procedure
```text
1. Initialize root RNG
2. Derive per-operator substream
3. Consume draws with offset tracking
4. Emit RNG audit and fail on ownership violations
```

---
## 7) Trace & Metrics
- Metrics: `rng_draws_total`, `rng_violations`, `max_offset`.
- Trace includes `rng_offset_before`, `rng_offset_after`, `operator_id`.

---
## 8) Validation
- golden RNG vectors for seed/substream/draw outputs.
- ownership violation tests.

---
## 9) Refactor & Equivalence
- E0 for generated random streams and offsets.

---
## 10) Checkpoint/Restore
- checkpoint stores root RNG state and per-stream offsets.
- restore must resume identical draw sequences.

FILE: layer4-implementation/Developer-Setup.md
==============================================
# UML_OS Developer Setup Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.DeveloperSetup_v1`  
**Purpose (1 sentence):** Define deterministic local developer environment setup and verification steps for implementing UML_OS components.  
**Spec Version:** `UML_OS.Implementation.DeveloperSetup_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Local development bootstrap and environment consistency.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.DeveloperSetup_v1`
- **Purpose (1 sentence):** Deterministic developer setup contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: minimize setup drift and non-reproducible local runs.
### 0.B Reproducibility Contract
- Replayable given `(lockfile_hash, toolchain_hash, env_manifest_hash, determinism_profile_hash)`.
### 0.C Numeric Policy
- N/A except deterministic parsing of versions and hashes.
### 0.D Ordering and Tie-Break Policy
- Setup checks execute in fixed order.
### 0.E Parallel, Concurrency, and Reduction Policy
- Validation may run in parallel; verdict merge order is deterministic.
### 0.F Environment and Dependency Policy
- Canonical runtime pins must match `docs/layer1-foundation/Dependency-Lock-Policy.md` and `docs/layer1-foundation/Environment-Manifest.md`.
### 0.G Operator Manifest
- `UML_OS.Dev.Setup.ValidateHost_v1`
- `UML_OS.Dev.Setup.ValidateToolchain_v1`
- `UML_OS.Dev.Setup.ValidateEnvManifest_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Dev.Setup.*`
### 0.I Outputs and Metric Schema
- Outputs: `(setup_report, env_manifest_hash)`
- Metrics: `checks_passed`, `checks_failed`
### 0.J Spec Lifecycle Governance
- Required check changes are MAJOR.
### 0.K Failure and Error Semantics
- Abort on failed required setup checks.
### 0.L Input/Data Provenance
- Host/toolchain facts must be captured via canonical probes.

---
## 2) System Model
### I.A Persistent State
- Local cache of validated setup report.
### I.B Inputs and Hyperparameters
- Host OS info, Python/toolchain versions, lockfiles, config.
### I.C Constraints and Feasible Set
- Valid iff required versions/hashes/flags match policy.
### I.D Transient Variables
- Probe outputs and normalized diagnostics.
### I.E Invariants and Assertions
- No hidden defaults; all env vars used by runtime are declared.

---
## 3) Initialization
1. Load dependency and environment contracts.
2. Probe host/runtime/toolchain.
3. Build deterministic setup checklist.

---
## 4) Operator Manifest
- `UML_OS.Dev.Setup.ValidateHost_v1`
- `UML_OS.Dev.Setup.ValidateToolchain_v1`
- `UML_OS.Dev.Setup.ValidateEnvManifest_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Dev.Setup.ValidateHost_v1`  
**Signature:** `(host_probe -> host_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Dev.Setup.ValidateToolchain_v1`  
**Signature:** `(toolchain_probe, lock_policy -> toolchain_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Dev.Setup.ValidateEnvManifest_v1`  
**Signature:** `(env_manifest, profile -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. ValidateHost_v1
2. ValidateToolchain_v1
3. ValidateEnvManifest_v1
4. Emit setup_report
```

---
## 7) Trace & Metrics
### Logging rule
- Setup emits deterministic validation records.
### Trace schema
- `run_header`: setup_version, host_id_hash
- `iter`: check_id, status
- `run_end`: setup_status, env_manifest_hash
### Metric schema
- `checks_passed`, `checks_failed`
### Comparability guarantee
- Comparable iff same setup spec + probe inputs.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Required checks complete and deterministic ordering enforced.
#### VII.B Operator test vectors (mandatory)
- Valid/invalid host and toolchain fixtures.
#### VII.C Golden traces (mandatory)
- Golden setup traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for setup verdict and report hash.
#### VIII.B Allowed refactor categories
- Probe implementation changes preserving normalized outputs.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of setup reports.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Last validated setup report hash and manifest hash.
### Serialization
- Canonical CBOR.
### Restore semantics
- Restored setup context must reproduce identical validation verdict.

---
## 11) Time-to-First-Success Profile Promise (Normative)
- `core` profile setup target:
  - deterministic quickstart completion in under 10 seconds on supported baseline hardware.
- `enterprise` and `regulated` profiles:
  - may require additional controls, but MUST declare incremental setup deltas relative to `core`.
- Setup reports MUST include:
  - profile id,
  - time-to-first-success measurement (informational),
  - deterministic verdict fields unaffected by timing variance.
- Onboarding companion references:
  - `docs/layer4-implementation/Gentle-Introduction.md`
  - `docs/layer4-implementation/Hello-World-End-to-End-Example.md`
  - `docs/layer4-implementation/Common-Pitfalls-Guide.md`

FILE: layer4-implementation/Developer-Troubleshooting-FAQ.md
============================================================
# UML_OS Developer Troubleshooting FAQ Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.TroubleshootingFAQ_v1`  
**Purpose (1 sentence):** Define deterministic diagnosis mappings from common development failures to canonical remediation workflows.  
**Spec Version:** `UML_OS.Implementation.TroubleshootingFAQ_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Developer support and failure remediation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.TroubleshootingFAQ_v1`
- **Purpose (1 sentence):** Deterministic troubleshooting reference contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: reduce time to deterministic root-cause and fix.
### 0.B Reproducibility Contract
- Replayable given `(failure_code, evidence_hashes, faq_version)`.
### 0.C Numeric Policy
- N/A except exact failure-code matching.
### 0.D Ordering and Tie-Break Policy
- FAQ lookup order is deterministic by failure code, then context key.
### 0.E Parallel, Concurrency, and Reduction Policy
- Multiple candidate remedies allowed; ranking deterministic.
### 0.F Environment and Dependency Policy
- Remediation steps must preserve evidence and contract bindings.
### 0.G Operator Manifest
- `UML_OS.FAQ.ResolveFailure_v1`
- `UML_OS.FAQ.GetRemediationSteps_v1`
- `UML_OS.FAQ.ValidateResolution_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.FAQ.*`
### 0.I Outputs and Metric Schema
- Outputs: `(faq_resolution_report, remediation_plan)`
- Metrics: `lookups_total`, `resolved_count`, `unresolved_count`
### 0.J Spec Lifecycle Governance
- Remediation mappings for required failure codes are MAJOR-governed.
### 0.K Failure and Error Semantics
- Unknown required failure mappings are deterministic failures.
### 0.L Input/Data Provenance
- Each recommendation must reference linked contract docs and evidence requirements.

---
## 2) System Model
### I.A Persistent State
- FAQ mapping table and remediation recipes.
### I.B Inputs and Hyperparameters
- failure code, subsystem, evidence hashes, runtime mode.
### I.C Constraints and Feasible Set
- Valid iff failure code has deterministic resolution mapping.
### I.D Transient Variables
- lookup diagnostics and selected remediation plan.
### I.E Invariants and Assertions
- Resolution advice must not conflict with contract policies.

---
## 3) Initialization
1. Load FAQ map and schema.
2. Validate required failure-code coverage.
3. Build deterministic lookup index.

---
## 4) Operator Manifest
- `UML_OS.FAQ.ResolveFailure_v1`
- `UML_OS.FAQ.GetRemediationSteps_v1`
- `UML_OS.FAQ.ValidateResolution_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.FAQ.ResolveFailure_v1`  
**Signature:** `(failure_code, context -> resolution_id)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.FAQ.GetRemediationSteps_v1`  
**Signature:** `(resolution_id -> remediation_plan)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.FAQ.ValidateResolution_v1`  
**Signature:** `(remediation_plan, context -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. ResolveFailure_v1
2. GetRemediationSteps_v1
3. ValidateResolution_v1
4. Return remediation_plan + report
```

---
## 7) Trace & Metrics
### Logging rule
- FAQ lookups emit deterministic resolution records.
### Trace schema
- `run_header`: faq_version, failure_code
- `iter`: lookup_step, status
- `run_end`: resolution_id, validation_status
### Metric schema
- `lookups_total`, `resolved_count`, `unresolved_count`
### Comparability guarantee
- Comparable iff same failure code and evidence context.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Required failure codes must have mappings.
#### VII.B Operator test vectors (mandatory)
- Lookup and remediation fixtures.
#### VII.C Golden traces (mandatory)
- Golden troubleshooting traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for selected resolution and remediation plan hash.
#### VIII.B Allowed refactor categories
- FAQ storage/index refactors preserving mappings.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of resolution outputs on fixed contexts.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Lookup cursor and partial resolution context.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed troubleshooting session preserves selected resolution path.

FILE: layer4-implementation/Disaster-Recovery-Operations-Runbook.md
===================================================================
# UML_OS Disaster Recovery Operations Runbook
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Operations.DisasterRecovery_v1`  
**Purpose (1 sentence):** Define deterministic operations procedures for severe failures, including full cluster loss and data corruption events.  
**Spec Version:** `UML_OS.Operations.DisasterRecovery_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) Full Cluster Failure Recovery
1. Recover control plane state from signed backups.
2. Reconstitute operator registry and trust roots.
3. Re-establish key material and HSM/KMS trust links.
4. Restore latest valid checkpoint/trace/wal artifacts.
5. Run deterministic replay integrity check before reopening traffic.

## 2) Data Corruption Recovery
- Detection:
  - checksum/hash mismatches during artifact validation/restore.
- Recovery:
  - isolate corrupted objects,
  - recover from secondary replica or lineage reconstruction,
  - verify rebuilt object hash links before promotion.

## 3) Incident Post-Mortem Linkage
- Every DR incident MUST produce:
  - incident summary,
  - affected hash roots,
  - evidence links,
  - remediation tasks linked to specific contract sections.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Disaster Recovery Operations Runbook" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Distributed-Failure-Recovery-Guide.md
=================================================================
# UML_OS Distributed Failure Recovery Guide
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Runtime.DistributedFailureRecovery_v1`  
**Purpose (1 sentence):** Define deterministic distributed failure detection, lease handling, restart sequencing, and recovery validation.  
**Spec Version:** `UML_OS.Runtime.DistributedFailureRecovery_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Distributed runtime reliability.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Runtime.DistributedFailureRecovery_v1`
- **Purpose (1 sentence):** Deterministic distributed failure recovery contract.
### 0.A Objective Semantics
- minimize unrecoverable distributed run states and split-brain risk.
### 0.B Reproducibility Contract
- recovery outcomes reproducible from `(failure_event_log_hash, lease_policy_hash, checkpoint_hash)`.
### 0.C Numeric Policy
- lease counters and epochs are uint64 exact.
### 0.D Ordering and Tie-Break Policy
- recovery actions ordered by `(epoch, rank, event_seq)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- rank-level checks parallelized; recovery plan aggregation deterministic.
### 0.F Environment and Dependency Policy
- distributed backend profile and timeout policy pinned.
### 0.G Operator Manifest
- `UML_OS.Runtime.DetectFailureEvent_v1`
- `UML_OS.Runtime.ResolveLeaseState_v1`
- `UML_OS.Runtime.ComputeRecoveryPlan_v1`
- `UML_OS.Runtime.ExecuteRecoveryPlan_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Runtime.*` namespace.
### 0.I Outputs and Metric Schema
- outputs: `(recovery_report, restart_plan_hash, final_cluster_state)`.
### 0.J Spec Lifecycle Governance
- lease/restart policy changes are MAJOR.
### 0.K Failure and Error Semantics
- unresolved lease conflicts fail closed deterministically.
### 0.L Input/Data Provenance
- all failure events and lease transitions are trace-bound.

---
## 2) System Model
### I.A Persistent State
- lease table, rank health state, recovery epoch.
### I.B Inputs and Hyperparameters
- failure events, lease TTL policy, checkpoint refs.
### I.C Constraints and Feasible Set
- exactly one active lease owner per partition.
### I.D Transient Variables
- per-rank health checks and plan candidates.
### I.E Invariants and Assertions
- no split-brain committed state transitions.

---
## 3) Initialization
1. Load cluster lease and health snapshots.
2. Validate last committed checkpoint binding.
3. Initialize recovery epoch context.

---
## 4) Operator Manifest
- `UML_OS.Runtime.DetectFailureEvent_v1`
- `UML_OS.Runtime.ResolveLeaseState_v1`
- `UML_OS.Runtime.ComputeRecoveryPlan_v1`
- `UML_OS.Runtime.ExecuteRecoveryPlan_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Runtime.DetectFailureEvent_v1`
**Signature:** `(cluster_state, health_signals -> failure_events)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** Canonically classifies rank/node failures and emits ordered failure events.

**Operator:** `UML_OS.Runtime.ResolveLeaseState_v1`
**Signature:** `(lease_table, failure_events, lease_policy -> lease_state)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** Resolves lease ownership with deterministic epoch/rank tie-breaking and split-brain prevention.

**Operator:** `UML_OS.Runtime.ComputeRecoveryPlan_v1`  
**Signature:** `(cluster_state, failure_events, lease_state -> recovery_plan)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Produces deterministic restart/eviction/rejoin plan.

**Operator:** `UML_OS.Runtime.ExecuteRecoveryPlan_v1`
**Signature:** `(recovery_plan, cluster_state -> recovery_report, final_cluster_state)`
**Purity class:** IO
**Determinism:** deterministic
**Definition:** Executes ordered recovery actions and validates resulting cluster state.

---
## 6) Procedure
```text
1. failure_events <- DetectFailureEvent_v1
2. lease_state <- ResolveLeaseState_v1
3. recovery_plan <- ComputeRecoveryPlan_v1
4. recovery_report, final_cluster_state <- ExecuteRecoveryPlan_v1
5. restart_plan_hash <- SHA-256(CBOR_CANONICAL(recovery_plan))
6. return (recovery_report, restart_plan_hash, final_cluster_state)
```

---
## 7) Trace & Metrics
- Metrics: `failed_ranks`, `recovery_attempts`, `recovery_success`, `split_brain_prevented`.
- Trace includes epoch, lease transitions, restart actions.

---
## 8) Validation
- rank loss and network partition scenario tests.
- deterministic restart ordering and lease conflict tests.

---
## 9) Refactor & Equivalence
- E0 for recovery plan hash and final cluster-state verdict.

---
## 10) Checkpoint/Restore
- checkpoint stores recovery epoch, lease table, pending plan hash.
- restore resumes recovery workflow deterministically.

---
## 11) Distributed Failure Fingerprint Standard (Normative)
- Every distributed recovery incident MUST emit a compact deterministic failure fingerprint:
  - `failure_operator`,
  - `failure_code`,
  - `first_divergence_step`,
  - `rank_set_hash`,
  - `network_state_hash`,
  - `recovery_plan_hash`,
  - `trace_segment_hash`.
- Fingerprint identity:
  - `distributed_failure_fingerprint_hash = SHA-256(CBOR_CANONICAL(failure_fingerprint_v1))`.
- Support workflow requirement:
  - fingerprint is the primary cross-environment triage key.

FILE: layer4-implementation/EQC-CI-Policy.md
============================================
# UML_OS EQC CI Policy
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.EQCCIPolicy_v1`
**Purpose (1 sentence):** Define deterministic CI gate policy that maps EQC lint/test outcomes to merge and release decisions.
**Spec Version:** `UML_OS.Implementation.EQCCIPolicy_v1` | 2026-02-19 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** CI/CD governance for EQC conformance.

---
## 1) Pipeline Stages (Normative)
1. `stage_lint`
2. `stage_contract_sync`
3. `stage_conformance`
4. `stage_replay`
5. `stage_release_gates`

Stage order is fixed and deterministic.

---
## 2) Mandatory Commands
- `eqc-es validate`
- `eqc-es impact --change DOCID@vX.Y.Z`
- `eqc-es regenerate-sidecars`
- `python3 tools/spec_lint.py`

---
## 3) Gate Mapping Rules
- Any BLOCKER lint finding: `merge=DENY`.
- Missing graph/reference parity: `merge=DENY`.
- Layer or edge-type violation: `merge=DENY`.
- Conformance or replay gate failure: `release=DENY`.
- Warnings only: `merge=ALLOW_WITH_NOTICE`.

---
## 4) Deterministic Verdict Contract
`ci_verdict_hash = SHA-256(CBOR_CANONICAL([pipeline_id, commit_hash, stage_outcomes, lint_verdict, conformance_verdict, replay_verdict]))`

`ci_verdict_hash` is logged in release evidence and validation logs.

---
## 5) Wiring References
- `docs/layer4-implementation/Build-and-CI-Matrix.md`
- `docs/layer4-implementation/Spec-Lint-Implementation.md`
- `docs/layer4-implementation/Spec-Lint-Rules.md`
- `docs/layer4-implementation/Change-Control-Playbook.md`
- `docs/layer3-tests/Test-Plan.md`
- `ecosystem.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS EQC CI Policy" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Ecosystem-Expansion-Roadmap.md
==========================================================
# UML_OS Ecosystem Expansion Roadmap (Items 12-40)
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.EcosystemExpansionRoadmap_v1`  
**Purpose (1 sentence):** Define the next-wave ecosystem, operations, governance, and interoperability expansions needed for category-leading platform adoption.  
**Spec Version:** `UML_OS.Implementation.EcosystemExpansionRoadmap_v1` | 2026-02-20 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Strategic platform expansion and ecosystem integration.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.EcosystemExpansionRoadmap_v1`
- **Purpose (1 sentence):** Deterministic execution plan for market-facing expansion tracks.
### 0.A Objective Semantics
- Minimize adoption friction while preserving deterministic, auditable guarantees.
### 0.B Reproducibility Contract
- Replayable given `(expansion_plan_hash, profile_bundle_hash, governance_policy_hash, interoperability_policy_hash)`.
### 0.C Numeric Policy
- Prioritization and scoring use binary64.
### 0.D Ordering and Tie-Break Policy
- Workstream order is fixed by this contract; intra-workstream task ties break by lexical task id.
### 0.E Parallel, Concurrency, and Reduction Policy
- Independent workstreams may execute in parallel; final readiness verdict is deterministic fail-dominant reduction.
### 0.F Environment and Dependency Policy
- All outputs must bind `env_manifest_hash` and release profile id.
### 0.G Operator Manifest
- `UML_OS.Implementation.PlanWorkstream_v1`
- `UML_OS.Implementation.EvaluateWorkstreamReadiness_v1`
- `UML_OS.Implementation.EmitExpansionReport_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Implementation.*` for planning/evaluation operators.
### 0.I Outputs and Metric Schema
- Outputs: `(expansion_report, readiness_by_workstream, release_blockers, expansion_evidence_hash)`.
- Metrics: `workstreams_total`, `workstreams_ready`, `blockers_open`.
### 0.J Spec Lifecycle Governance
- Workstream contract changes are MINOR; readiness gate semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- Missing mandatory evidence for required profiles is deterministic failure.
### 0.L Input/Data Provenance
- All workstream artifacts must be hash-addressed and cross-linked to source contracts.

---
## 2) Expansion Workstreams (12-40)
### II.A Deep ML Ecosystem Integration (12)
- Native connectors:
  - Snowflake, BigQuery, S3, ADLS, Delta Lake.
- Requirements:
  - deterministic ingestion envelopes,
  - automatic dataset registration + schema inference,
  - lineage binding to data contracts.
- External model registry sync:
  - Hugging Face Hub, MLflow Registry, SageMaker Registry.
- Feature store integration:
  - deterministic point-in-time lookup contracts for Feast/Tecton class systems.

### II.B Real-Time and Streaming Determinism (13)
- Streaming `NextBatch` variant for Kafka/Kinesis/Pulsar.
- Exactly-once micro-batch semantics + deterministic offset checkpointing.
- Stateful streaming operator state snapshots in checkpoints.
- Manifest-defined watermarks + late-data policies.

### II.C Advanced Model Lifecycle Automation (14)
- Manifest-driven retraining triggers (drift/time policy).
- Built-in canary/blue-green/A-B rollout orchestration.
- Performance decay detection integrated with monitoring policy.
- Parent-child generation lineage (verifiable model family tree).

### II.D Security Hardening and Compliance Automation (15)
- Automated compliance cross-framework reports (GDPR/HIPAA/SOC2 mapping).
- Data residency controls enforced in runtime/storage policies.
- Confidential multi-party compute proof inclusion in certificates.
- Unified attestation chain format for heterogeneous TEEs.

### II.E Developer Productivity and UX (16)
- Interactive IR/job debugger with redaction-aware tensor inspection.
- Jupyter integration and notebook-to-manifest conversion.
- Snippet library + CLI inject workflow for common patterns.
- IDE language-server features: schema-aware completion + inline docs.

### II.F Governance and Policy as Code (17)
- Data usage policy language with purpose restrictions.
- Regulation-as-code bundles and continuous validation.
- Policy versioning and fully reproducible evaluation history.

### II.G Economic Models and Incentives (18)
- Verifiable compute marketplace execution path.
- Token-based accounting and chargeback/billing records.
- License and royalty usage tracking bound to certificate artifacts.

### II.H Environmental Sustainability (19)
- Carbon-aware scheduling policy integration.
- Run-level energy accounting in evidence/certificates.
- Green-optimization guidance with determinism-preserving constraints.

### II.I Long-Term Archival and Notarization (20)
- Self-contained preservation package format (`.umlospack`).
- Public/notary timestamp anchoring for long-term tamper evidence.
- Bit-rot detection and deterministic archival integrity rechecks.

### II.J Multi-Tenancy at Scale (21)
- Hierarchical tenancy (org/project/run) with inherited policy controls.
- Deterministic fairness/quota scheduling with burst/preemption semantics.
- Immutable per-tenant audit streams.

### II.K Rich Observability Beyond Metrics (22)
- End-to-end distributed tracing spans per operator invocation.
- Structured log schema with trace/metric correlation fields.
- Real-time run/policy/resource dashboards with deterministic drill-down IDs.

### II.L Research Extensibility (23)
- Plugin architecture for optimizers/experimental operators with conformance checks.
- Manifest feature flags for controlled experimentation.
- DOI/paper hash linkage in run evidence and certificate context.

### II.M Cross-Version Guarantees (24)
- LTS windows (3-5 years target policy band).
- Automated old-artifact corpus compatibility test framework.
- Graceful deprecation over at least two MAJOR releases where feasible.

### II.N Community Recognition and Incentives (25)
- Bug bounty framework for determinism/security classes.
- Contribution impact reports and recognition badges.
- Certified developer program with exam/practical evidence.

### II.O Formal Methods for Implementation Safety (26)
- Model checking for orchestrator liveness/safety properties.
- IR executor fuzzing harness at large DAG scale.
- Symbolic execution for critical operators under contract preconditions.

### II.P MLOps Toolchain Integration (27)
- Kubeflow component wrappers.
- Airflow operators (`UMLOSRunOperator`, certificate wait operators).
- MLflow project flavor integration.

### II.Q Emerging Hardware Adaptation (28)
- Quantum-hybrid adapter roadmap.
- Neuromorphic/spiking operator support roadmap.
- Optical/analog accelerator primitive mapping policy.

### II.R Accessibility for Non-Experts (29)
- Natural-language assisted manifest bootstrap.
- GUI pipeline builder with deterministic export.
- Community template gallery with profile compatibility tags.

### II.S Continuous Improvement Process (30)
- Quarterly public roadmap reviews.
- Public technical debt and deprecation dashboard.
- Post-release retrospective publication requirement.

### II.T Responsible AI and Ethics Hooks (31)
- Fairness metric hooks and optional gate policies.
- Model-card-as-code autopopulation from run evidence.
- License/terms hash provenance for training data.

### II.U DR and Business Continuity (32)
- Region failover continuity proofs.
- Full backup/restore validated drills.
- Managed chaos engineering service profile.

### II.V Identity and Access Integration (33)
- SAML/OIDC/LDAP identity mapping contracts.
- Fine-grained IAM role federation mappings.
- Break-glass JIT access with deterministic revocation/audit.

### II.W Multi-Cloud and Hybrid Cloud (34)
- Unified commit-pointer semantics across cloud/on-prem stores.
- Cloud-agnostic manifest portability profile.
- Cost-aware placement under residency/performance constraints.

### II.X Collaborative Model Development (35)
- Model branch/merge semantics with deterministic conflict policy.
- Annotation/comment attachment to IR steps with trace linkage.
- Deterministic collaborative manifest merge protocol.

### II.Y Data Privacy Lifecycle Integration (36)
- Tokenization/anonymization operators with key policy binding.
- Trace/log masking with auditor-unseal authorization controls.
- Consent-withdrawal impact tracing to model/version compliance states.

### II.Z Online Learning and Continuous Deployment (37)
- Incremental update operators with checkpoint granularity guarantees.
- Continuous deploy path with canary + deterministic rollback.
- Model freshness attestations in certificates.

### III.A HSM and Key Governance (38)
- HSM-backed signing requirements for certificates.
- Key-usage attestation artifacts.
- Deterministic key rotation policy integration.

### III.B Regulatory Sandbox Support (39)
- Sandbox profile with relaxed gates but mandatory full audit tagging.
- Regulator-specific policy bundles and export formats.
- Signed regulator-ready report generation.

### III.C Long-Term Vision Artifacts (40)
- Annual state-of-platform report.
- Public future-direction whitepapers.
- Academic collaboration integration loop for spec evolution.

---
## 3) Procedure
```text
1. Resolve target release profile and required workstream set.
2. Validate dependency order and mandatory prerequisites.
3. Execute workstream readiness checks with deterministic criteria.
4. Aggregate readiness and emit blockers.
5. Emit expansion_evidence_hash and publish expansion report.
```

---
## 4) Validation
- Every workstream must define:
  - scope boundary,
  - deterministic success criteria,
  - evidence artifact format,
  - release gate binding.
- Regulated profile requires evidence-grade completion for applicable workstreams.

---
## 5) Checkpoint/Restore
- Checkpoint stores completed workstream ids, pending set, partial readiness hashes.
- Restore must resume with identical final readiness/blocker results.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Evidence-Catalog.md
===============================================
# UML_OS Evidence Catalog
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Release.EvidenceCatalog_v1`
**Purpose (1 sentence):** Define the authoritative evidence artifact catalog with schema, producer, verifier, and gate bindings.
**Spec Version:** `UML_OS.Release.EvidenceCatalog_v1` | 2026-02-21 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Release.EvidenceCatalog_v1`
- **Purpose (1 sentence):** Deterministic evidence catalog contract.
- **Spec Version:** `UML_OS.Release.EvidenceCatalog_v1` | 2026-02-21 | Authors: Olejar Damir
- **Domain / Problem Class:** evidence governance and external verifiability.
### 0.A Objective Semantics
- Every trust claim must map to a deterministic evidence artifact and verifier.
### 0.B Reproducibility Contract
- Replayable given `(evidence_catalog_version, artifact_refs, verifier_versions)`.
### 0.C Numeric Policy
- N/A.
### 0.D Ordering and Tie-Break Policy
- Catalog entries are ordered by `artifact_id` ascending UTF-8 bytewise.
### 0.E Parallel, Concurrency, and Reduction Policy
- Validation may run in parallel; verdict merge is fail-dominant.
### 0.F Environment and Dependency Policy
- Canonical serialization profile: `CanonicalSerialization_v1`.
### 0.G Operator Manifest
- `UML_OS.Release.CollectEvidence_v1`
- `UML_OS.Release.ValidateEvidenceBundle_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Evidence bundle path namespace: `release/evidence/<release_id>/`.
### 0.I Outputs and Metric Schema
- Outputs: `(evidence_catalog_report, evidence_catalog_hash)`.
### 0.J Spec Lifecycle Governance
- Catalog schema changes are MAJOR-governed.
### 0.K Failure and Error Semantics
- Missing mandatory artifact is deterministic failure.
### 0.L Input/Data Provenance
- Evidence producers must emit content-addressed artifacts.
### 0.Z EQC Mandatory Declarations Addendum
- `stochastic_used: false`
- `seed_space: N/A`
- `prng_family: N/A`
- `determinism_level: BITWISE`

## 2) Artifact Catalog (Normative)
| artifact_id | schema_ref | producer | verifier | referenced_by | failure_codes |
|---|---|---|---|---|---|
| `execution_certificate` | `docs/layer2-specs/Execution-Certificate.md` | `UML_OS.Certificate.WriteExecutionCertificate_v1` | `UML_OS.Security.VerifyCertificate_v1` | release gates, audit exports | `CONTRACT_VIOLATION`, `SIGNATURE_MISMATCH` |
| `trace_sidecar` | `docs/layer2-specs/Trace-Sidecar.md` | `UML_OS.IO.WriteTape_v1` | `UML_OS.Replay.CompareTrace_v1` | certificate payload, replay, release gates | `CONTRACT_VIOLATION`, `TRACE_SCHEMA_INVALID` |
| `checkpoint_manifest` | `docs/layer2-specs/Checkpoint-Schema.md` | `UML_OS.IO.SaveCheckpoint_v1` | `UML_OS.Checkpoint.Restore_v1` | certificate payload, replay, recovery proofs | `CONTRACT_VIOLATION`, `CHECKPOINT_INVALID` |
| `policy_transcript` | `docs/layer2-specs/Monitoring-Policy.md` | `UML_OS.Policy.Evaluate_v1` | `UML_OS.Monitor.DriftCompute_v1` | `policy_gate_hash`, release gates | `CONTRACT_VIOLATION`, `POLICY_VIOLATION` |
| `adapter_cert_bundle` | `docs/layer4-implementation/Third-Party-Operator-Certification-Program.md` | conformance harness | `UML_OS.Release.ValidateEvidenceBundle_v1` | enterprise/regulated gates | `CERT_BUNDLE_INVALID` |
| `chaos_recovery_proof_pack` | `docs/layer3-tests/Failure-Injection-Scenarios.md` | chaos harness | release gate verifier | regulated release gate | `RECOVERY_OUTCOME_MISMATCH` |
| `perf_baseline_bundle` | `docs/layer3-tests/Performance-Plan.md` | perf harness | `UML_OS.Perf.EvaluateRegressionPolicy_v1` | performance gate | `PERF_REGRESSION` |

## 3) Catalog Hash (Normative)
- `evidence_catalog_hash = SHA-256(CBOR_CANONICAL(["evidence_catalog_v1", entries]))`.

## 4) Cross-References
- `docs/layer4-implementation/Release-Evidence-Assembler.md`
- `docs/layer3-tests/Release-Gates.md`
- `docs/layer2-specs/Execution-Certificate.md`
- `docs/layer2-specs/Trace-Sidecar.md`

## 6) Procedure
```text
1. Load required artifacts for target release profile.
2. Validate each artifact against schema_ref and verifier.
3. Record deterministic pass/fail with failure code mapping.
4. Compute evidence_catalog_hash and emit catalog report.
```

FILE: layer4-implementation/Expansion-Catalog-041-250.md
========================================================
# UML_OS Expansion Catalog 041-250
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ExpansionCatalog041_250_v1`  
**Purpose (1 sentence):** Formalize high-scope expansion ideas (items 41-250) into a deterministic intake catalog with execution gates and profile-aware prioritization.  
**Spec Version:** `UML_OS.Implementation.ExpansionCatalog041_250_v1` | 2026-02-20 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Strategic roadmap intake and governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ExpansionCatalog041_250_v1`
- **Purpose (1 sentence):** Govern large-scale expansion proposals without compromising core determinism contracts.
### 0.A Objective Semantics
- Convert broad expansion demand into deterministic, staged, evidence-bound deliverables.
### 0.B Reproducibility Contract
- Replayable given `(catalog_hash, prioritization_policy_hash, profile_requirements_hash)`.
### 0.C Numeric Policy
- Priority scores in binary64; tie-break by stable idea id.
### 0.D Ordering and Tie-Break Policy
- Ideas ordered by numeric id (`041..250`) then priority score.
### 0.E Parallel, Concurrency, and Reduction Policy
- Independent tracks may run in parallel; release eligibility is fail-dominant reduction over required track gates.
### 0.F Environment and Dependency Policy
- Any promoted item must declare required profile(s), dependencies, and evidence format.
### 0.G Operator Manifest
- `UML_OS.Implementation.RegisterExpansionIdea_v1`
- `UML_OS.Implementation.ScoreExpansionIdea_v1`
- `UML_OS.Implementation.BindExpansionToBacklog_v1`
- `UML_OS.Implementation.EmitExpansionCatalogReport_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Catalog IDs: `EC-041` ... `EC-250`.
### 0.I Outputs and Metric Schema
- Outputs: `(catalog_report, prioritized_queue, blocked_items, catalog_hash)`.
- Metrics: `ideas_total`, `ideas_ready`, `ideas_blocked`, `ideas_promoted`.
### 0.J Spec Lifecycle Governance
- New idea additions are MINOR; reclassification of gate severity is MAJOR.
### 0.K Failure and Error Semantics
- Missing dependency/evidence definition => deterministic block.
### 0.L Input/Data Provenance
- Source proposals and rationale must be hash-addressed and immutable in review history.

---
## 2) Catalog Scope (Items 41-250)
### II.A Developer Zero-Friction and Tooling (041-044)
- `EC-041` zero-friction DX (`init/check/self-heal/explore`).
- `EC-042` sub-millisecond inference contract extensions.
- `EC-043` cross-run analytics/query/anomaly attribution.
- `EC-044` supply-chain security hardening (SLSA/pq-crypto/signing).

### II.B Policy/Governance/Ecosystem Hardware (055-066)
- `EC-055` policy-as-code with simulation + self-executing compliance exports.
- `EC-066` accelerator ecosystem (FPGA/TPU/neuromorphic).

### II.C Reliability/Privacy/Decentralization/Sustainability (077-099)
- `EC-077` pluggable DP accountants + composition proofs.
- `EC-088` Byzantine fault tolerance extensions + fault proofs.
- `EC-099` energy-aware operator accounting and certificate embedding.

### II.D Community/Future-Proof/Access/Explainability/DR/Data VCS (100-106)
- `EC-100` open governance and merit recognition programs.
- `EC-101` post-quantum agility and long-horizon archival cryptography.
- `EC-102` offline/low-bandwidth/delta-checkpoint/p2p artifact modes.
- `EC-103` explainability operators and evidence bindings.
- `EC-104` cross-region replication/failover proof and RTO contracts.
- `EC-105` DVC/LakeFS integrations and data diff reporting.
- `EC-106` multi-tenant federated learning with secure aggregation proofs.

### II.E Learning/CI/CD/Serving/Multimodal and Model Families (107-146)
- `EC-107` interactive educational resources and sandboxing.
- `EC-108` CI/CD native templates and PR impact comments.
- `EC-109` serverless cold-start optimization contracts.
- `EC-110` multimodal data/model/DP extensions.
- `EC-111` patent-ready provenance/custody.
- `EC-112` chaos manifests and chaos certificates.
- `EC-113` finance system and invoicing integrations.
- `EC-114` edge runtime and OTA verification.
- `EC-115` carbon labeling and marketplace display.
- `EC-116` synthetic data generation/DP/lineage.
- `EC-117` explainability platform export compatibility.
- `EC-118` multi-task learning contract set.
- `EC-119` RL environment/policy contract family.
- `EC-120` generative-model evaluation operators.
- `EC-121` continual learning and replay buffer determinism.
- `EC-122` uncertainty quantification and selective prediction.
- `EC-123` adversarial robustness and certificates.
- `EC-124` compression (pruning/quantization/distillation).
- `EC-125` AutoML deterministic sweep orchestration.
- `EC-126` causal inference contracts.
- `EC-127` interpretability-by-design operators.
- `EC-128` fairness constraints and debiasing contracts.
- `EC-129` shift/OOD detection and safe fallback.
- `EC-130` multi-agent deterministic simulation.
- `EC-131` hybrid classical-quantum integration.
- `EC-132` neurosymbolic integration proofs.
- `EC-133` evolutionary algorithm lineage certificates.
- `EC-134` meta-learning deterministic task distribution.
- `EC-135` Bayesian deep learning uncertainty evidence.
- `EC-136` GNN operators and sparse memory planning.
- `EC-137` time-series specific operators/metrics.
- `EC-138` recommender contracts and ranking metrics.
- `EC-139` anomaly detection and streaming alerts.
- `EC-140` NLP operators/decoding/metrics.
- `EC-141` CV operators/augmentations/metrics.
- `EC-142` audio/speech operators/metrics.
- `EC-143` RLHF pipeline evidence bindings.
- `EC-144` constitutional AI operators and certificates.
- `EC-145` alignment operators/evaluations.
- `EC-146` centralized policy server and automated compliance checks.

### II.F Incident/Audit/Marketplace and Domain Vertical Expansion (147-250)
- `EC-147` AI incident response automation.
- `EC-148` auditor API/audit package/verifier.
- `EC-149` AI marketplace listing/pricing/escrow.
- `EC-150` regulated industry packages (medical/finance/privacy).
- `EC-151` safety-critical standards alignment.
- `EC-152` space/defense hardened runtime patterns.
- `EC-153` tinyML and low-power continuity.
- `EC-154` HPC integration (MPI/schedulers/burst buffers).
- `EC-155` real-time and WCET certificate extensions.
- `EC-156` mixed-criticality scheduling/isolation proofs.
- `EC-157` open-source community operating model.
- `EC-158` academia reproducibility workflows.
- `EC-159` nonprofit/humanitarian enablement.
- `EC-160` arts/creative provenance.
- `EC-161` gaming fairness and rollback.
- `EC-162` robotics control/safety traces.
- `EC-163` autonomous vehicle safety envelope proofs.
- `EC-164` healthcare clinical evidence integration.
- `EC-165` finance risk/backtest certificates.
- `EC-166` energy/grid optimization certificates.
- `EC-167` agriculture precision pipelines.
- `EC-168` education personalization/grading certificates.
- `EC-169` legal evidence/analysis outputs.
- `EC-170` government transparency certificates.
- `EC-171` veterinary/wildlife behavior analytics.
- `EC-172` sports analytics/injury certificates.
- `EC-173` fashion trend/design reproducibility.
- `EC-174` architecture/construction AI certificates.
- `EC-175` chemistry/material discovery provenance.
- `EC-176` physics simulation reproducibility.
- `EC-177` genomics/protein systems evidence.
- `EC-178` neuroscience decoding reproducibility.
- `EC-179` psychology screening/governance concerns.
- `EC-180` sociology network/opinion simulation.
- `EC-181` economics agent-based policy simulation.
- `EC-182` political science forecasting/analysis.
- `EC-183` digital history inference.
- `EC-184` archaeology site/artifact analysis.
- `EC-185` linguistics computational analysis.
- `EC-186` philosophy computational reasoning.
- `EC-187` religion computational text analysis.
- `EC-188` mythology motif/comparison generation.
- `EC-189` folklore motif indexing.
- `EC-190` anthropology cultural analysis.
- `EC-191` geography spatial/climate analysis.
- `EC-192` oceanography simulations and tracking.
- `EC-193` meteorology prediction/attribution.
- `EC-194` astronomy object detection/simulation.
- `EC-195` aerospace mission planning evidence.
- `EC-196` defense deterministic mission AI.
- `EC-197` intelligence data-fusion provenance.
- `EC-198` law-enforcement forensic governance.
- `EC-199` emergency response optimization.
- `EC-200` humanitarian aid needs/impact certification.
- `EC-201` development economics causal evaluations.
- `EC-202` public health interventions.
- `EC-203` epidemiology modeling/tracing.
- `EC-204` environmental science ecosystem/pollution planning.
- `EC-205` climate science and geoengineering simulation.
- `EC-206` water resources optimization.
- `EC-207` mining exploration/safety.
- `EC-208` oil and gas reservoir/pipeline analytics.
- `EC-209` manufacturing quality/maintenance/supply chain.
- `EC-210` logistics routing/fleet/warehouse automation.
- `EC-211` retail forecasting/personalization/inventory.
- `EC-212` e-commerce recommendation/fraud/service.
- `EC-213` advertising targeting/bidding analytics.
- `EC-214` media content personalization/audience analysis.
- `EC-215` publishing writing/edit/fact-check provenance.
- `EC-216` social-media moderation/trend analysis.
- `EC-217` telecom optimization/fraud/churn.
- `EC-218` utility grid/load/outage analytics.
- `EC-219` transportation traffic/transit/logistics.
- `EC-220` smart city planning/safety/waste.
- `EC-221` space exploration autonomy/analysis.
- `EC-222` underwater exploration autonomy/mapping.
- `EC-223` polar exploration modeling/navigation.
- `EC-224` high-altitude research operations.
- `EC-225` deep-sea research operations.
- `EC-226` cave exploration mapping/navigation.
- `EC-227` jungle exploration biodiversity tracking.
- `EC-228` desert exploration water/site detection.
- `EC-229` mountain exploration risk modeling.
- `EC-230` volcanic research prediction/simulation.
- `EC-231` earthquake research modeling/risk.
- `EC-232` tsunami modeling/warning.
- `EC-233` flood modeling/risk.
- `EC-234` drought monitoring/impact.
- `EC-235` wildfire modeling/detection.
- `EC-236` landslide hazard/early-warning.
- `EC-237` coastal erosion/surge/SLR.
- `EC-238` marine biology analysis.
- `EC-239` freshwater biology analysis.
- `EC-240` terrestrial biodiversity analysis.
- `EC-241` conservation planning.
- `EC-242` evolutionary biology inference.
- `EC-243` paleontology analysis.
- `EC-244` biological anthropology analysis.
- `EC-245` digital archaeology analysis.
- `EC-246` digital history analysis.
- `EC-247` computational linguistics analysis.
- `EC-248` computational philosophy analysis.
- `EC-249` computational religion analysis.
- `EC-250` computational mythology analysis.

---
## 3) Promotion Gate (Normative)
- No catalog idea is promoted to release-critical scope until it defines:
  - explicit profile applicability (`core|enterprise|regulated`),
  - deterministic IO contract,
  - evidence artifact schema,
  - compatibility/migration statement,
  - security and policy implications.

---
## 4) Procedure
```text
1. Register new/updated catalog ideas with stable IDs.
2. Score each idea against profile value, risk, and dependency readiness.
3. Bind ready ideas to implementation backlog epics.
4. Emit prioritized queue and blocked-items report.
5. Emit catalog_hash for governance/audit linkage.
```

---
## 5) Checkpoint/Restore
- Checkpoint stores scored queue, blocked reasons, and dependency snapshot hash.
- Restore resumes prioritization and emits identical queue ordering for same inputs.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/External-Interface-Standard.md
==========================================================
# UML_OS External Interface Standard
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.API.ExternalInterfaceStandard_v1`
**Purpose (1 sentence):** Define generated external API artifacts, derivation rules, versioning, and conformance obligations.
**Spec Version:** `UML_OS.API.ExternalInterfaceStandard_v1` | 2026-02-21 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.API.ExternalInterfaceStandard_v1`
- **Purpose (1 sentence):** Deterministic external API interoperability contract.
- **Spec Version:** `UML_OS.API.ExternalInterfaceStandard_v1` | 2026-02-21 | Authors: Olejar Damir
- **Domain / Problem Class:** interface generation and third-party integration.
### 0.A Objective Semantics
- Generated interfaces are normative artifacts, not advisory exports.
### 0.B Reproducibility Contract
- Replayable given `(operator_registry_root_hash, interface_contract_hash, generator_version_hash)`.
### 0.C Numeric Policy
- N/A.
### 0.D Ordering and Tie-Break Policy
- Endpoint and message ordering derived deterministically from canonical operator registry order.
### 0.E Parallel, Concurrency, and Reduction Policy
- Generator steps may parallelize; emitted artifacts must be byte-identical.
### 0.F Environment and Dependency Policy
- Canonical profile: `CanonicalSerialization_v1`.
### 0.G Operator Manifest
- `UML_OS.Product.GenerateExternalInterfaces_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `interfaces/openapi/`, `interfaces/protobuf/`, `sdk/<lang>/`.
### 0.I Outputs and Metric Schema
- Outputs: `(openapi_bundle_hash, protobuf_bundle_hash, sdk_bundle_hash, interface_conformance_hash)`.
### 0.J Spec Lifecycle Governance
- Compatibility rules are MAJOR-governed.
### 0.K Failure and Error Semantics
- Mismatched canonicalization is deterministic failure.
### 0.L Input/Data Provenance
- Source-of-truth inputs: `docs/layer1-foundation/API-Interfaces.md`, `contracts/operator_registry.cbor`.

## 2) Derivation Rules (Normative)
- OpenAPI/Protobuf/SDK artifacts MUST be generated only from canonical operator registry + API interface contract.
- Manual edits to generated artifacts are non-conformant.
- Client round-trip conformance suite is mandatory:
  - generated client -> server stub -> canonical request/response bytes must match runtime canonicalization.

## 3) Compatibility Policy (Normative)
- `stable`: backward compatible within MAJOR.
- `lts`: long support window per lifecycle policy.
- `experimental`: no compatibility guarantee.
- See: `docs/layer4-implementation/API-Lifecycle-and-Deprecation-Policy.md`.

## 4) Conformance Identity (Normative)
- `interface_conformance_hash = SHA-256(CBOR_CANONICAL(["iface_conf_v1", test_vector_set_hash, runner_version_hash, openapi_bundle_hash, protobuf_bundle_hash, sdk_bundle_hash]))`.

## 6) Procedure
```text
1. Load canonical operator registry and API interface contract.
2. Generate OpenAPI, Protobuf, and SDK bundles deterministically.
3. Run round-trip client conformance suite.
4. Emit bundle hashes and interface_conformance_hash.
```

FILE: layer4-implementation/Fixtures-and-Golden-Data.md
=======================================================
# UML_OS Fixtures and Golden Data Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.FixturesGoldenData_v1`  
**Purpose (1 sentence):** Define deterministic fixture and golden-data lifecycle, storage, and update rules for tests and replay validation.  
**Spec Version:** `UML_OS.Test.FixturesGoldenData_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Test fixture governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.FixturesGoldenData_v1`
- **Purpose (1 sentence):** Deterministic fixture/golden governance.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: prevent fixture/golden drift.
### 0.B Reproducibility Contract
- Replayable given `(fixture_set_hash, golden_set_hash, vector_catalog_hash)`.
### 0.C Numeric Policy
- Golden comparisons follow declared E0/E1 profile.
### 0.D Ordering and Tie-Break Policy
- Fixture and golden records sorted by `(suite_id, case_id)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel generation allowed; final set hash deterministic.
### 0.F Environment and Dependency Policy
- Fixture generation must run under pinned deterministic profile.
### 0.G Operator Manifest
- `UML_OS.Test.LoadFixture_v1`
- `UML_OS.Test.ValidateGolden_v1`
- `UML_OS.Test.UpdateGolden_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `fixtures/`, `goldens/`, `vectors/` canonical roots.
### 0.I Outputs and Metric Schema
- Outputs: `(fixture_report, golden_report)`
- Metrics: `fixtures_total`, `goldens_total`, `mismatches`
### 0.J Spec Lifecycle Governance
- Golden update policy changes are MAJOR.
### 0.K Failure and Error Semantics
- Mismatches in required E0 fields fail deterministically.
### 0.L Input/Data Provenance
- Every golden must reference fixture and schema digest.

---
## 2) System Model
### I.A Persistent State
- Fixture and golden registries.
### I.B Inputs and Hyperparameters
- Fixture payloads, expected outputs, profile metadata.
### I.C Constraints and Feasible Set
- Valid iff fixture and golden digests are present and match catalog.
### I.D Transient Variables
- compare diagnostics and update proposals.
### I.E Invariants and Assertions
- Golden updates require explicit approval mode and traceability.

---
## 3) Initialization
1. Load fixture/golden catalogs.
2. Validate digest refs.
3. Initialize deterministic compare/update pipeline.

---
## 4) Operator Manifest
- `UML_OS.Test.LoadFixture_v1`
- `UML_OS.Test.ValidateGolden_v1`
- `UML_OS.Test.UpdateGolden_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.LoadFixture_v1`  
**Signature:** `(suite_id, case_id -> fixture_payload)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.Test.ValidateGolden_v1`  
**Signature:** `(actual_output, golden_output, profile -> validate_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Test.UpdateGolden_v1`  
**Signature:** `(proposal, approval_token -> update_report)`  
**Purity class:** IO  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. LoadFixture_v1
2. ValidateGolden_v1
3. If approved update path: UpdateGolden_v1
4. Emit reports
```

---
## 7) Trace & Metrics
### Logging rule
- Fixture/golden operations emit deterministic records.
### Trace schema
- `run_header`: fixture_set_hash, golden_set_hash
- `iter`: suite_id, case_id, status
- `run_end`: mismatch_count, update_status
### Metric schema
- `fixtures_total`, `goldens_total`, `mismatches`
### Comparability guarantee
- Comparable iff fixture/golden sets and profile match.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- No unresolved fixture/golden digest refs.
#### VII.B Operator test vectors (mandatory)
- Load/validate/update fixtures.
#### VII.C Golden traces (mandatory)
- Golden fixture governance traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for required-field golden validation.
#### VIII.B Allowed refactor categories
- Storage/index changes preserving fixture/golden identities.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of validation outputs on frozen fixtures.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Fixture/golden cursor and update state.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed validation/update must preserve deterministic outcomes.

FILE: layer4-implementation/Formal-Verification-Roadmap.md
==========================================================
# UML_OS Formal Verification Roadmap
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Verification.FormalRoadmap_v1`  
**Purpose (1 sentence):** Define mechanized proof targets for critical correctness and determinism properties.  
**Spec Version:** `UML_OS.Verification.FormalRoadmap_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) Priority Proof Targets
### I.A TMMU Slot Assignment Optimality
- Target: prove interval-graph coloring optimality for logical slot assignment.
- Scope: `TMMU.AssignLogicalSlots_v1` and related liveness assumptions.

### I.B Privacy Accountant Correctness
- Target: prove PLD/Moments accountant compositional correctness and numerical stability bounds.
- Scope: DP accountant operators and stable floating-point/approximation constraints.

### I.C IR Type/Shape Safety
- Target: mechanized typing/shape discipline proving absence of runtime shape mismatch for well-typed IR.
- Scope: UML_Model_IR typing rules and executor preconditions.

---
## 2) Proof Artifact Requirements
- Every proof package MUST include:
  - formal statement,
  - assumptions,
  - mechanized proof artifact reference,
  - executable extraction/test witness,
  - proof bundle hash.

---
## 3) Governance
- Proof regressions are release blockers for `regulated` profile when proof-marked contracts are modified.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Formal Verification Roadmap" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Gentle-Introduction.md
==================================================
# UML_OS Gentle Introduction
**Spec Version:** v1.0.0 | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**EQC Compliance:** Informational companion, non-authoritative for contract semantics.

**Purpose (1 sentence):** Provide a beginner-friendly conceptual path before deep contract details.

## 1) What UML_OS Is
- A deterministic execution contract for ML systems.
- Focuses on reproducibility, auditability, and controlled evolution.

## 2) Mental Model
- Manifest defines intent.
- Operators execute deterministically.
- Trace records what happened.
- Checkpoint captures recoverable state.
- Certificate proves execution claims.

## 3) First Learning Path
1. Read `Reference-Stack-Minimal.md`.
2. Run hello world example.
3. Inspect trace and certificate.
4. Learn replay determinism and gate policies.

## 4) What to Read Next
- `docs/layer2-specs/UML_OS-Kernel-v3.22-OS.md`
- `docs/layer2-specs/Execution-Certificate.md`
- `docs/layer3-tests/Conformance-Harness-Guide.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Gentle Introduction" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Hello-World-End-to-End-Example.md
=============================================================
# UML_OS Hello World End-to-End Example
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.ReferenceExample.HelloWorld_v1`  
**Purpose (1 sentence):** Provide a full, concrete worked example from manifest to final certificate for a tiny model.  
**Spec Version:** `UML_OS.ReferenceExample.HelloWorld_v1` | 2026-02-20 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Integrated tutorial-grade deterministic workflow.

---
## 1) Example Inputs (Normative)
- Manifest: minimal local profile with fixed `tenant_id`, `seed`, `datasets`, and `policy_bundle`.
- Model IR: single linear layer + MSE loss.
- Data: synthetic fixed-size fixture set.
- Steps: exactly 3 train steps.

## 2) Expected Workflow Outputs
- Canonical manifest hash.
- Deterministic per-step trace records.
- Checkpoint header hash and checkpoint hash.
- Execution certificate hash.
- Replay comparison verdict (`E0` pass).

## 3) Output Bundle Structure
- `hello_world/manifest.yaml`
- `hello_world/model_ir.json`
- `hello_world/trace_sidecar.cborlog`
- `hello_world/checkpoint_header.cbor`
- `hello_world/execution_certificate.cbor`
- `hello_world/replay_report.json`

## 4) Acceptance Criteria
- Byte-identical `trace_final_hash` across reruns.
- Byte-identical `certificate_hash` across reruns.
- Replay comparator returns no divergences.

## 5) Related Contracts
- `docs/layer4-implementation/Reference-Stack-Minimal.md`
- `docs/layer3-tests/Test-Plan.md`
- `docs/layer2-specs/Trace-Sidecar.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Hello World End-to-End Example" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Implementation-Backlog.md
=====================================================
# UML_OS Implementation Backlog Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.Backlog_v1`  
**Purpose (1 sentence):** Define deterministic implementation task inventory and status semantics for operator-level delivery tracking.  
**Spec Version:** `UML_OS.Implementation.Backlog_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Engineering execution planning.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.Backlog_v1`
- **Purpose (1 sentence):** Deterministic implementation backlog governance.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: minimize ambiguous implementation status.
### 0.B Reproducibility Contract
- Replayable given `(backlog_hash, operator_registry_root_hash, roadmap_hash)`.
### 0.C Numeric Policy
- Priority/severity fields use exact integer domains.
### 0.D Ordering and Tie-Break Policy
- Tasks sorted by `(priority, subsystem, operator_id)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel work allowed; status merge is deterministic.
### 0.F Environment and Dependency Policy
- Backlog status changes require linked artifact hashes (PR/test/report).
### 0.G Operator Manifest
- `UML_OS.ImplBacklog.CreateTask_v1`
- `UML_OS.ImplBacklog.UpdateStatus_v1`
- `UML_OS.ImplBacklog.ValidateCoverage_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.ImplBacklog.*`
### 0.I Outputs and Metric Schema
- Outputs: `(backlog_report, coverage_report)`
- Metrics: `tasks_total`, `tasks_done`, `coverage_pct`
### 0.J Spec Lifecycle Governance
- State machine changes are MAJOR.
### 0.K Failure and Error Semantics
- Invalid transitions fail deterministically.
### 0.L Input/Data Provenance
- Tasks must reference operator ids and contract versions.

---
## 2) System Model
### I.A Persistent State
- Backlog task table and transition log.
### I.B Inputs and Hyperparameters
- task specs, owners, dependencies, evidence refs.
### I.C Constraints and Feasible Set
- Valid iff every required operator has an implementation task.
### I.D Transient Variables
- update diffs and validation diagnostics.
### I.E Invariants and Assertions
- Task IDs unique; transitions append-only.
- Productization invariants:
  - every release train contains profile packaging tasks (`core`, `enterprise`, `regulated`), where `managed` is used only as execution mode mapping for `enterprise`,
  - observability bridge tasks produce deterministic mapping artifacts,
  - certification tasks emit externally-verifiable evidence bundles,
  - reference-stack tasks cover WAL -> trace -> checkpoint -> certificate -> replay end-to-end flow.

### II.F Mandatory Productization Epics (Normative)
| epic_id | required_tasks | done_criteria |
|---|---|---|
| `EPIC_profiles` | define/validate `core`, `enterprise`, `regulated` profile bundles | profile bundle hashes published and promotion policy validated; execution-mode mapping note preserved (`enterprise -> managed` unless stricter mode selected) |
| `EPIC_observability_bridge` | map UML_OS trace/metrics to OTel + Prometheus semantics | mapping hash published; exporter determinism tests pass |
| `EPIC_adapter_certification` | backend/store certification evidence generation | certification bundle hash + signed verification report published |
| `EPIC_reference_stack` | runnable local end-to-end reference stack + golden demo | demo evidence hashes match across environments |
| `EPIC_external_api` | OpenAPI/Protobuf generation + SDK generation (py/go/ts) | generated client conformance passes |
| `EPIC_security_case` | threat model + control mapping + mode proof obligations | auditor-ready security case report approved |
| `EPIC_evolution_economics` | bounded deprecation windows + migration operator coverage | compatibility policy checks pass |
| `EPIC_performance_contract` | tier baselines and regression evidence | baseline hashes + regression verdicts published |
| `EPIC_chaos_recovery` | mandatory chaos scenarios + proof packs | regulated recovery proof pack checks pass |
| `EPIC_onboarding_examples` | runnable minimal stack + hello-world workflow + beginner docs | new contributor can produce deterministic trace/cert in first run |
| `EPIC_third_party_certification` | third-party operator certification process + package format | publishable certified module packages validated |
| `EPIC_brownfield_adoption` | phased migration patterns and anti-pattern guidance | incremental adoption path validated on legacy integration fixture |
| `EPIC_tooling_suite` | manifest generator, IR explorer, migration assistant, replay monitor, semantic trace diff | tooling conformance and deterministic output checks pass |
| `EPIC_formal_verification` | mechanized proof artifacts for TMMU optimality, DP accounting, IR type safety | proof package hashes published and verification checks pass |
| `EPIC_interop_bridge` | ONNX bridge, OTLP exporter profile, Prometheus metric contract, K8s operator CRDs | interoperability conformance vectors pass |
| `EPIC_governance_model` | RFC workflow, TSC charter, backport/version policy, contribution ladder | governance artifacts approved and linked from release notes |
| `EPIC_disaster_ops` | full cluster failure + data corruption runbooks + postmortem template adoption | drill evidence bundles validated in release gates |
| `EPIC_research_extensions` | federated/VDF/zk extension design docs with adoption criteria | extension proposals include deterministic migration/conformance plan |
| `EPIC_ecosystem_connectors` | first-class external data/model/feature-store connectors with deterministic wrappers | connector conformance + lineage integrity checks pass |
| `EPIC_streaming_runtime` | streaming NextBatch variant + stateful stream snapshots + watermark policy | streaming determinism and exactly-once suites pass |
| `EPIC_model_lifecycle_automation` | retraining triggers, rollout automation, performance decay rollback, model family lineage | lifecycle automation gates pass by profile |
| `EPIC_compliance_automation` | residency controls + framework crosswalk reports + TEE chain unification | auditor-export evidence bundle pass |
| `EPIC_devex_plus` | debugger/jupyter/snippets/language-server | deterministic UX output contracts validated |
| `EPIC_policy_as_code` | data-usage and regulation-as-code bundles | policy versioning and reproducibility checks pass |
| `EPIC_economic_models` | marketplace/billing/licensing evidence contracts | accounting/reconciliation tests pass |
| `EPIC_sustainability` | carbon-aware scheduling + energy accounting + green guide | sustainability metrics integrated into release evidence |
| `EPIC_archival_notarization` | define canonical `.umlospack` layout; generate archive hash manifest; bind RFC3161/TSA or equivalent notarization proof; schedule deterministic bit-rot revalidation workflow and restore drills | archive bundle hash + notarization proof hash + restore-verdict hash published; release gate requires successful replay from archived package and no unresolved bit-rot alerts |
| `EPIC_multitenancy_scale` | hierarchical tenancy + fairness/quota + immutable tenant audit logs | tenant isolation/fairness tests pass |
| `EPIC_obs_plus` | distributed traces + structured logs + real-time dashboards | telemetry correlation conformance passes |
| `EPIC_cross_version_lts` | long-window compatibility corpora + deprecation enforcement | cross-version regression suites pass |
| `EPIC_iam_federation` | SAML/OIDC/LDAP + federated roles + JIT break-glass lifecycle | IAM auditability gates pass |
| `EPIC_multicloud` | unified storage semantics and cloud-agnostic manifests | cross-cloud reproducibility tests pass |
| `EPIC_collaboration` | model branching/merging and deterministic collaborative edits | merge/conflict determinism tests pass |
| `EPIC_online_learning` | incremental update operators + freshness attestations | online-learning replay/gate tests pass |
| `EPIC_hsm_enforcement` | HSM signing + key usage attestation + rotation policies | cryptographic governance checks pass |
| `EPIC_regulatory_sandbox` | sandbox profile, regulator bundles, signed regulator exports | sandbox-to-production transition checks pass |
| `EPIC_expansion_catalog_041_250` | intake, scoring, and staged promotion of catalog items EC-041..EC-250 | catalog hash published; promoted subset fully contract-bound |

---
## 3) Initialization
1. Load operator registry.
2. Load roadmap and backlog store.
3. Compute required coverage set.

---
## 4) Operator Manifest
- `UML_OS.ImplBacklog.CreateTask_v1`
- `UML_OS.ImplBacklog.UpdateStatus_v1`
- `UML_OS.ImplBacklog.ValidateCoverage_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.ImplBacklog.CreateTask_v1`  
**Signature:** `(task_spec -> task_id)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.ImplBacklog.UpdateStatus_v1`  
**Signature:** `(task_id, from_state, to_state, evidence_refs -> transition_record)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.ImplBacklog.ValidateCoverage_v1`  
**Signature:** `(backlog, required_operator_set -> coverage_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. CreateTask_v1 for uncovered required operators
2. UpdateStatus_v1 as implementation progresses
3. ValidateCoverage_v1 before release gates
4. Validate mandatory productization epics before release gates
5. Emit backlog_report + coverage_report
```

---
## 7) Trace & Metrics
### Logging rule
- Backlog updates emit deterministic task transition events.
### Trace schema
- `run_header`: backlog_version, registry_hash
- `iter`: task_id, transition, status
- `run_end`: coverage_report_hash
### Metric schema
- `tasks_total`, `tasks_done`, `coverage_pct`
### Comparability guarantee
- Comparable iff same required operator set and backlog schema.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- No orphan operator tasks; no illegal state transitions.
#### VII.B Operator test vectors (mandatory)
- Transition/state and coverage tests.
#### VII.C Golden traces (mandatory)
- Golden backlog evolution traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for coverage verdict and transition log.
#### VIII.B Allowed refactor categories
- Storage/index changes preserving task semantics.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of coverage reports.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Task state snapshot and transition cursor.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed backlog processing must preserve transition order and coverage results.

FILE: layer4-implementation/Implementation-Roadmap.md
=====================================================
# UML_OS Implementation Roadmap
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.RoadmapPlanner_v1`  
**Purpose (1 sentence):** Define deterministic implementation phases, dependency order, and delivery gates for the final UML_OS product.  
**Spec Version:** `UML_OS.Implementation.RoadmapPlanner_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Program planning and delivery governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.RoadmapPlanner_v1`
- **Purpose (1 sentence):** Deterministic implementation sequencing.
- **Spec Version:** `UML_OS.Implementation.RoadmapPlanner_v1` | 2026-02-18 | Authors: Olejar Damir
- **Domain / Problem Class:** Engineering roadmap orchestration.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Objective: minimize delivery risk and integration rework.
- Comparison: fewer blocked milestones is better; ties by earlier completion date.
### 0.B Reproducibility Contract
- Replayable given `(roadmap_version, dependency_graph_hash, team_capacity_profile)`.
### 0.C Numeric Policy
- Milestone scoring in binary64.
- Deterministic integer ordering for phase indices.
### 0.D Ordering and Tie-Break Policy
- Phase order strict by dependency DAG then phase_id.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel work allowed only on dependency-independent tasks.
### 0.F Environment and Dependency Policy
- Determinism level: `BITWISE` for phase ordering and gate results.
### 0.G Operator Manifest
- `UML_OS.Implementation.ResolveDependencies_v1`
- `UML_OS.Implementation.AssignMilestones_v1`
- `UML_OS.Implementation.EvaluateGates_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Fully-qualified operator names required.
### 0.I Outputs and Metric Schema
- Outputs: `(phase_plan, gate_report)`.
- Metrics: `blocked_tasks`, `critical_path_days`, `phase_completion_ratio`.
- Completion status: `success | failed`.
### 0.J Spec Lifecycle Governance
- Phase semantics changes require MINOR/MAJOR bump based on compatibility.
### 0.K Failure and Error Semantics
- Abort-only on dependency cycles or invalid gates.
### 0.L Input/Data Provenance
- Inputs: dependency graph and capacity assumptions are versioned and hashed.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.


## 2) System Model
### I.A Persistent State
- `roadmap_state` with phase statuses and gate outcomes.
### I.B Inputs and Hyperparameters
- dependency graph, capacity, release constraints.
### I.C Constraints and Feasible Set
- Unconstrained planning; validity set by dependency acyclicity.
### I.D Transient Variables
- critical path, current frontier, gate diagnostics.
### I.E Invariants and Assertions
- no phase starts before dependencies are complete.

### II.F Phase DAG and Milestones (Concrete)
| phase_id | depends_on | deliverables | gate_criteria |
|---|---|---|---|
| `P1_core_specs` | - | kernel/data/model/tmmu/dp specs finalized | all core docs EQC-lint pass |
| `P2_registries` | `P1_core_specs` | trace/error/config/checkpoint registries concrete + canonical operator registry artifact | schema/hash consistency checks pass |
| `P3_codegen_runtime` | `P2_registries` | adapters, mapping, interface stubs | backend conformance suite pass |
| `P4_validation` | `P3_codegen_runtime` | golden traces + replay harness | E0/E1 equivalence suite pass |
| `P5_release` | `P4_validation` | deployment runbook + signed artifacts | deployment canary gates pass |
| `P6_profile_packaging` | `P5_release` | Core/Enterprise/Regulated profile bundles (`managed` remains execution_mode mapping for enterprise) | profile promotion checks pass |
| `P7_observability_bridge` | `P5_release` | OpenTelemetry/Prometheus deterministic mapping bundle | mapping conformance + exporter determinism pass |
| `P8_adapter_certification_program` | `P5_release` | external backend/store certification evidence bundles | vendor-verifiable certification bundle checks pass |
| `P9_reference_stack` | `P5_release` | runnable end-to-end local reference stack (WAL->trace->checkpoint->certificate->replay) | golden demo reproducibility pass |
| `P10_external_interfaces` | `P3_codegen_runtime` | generated OpenAPI/Protobuf + Python/Go/TypeScript SDKs | generated SDK conformance tests pass |
| `P11_security_case` | `P5_release` | control-mapped auditor-ready threat/security case | managed/confidential/regulated proof checks pass |
| `P12_evolution_contract` | `P2_registries` | deprecation windows + mandatory migration economics policy | compatibility and migration gate pass |
| `P13_performance_tiers` | `P4_validation` | official CPU/single-GPU/multi-GPU benchmark baselines | baseline hash + regression verdict pass |
| `P14_chaos_proof_packs` | `P5_release` | mandatory chaos/recovery proof packs | regulated recovery evidence gates pass |

Deterministic gate evaluation:
- Gates evaluate a fixed ordered checklist with boolean outcomes.
- Final gate verdict is lexical reduction over checklist items (`fail` dominates `pass`), independent of runtime execution ordering.
- Mandatory pre-gate: `tools/spec_lint.py` pass for every phase boundary after `P2_registries`.

### II.G Compatibility Contract (Normative)
- Deprecation lifecycle: announce -> warning phase -> removal.
- Minimum supported versions window must be declared for config/trace/checkpoint schemas.
- Breaking change protocol:
  - requires MAJOR version bump,
  - requires migration operator,
  - requires golden migration tests with E0/E1 invariants.
- Standard migration operators:
  - `UML_OS.Config.ManifestMigrate_v1`
  - `UML_OS.Checkpoint.CheckpointMigrate_v1`
  - `UML_OS.Trace.TraceMigrate_v1`
- Operational merge workflow reference:
  - `docs/layer4-implementation/Change-Control-Playbook.md`
- Productization reference:
  - `docs/layer4-implementation/Industry-Productization-Upgrade-Plan.md`
  - `docs/layer4-implementation/Reference-Stack-Minimal.md`
  - `docs/layer4-implementation/Third-Party-Operator-Certification-Program.md`
  - `docs/layer4-implementation/API-Lifecycle-and-Deprecation-Policy.md`
  - `docs/layer4-implementation/Brownfield-Deployment-Guide.md`
  - `docs/layer4-implementation/Tooling-and-Automation-Suite.md`
  - `docs/layer4-implementation/Formal-Verification-Roadmap.md`
  - `docs/layer4-implementation/Interoperability-Standards-Bridge.md`
  - `docs/layer4-implementation/Community-Governance-Model.md`
  - `docs/layer4-implementation/Disaster-Recovery-Operations-Runbook.md`
  - `docs/layer4-implementation/Research-Extensions-Roadmap.md`
  - `docs/layer4-implementation/Ecosystem-Expansion-Roadmap.md`
  - `docs/layer4-implementation/Expansion-Catalog-041-250.md`

---
## 3) Initialization
1. Load dependency graph.
2. Validate graph acyclicity.
3. Initialize phase queue.

---
## 4) Operator Manifest
- `UML_OS.Implementation.ResolveDependencies_v1`
- `UML_OS.Implementation.AssignMilestones_v1`
- `UML_OS.Implementation.EvaluateGates_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions

External operator reference: `UML_OS.Error.Emit_v1` is defined normatively in `docs/layer1-foundation/Error-Codes.md` and imported by reference.

Template conformance note (III.A): each operator definition in this section is interpreted with the full EQC operator template fields. When a field is not repeated inline, the section-level defaults are: explicit typed signatures, deterministic ordering/tie handling, declared numerical policy inheritance, deterministic failure semantics (0.K), explicit dependencies, and VII.B test-vector coverage.

**Operator:** `UML_OS.Implementation.ResolveDependencies_v1`  
**Category:** IO  
**Signature:** `(graph -> ordered_phases)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** topological ordering of roadmap phases.  
**Preconditions / Postconditions:** acyclic graph required.  
**Edge cases:** disconnected phase clusters.  
**Numerical considerations:** N/A.  
**Ordering/tie handling:** lexical phase_id tie-break.  
**Complexity note:** O(V+E).  
**Failure behavior:** cycle => deterministic abort.  
**Dependencies:** graph parser.  
**Test vectors:** known DAG/cycle fixtures.

**Operator:** `UML_OS.Implementation.AssignMilestones_v1`  
**Category:** IO  
**Signature:** `(ordered_phases, capacity -> phase_plan)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** allocates tasks to milestones under capacity constraints.

**Operator:** `UML_OS.Implementation.EvaluateGates_v1`  
**Category:** IO  
**Signature:** `(phase_outputs -> gate_report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** computes pass/fail for each milestone gate.

---
## 6) Procedure
```text
1. ResolveDependencies_v1
2. AssignMilestones_v1
3. EvaluateGates_v1
4. Emit phase_plan + gate_report
```

---
## 7) Trace & Metrics
### Logging rule
Each phase transition and gate verdict is logged deterministically.
### Trace schema
- `run_header`: roadmap_version, graph_hash
- `iter`: phase_id, status, gate_status
- `run_end`: completion_summary
### Metric schema
- `blocked_tasks`, `critical_path_days`, `phase_completion_ratio`
### Comparability guarantee
Comparable iff roadmap graph, capacity model, and gate definitions match.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
Passes ordering, completeness, deterministic gate semantics.
#### VII.B Operator test vectors (mandatory)
Includes DAG order, milestone assignment, gate verdict vectors.
#### VII.C Golden traces (mandatory)
Golden roadmap transitions for baseline project plans.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for identical phase ordering and gate outputs.
#### VIII.B Allowed refactor categories
- Planner implementation refactor preserving plan outputs.
#### VIII.C Equivalence test procedure (mandatory)
Exact comparison of plan and gate report.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- phase statuses and unresolved dependency frontier.
### Serialization
- deterministic canonical CBOR.
### Restore semantics
- resumed planning yields identical final plan.

FILE: layer4-implementation/Incident-Postmortem-Template.md
===========================================================
# UML_OS Incident Post-Mortem Template
**Spec Version:** v1.0.0 | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


## 1) Incident Metadata
- incident_id:
- start_time_utc:
- end_time_utc:
- affected_profile:
- severity:

## 2) Deterministic Evidence Links
- trace_final_hash:
- checkpoint_hash:
- certificate_hash:
- wal_terminal_hash:
- policy_gate_hash:

## 3) Root Cause Summary
- primary_failure_operator:
- first_divergence_step:
- failure_code:
- distributed_failure_fingerprint_hash (if applicable):

## 4) Timeline
- event_1:
- event_2:
- event_3:

## 5) Remediation
- immediate_actions:
- long_term_actions:
- contract_sections_to_update:

## 6) Verification
- replay_verdict_after_fix:
- release_gate_verdict_after_fix:

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Incident Post-Mortem Template" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Industry-Productization-Upgrade-Plan.md
===================================================================
# UML_OS Industry Productization Upgrade Plan
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.IndustryProductizationPlan_v1`  
**Purpose (1 sentence):** Define normative, externally-verifiable productization requirements that reduce adoption friction and improve ecosystem interoperability for UML_OS.  
**Spec Version:** `UML_OS.Implementation.IndustryProductizationPlan_v1` | 2026-02-20 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Product profile governance, ecosystem integration, and third-party trust.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.IndustryProductizationPlan_v1`
- **Purpose (1 sentence):** Deterministic productization and certification governance.
### 0.A Objective Semantics
- Minimize adoption time while preserving deterministic guarantees and auditable evidence.
### 0.B Reproducibility Contract
- Replayable given `(product_profile_id, profile_bundle_hash, certification_policy_hash, observability_mapping_hash)`.
### 0.C Numeric Policy
- Governance thresholds use binary64.
### 0.D Ordering and Tie-Break Policy
- Upgrade steps are executed in declared section order (1..9), ties broken by lexical `workstream_id`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Workstreams may execute in parallel only when cross-workstream dependencies are absent; aggregate readiness verdict is deterministic fail-dominant reduction.
### 0.F Environment and Dependency Policy
- All generated evidence must bind `env_manifest_hash` and `determinism_profile_hash`.
### 0.G Operator Manifest
- `UML_OS.Product.ResolveProfile_v1`
- `UML_OS.Product.EmitObservabilityMapping_v1`
- `UML_OS.Product.BuildCertificationBundle_v1`
- `UML_OS.Product.ValidateReferenceStack_v1`
- `UML_OS.Product.GenerateExternalInterfaces_v1`
- `UML_OS.Product.EmitSecurityCase_v1`
- `UML_OS.Product.ValidateEvolutionPolicy_v1`
- `UML_OS.Product.EvaluatePerformanceTier_v1`
- `UML_OS.Product.RunChaosProofPack_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Use `UML_OS.Product.*` for all operators in this contract.
### 0.I Outputs and Metric Schema
- Outputs: `(productization_report, profile_bundle_hash, certification_evidence_bundle_hash, upgrade_gate_verdict)`.
- Metrics: `adoption_days_estimate`, `interop_pass_rate`, `third_party_verifiability_score`.
### 0.J Spec Lifecycle Governance
- Profile definitions and certification requirements are MAJOR-governed.
### 0.K Failure and Error Semantics
- Missing mandatory artifacts/evidence is a deterministic failure.
### 0.L Input/Data Provenance
- Inputs are sourced from layer2/layer3/layer4 contracts and must be content-addressed.

---
## 2) Normative Upgrade Workstreams
### I.A Product Profiles (Core/Enterprise/Regulated)
- Define three normative profiles:
  - `core`: single-node, single backend adapter, single artifact store adapter, default deterministic trace/redaction policy.
  - `enterprise`: multi-node operational profile with deployment/runbook and policy gate integration.
  - `regulated`: enterprise profile + attestation, revocation, and control-mapped evidence requirements.
- Runtime-mode mapping note:
  - product profile `enterprise` maps to execution mode `managed` unless a stricter mode is selected.
  - `managed` is an execution mode; `enterprise` is the product profile.
- Graduation policy:
  - `core -> enterprise`: requires conformance pipeline pass and deployment gate pass.
  - `enterprise -> regulated`: requires full security case and regulator-grade evidence bundle.

### I.B Observability Interoperability Bridge
- Emit normative mapping from UML_OS trace/metrics schema to OpenTelemetry + Prometheus semantics:
  - trace fields to span/resource attributes,
  - metric names/units to canonical Prometheus names,
  - deterministic exporter mapping hashes.
- Mapping output identity:
  - `observability_mapping_hash = SHA-256(CBOR_CANONICAL(mapping_bundle))`.

### I.C Adapter Certification Program
- Require externally publishable certification classes:
  - `UML_OS Certified Backend vX`
  - `UML_OS Certified Artifact Store vY`
- Certification evidence bundle MUST contain:
  - test vectors catalog hash,
  - conformance harness suite reports,
  - reproducibility verdicts,
  - adapter binary/runtime fingerprints,
  - signed certificate and verification report hashes.

### I.D Runnable Reference Stack
- Provide minimal end-to-end runnable reference stack (local mode) that exercises:
  - WAL -> trace -> checkpoint -> execution certificate -> replay.
- Provide deterministic golden demo pipeline with fixed fixtures and locked environment.

### I.E External Interface Standardization
- Generate normative OpenAPI + Protobuf from operator registry and interface contracts.
- Generate SDKs at minimum for Python/Go/TypeScript.
- Generated client conformance tests MUST verify canonicalization and replay-safe behavior.

### I.F Auditor-Ready Security Case
- Expand threat model into control-mapped security case with:
  - assets, trust boundaries, attacker capabilities,
  - required mitigations,
  - evidence locations (trace/certificate/policy transcripts),
  - mode-specific proof requirements for managed/confidential/regulated.

### I.G Evolution and Deprecation Economics
- Add time-bounded deprecation windows (`N` releases, policy-defined).
- Breaking changes MUST include migration operators and migration evidence.
- Publish customer-facing compatibility guarantees by profile.

### I.H Performance as Contract
- Publish official benchmark tiers:
  - `cpu_tier`, `single_gpu_tier`, `multi_gpu_tier`.
- Release evidence for each tier MUST include:
  - `env_manifest_hash`,
  - workload IDs,
  - baseline hash,
  - deterministic regression verdict.

### I.I Chaos + Recovery Proof Packs
- Define mandatory chaos scenarios:
  - network partition,
  - partial artifact store failure,
  - WAL corruption variants.
- Emit standardized recovery proof packs for regulated environments:
  - scenario id,
  - expected invariant checks,
  - recovery transcript hash,
  - final recovery verdict hash.

---
## 3) Procedure
```text
1. Resolve target product profile (core/enterprise/regulated).
2. Build observability mapping bundle and hash.
3. Build adapter certification evidence bundle and hash.
4. Validate runnable reference stack and golden demo determinism.
5. Generate OpenAPI/Protobuf + SDK artifacts and run conformance checks.
6. Emit control-mapped security case report.
7. Validate deprecation/evolution policy bindings.
8. Evaluate performance baselines for required platform tiers.
9. Run mandatory chaos scenarios and build recovery proof pack.
10. Aggregate deterministic upgrade verdict and emit productization report.
```

---
## 4) Validation
- Required cross-contract references:
  - `docs/layer2-specs/Security-Compliance-Profile.md`
  - `docs/layer2-specs/Trace-Sidecar.md`
  - `docs/layer2-specs/Execution-Certificate.md`
  - `docs/layer2-specs/Run-Commit-WAL.md`
  - `docs/layer3-tests/Conformance-Harness-Guide.md`
  - `docs/layer3-tests/Performance-Plan.md`
  - `docs/layer3-tests/Failure-Injection-Scenarios.md`
  - `docs/layer4-implementation/Backend-Adapter-Guide.md`
  - `docs/layer4-implementation/Artifact-Store-Adapter-Guide.md`
  - `docs/layer4-implementation/Release-Evidence-Assembler.md`
  - `docs/START-HERE.md`
  - `docs/layer4-implementation/Tooling-Suite.md`

---
## 5) Checkpoint/Restore
- Checkpoint stores:
  - completed workstream ids,
  - partial certification bundle hash,
  - partial observability mapping hash,
  - partial chaos proof pack hash.
- Restore semantics:
  - resumed execution must reproduce identical final upgrade verdict and evidence hashes.

---
## 6) Extended Ecosystem Tracks (Normative Reference)
- This plan is extended by:
  - `docs/layer4-implementation/Ecosystem-Expansion-Roadmap.md`
  - `docs/layer4-implementation/Expansion-Catalog-041-250.md`
- The extension is normative for long-horizon 10/10 competitiveness items (ecosystem integration, streaming, economics, IAM, multi-cloud, sustainability, long-term archival, and advanced extensibility).

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

- Additional 10/10 references:
  - `docs/layer4-implementation/External-Interface-Standard.md`
  - `docs/layer4-implementation/Evidence-Catalog.md`
  - `docs/layer4-implementation/Security-Case-Template.md`
  - `docs/layer3-tests/Failure-Injection-Index.md`
  - `docs/layer4-implementation/Benchmark-Evidence-Spec.md`
  - `docs/layer4-implementation/Determinism-Audit-Playbook.md`

FILE: layer4-implementation/Interoperability-Standards-Bridge.md
================================================================
# UML_OS Interoperability Standards Bridge
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Interop.StandardsBridge_v1`  
**Purpose (1 sentence):** Define normative mappings between UML_OS artifacts and major industry standards for runtime integration.  
**Spec Version:** `UML_OS.Interop.StandardsBridge_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) ONNX Interop
- Define canonical mapping UML_Model_IR -> ONNX graph.
- Define constrained importer ONNX -> UML_Model_IR with deterministic normalization.
- Require round-trip conformance vectors for supported op subset.

## 2) OpenTelemetry Native Export
- Provide OTLP exporter profile for UML_OS trace records.
- Semantic conventions MUST include stable attrs:
  - `umlos.operator_id`, `umlos.step`, `umlos.run_id`, `umlos.trace_final_hash`.

## 3) Prometheus/OpenMetrics Integration
- Standard runtime metric set:
  - `umlos_loss_total`
  - `umlos_gradient_norm`
  - `umlos_tmmu_peak_bytes`
  - `umlos_replay_divergence_total`
- Deterministic `/metrics` projection required for identical run windows.

## 4) Kubernetes Operator Surface
- Publish CRDs at minimum for:
  - `UmlosRun`
  - `UmlosModel`
  - `UmlosDataset`
- Controller behavior must preserve deterministic evidence semantics and profile gates.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Interoperability Standards Bridge" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

## 5) External Interface Contract Reference (Normative)
- `docs/layer4-implementation/External-Interface-Standard.md` is the authoritative generated-interface contract.
- This bridge document is compatible with and constrained by that contract.

FILE: layer4-implementation/Local-Replay-Runbook.md
===================================================
# UML_OS Local Replay Runbook
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.LocalReplayRunbook_v1`  
**Purpose (1 sentence):** Define deterministic local replay execution steps for developers to reproduce and diagnose run divergence.  
**Spec Version:** `UML_OS.Implementation.LocalReplayRunbook_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Developer replay operations.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.LocalReplayRunbook_v1`
- **Purpose (1 sentence):** Deterministic local replay workflow.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: minimize replay divergence count.
### 0.B Reproducibility Contract
- replay requires identical `manifest_hash`, `replay_token`, `determinism_profile_hash`.
### 0.C Numeric Policy
- binary64 for replay checks and comparator metrics.
### 0.D Ordering and Tie-Break Policy
- process trace records in canonical `(t, rank, operator_seq)` order.
### 0.E Parallel, Concurrency, and Reduction Policy
- local replay runs single-process unless distributed replay profile is explicitly enabled.
### 0.F Environment and Dependency Policy
- lockfile-pinned local runtime required.
### 0.G Operator Manifest
- `UML_OS.Replay.LoadArtifacts_v1`
- `UML_OS.Replay.RunDeterministicReplay_v1`
- `UML_OS.Replay.CompareOutputs_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- all operators under `UML_OS.Replay.*`.
### 0.I Outputs and Metric Schema
- outputs: `(replay_report, divergence_report)`.
### 0.J Spec Lifecycle Governance
- comparator key changes are MAJOR.
### 0.K Failure and Error Semantics
- failures emit deterministic replay error record.
### 0.L Input/Data Provenance
- replay inputs are content-addressed artifacts from checkpoint/trace/certificate.

---
## 2) System Model
### I.A Persistent State
- replay cursor, divergence accumulator, diagnostics context.
### I.B Inputs and Hyperparameters
- run id, artifact paths, replay mode (`STRICT_E0` / `TOLERANT_E1`).
### I.C Constraints and Feasible Set
- artifacts must share same `replay_token`.
### I.D Transient Variables
- per-step comparison deltas.
### I.E Invariants and Assertions
- monotonic replay step progression.

---
## 3) Initialization
1. Load manifest/checkpoint/trace/certificate references.
2. Validate hash/link consistency.
3. Initialize replay comparator state.

---
## 4) Operator Manifest
- `UML_OS.Replay.LoadArtifacts_v1`
- `UML_OS.Replay.RunDeterministicReplay_v1`
- `UML_OS.Replay.CompareOutputs_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Replay.LoadArtifacts_v1`  
**Signature:** `(artifact_refs -> replay_inputs)`  
**Purity class:** IO  
**Definition:** Loads and validates artifact hash links required for replay.

**Operator:** `UML_OS.Replay.RunDeterministicReplay_v1`
**Signature:** `(replay_inputs -> observed_outputs, replay_report)`
**Purity class:** IO
**Definition:** Replays run steps deterministically under the active replay mode and emits canonical replay report.

**Operator:** `UML_OS.Replay.CompareOutputs_v1`  
**Signature:** `(expected, observed, replay_mode -> diff)`  
**Purity class:** PURE  
**Definition:** Applies E0/E1 comparator rules and emits deterministic diff.

---
## 6) Procedure
```text
1. replay_inputs <- LoadArtifacts_v1(...)
2. observed <- RunDeterministicReplay_v1(replay_inputs)
3. diff <- CompareOutputs_v1(expected, observed, replay_mode)
4. if diff.has_divergence: Error.Emit_v1(REPLAY_DIVERGENCE)
5. return (replay_report, divergence_report)
```

---
## 7) Trace & Metrics
- Metrics: `divergence_count`, `first_divergence_t`, `max_abs_error`, `max_rel_error`.
- Trace includes replay mode and comparator profile hash.

---
## 8) Validation
- Golden replays for one E0 and one E1 profile.
- Fault-injected replay for deterministic divergence detection.

---
## 9) Refactor & Equivalence
- E0 for replay verdict and first divergence location.
- E1 allowed only for declared tolerant metrics.

---
## 10) Checkpoint/Restore
- Replay session checkpoint stores replay cursor and diff accumulator.
- Restore must resume with identical comparator output.

FILE: layer4-implementation/Migration-Execution-Guide.md
========================================================
# UML_OS Migration Execution Guide Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.MigrationExecutionGuide_v1`  
**Purpose (1 sentence):** Define deterministic operational procedures for executing and validating manifest/trace/checkpoint migrations.  
**Spec Version:** `UML_OS.Implementation.MigrationExecutionGuide_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Schema and artifact migration operations.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.MigrationExecutionGuide_v1`
- **Purpose (1 sentence):** Deterministic migration execution contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: prevent non-verifiable migration outcomes.
### 0.B Reproducibility Contract
- Replayable given `(source_hash, target_hash, migration_operator_id, migration_policy_hash)`.
### 0.C Numeric Policy
- Version and sequence checks use exact deterministic comparisons.
### 0.D Ordering and Tie-Break Policy
- Migration phases execute in fixed order.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel migrations allowed only for independent objects with deterministic merge order.
### 0.F Environment and Dependency Policy
- Migration tools must run under pinned lockfile/toolchain.
### 0.G Operator Manifest
- `UML_OS.Migrate.Manifest_v1`
- `UML_OS.Migrate.Checkpoint_v1`
- `UML_OS.Migrate.Trace_v1`
- `UML_OS.Migrate.ValidateOutcome_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Migrate.*`
### 0.I Outputs and Metric Schema
- Outputs: `(migration_report, migration_certificate_hash)`
- Metrics: `objects_migrated`, `objects_failed`
### 0.J Spec Lifecycle Governance
- Required migration invariants changes are MAJOR.
### 0.K Failure and Error Semantics
- Any invariant breach is deterministic abort.
### 0.L Input/Data Provenance
- Source and target objects must be content-addressed and trace-linked.

---
## 2) System Model
### I.A Persistent State
- Migration registry and migration certificates.
### I.B Inputs and Hyperparameters
- source objects, target schema versions, migration operators.
### I.C Constraints and Feasible Set
- Valid iff migration path is supported and invariants hold.
### I.D Transient Variables
- transform diagnostics and diff maps.
### I.E Invariants and Assertions
- Migration must be deterministic and hash-consistent across implementations.

---
## 3) Initialization
1. Resolve migration path.
2. Validate source artifacts and compatibility.
3. Initialize migration execution context.

---
## 4) Operator Manifest
- `UML_OS.Migrate.Manifest_v1`
- `UML_OS.Migrate.Checkpoint_v1`
- `UML_OS.Migrate.Trace_v1`
- `UML_OS.Migrate.ValidateOutcome_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Migrate.Manifest_v1`  
**Signature:** `(source_manifest, target_version -> target_manifest)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Migrate.Checkpoint_v1`  
**Signature:** `(source_checkpoint, target_version -> target_checkpoint)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.Migrate.Trace_v1`  
**Signature:** `(source_trace, target_version -> target_trace)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.Migrate.ValidateOutcome_v1`  
**Signature:** `(source_obj, target_obj, invariants -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. Migrate.Manifest_v1 / Migrate.Checkpoint_v1 / Migrate.Trace_v1
2. ValidateOutcome_v1 for each migrated object
3. Emit migration certificate
4. Return migration_report
```

---
## 7) Trace & Metrics
### Logging rule
- Migration execution emits deterministic stage and validation records.
### Trace schema
- `run_header`: migration_operator_id, from_version, to_version
- `iter`: object_id, stage, status
- `run_end`: migration_certificate_hash
### Metric schema
- `objects_migrated`, `objects_failed`
### Comparability guarantee
- Comparable iff same source objects, operator, and target version.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Supported path and required invariants declared.
#### VII.B Operator test vectors (mandatory)
- Migration success/failure fixtures.
#### VII.C Golden traces (mandatory)
- Golden migration execution traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for migrated object hashes and validation verdicts.
#### VIII.B Allowed refactor categories
- Runtime optimization preserving transformed bytes/hashes.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of migrated outputs and certificates.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Migration cursor and partial output refs.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed migration must preserve final target hashes and certificate.

FILE: layer4-implementation/Module-Scaffolding-Guide.md
=======================================================
# UML_OS Module Scaffolding Guide Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ModuleScaffold_v1`  
**Purpose (1 sentence):** Define deterministic module scaffolding templates and required wiring for new operator implementations.  
**Spec Version:** `UML_OS.Implementation.ModuleScaffold_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Code generation and module bootstrap governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ModuleScaffold_v1`
- **Purpose (1 sentence):** Deterministic module skeleton contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: eliminate ad-hoc operator module structure.
### 0.B Reproducibility Contract
- Replayable given `(operator_id, scaffold_template_hash, signature_digest)`.
### 0.C Numeric Policy
- N/A except deterministic versioning and hash comparisons.
### 0.D Ordering and Tie-Break Policy
- Generated files and sections follow fixed ordering.
### 0.E Parallel, Concurrency, and Reduction Policy
- Multi-module generation allowed with deterministic merge order.
### 0.F Environment and Dependency Policy
- Scaffold must be generated from operator registry metadata only.
### 0.G Operator Manifest
- `UML_OS.Scaffold.GenerateModule_v1`
- `UML_OS.Scaffold.ValidateScaffold_v1`
- `UML_OS.Scaffold.BindTests_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `src/<subsystem>/<operator>.py` + tests + vectors.
### 0.I Outputs and Metric Schema
- Outputs: `(scaffold_report, generated_paths)`
- Metrics: `files_generated`, `validation_failures`
### 0.J Spec Lifecycle Governance
- Template contract changes are MAJOR.
### 0.K Failure and Error Semantics
- Missing required scaffold files is fatal.
### 0.L Input/Data Provenance
- All generated artifacts must cite operator id/version/digest.

---
## 2) System Model
### I.A Persistent State
- Scaffold template registry.
### I.B Inputs and Hyperparameters
- operator metadata, template version, module root.
### I.C Constraints and Feasible Set
- Valid iff scaffold matches required structure and signature bindings.
### I.D Transient Variables
- generated file map and validation diagnostics.
### I.E Invariants and Assertions
- Scaffold placeholders must be deterministic and complete.

---
## 3) Initialization
1. Load operator registry row.
2. Resolve template.
3. Prepare deterministic output paths.

---
## 4) Operator Manifest
- `UML_OS.Scaffold.GenerateModule_v1`
- `UML_OS.Scaffold.ValidateScaffold_v1`
- `UML_OS.Scaffold.BindTests_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Scaffold.GenerateModule_v1`  
**Signature:** `(operator_record, template -> generated_module)`  
**Purity class:** IO  
**Determinism:** deterministic.

**Operator:** `UML_OS.Scaffold.ValidateScaffold_v1`  
**Signature:** `(generated_module, scaffold_rules -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.Scaffold.BindTests_v1`  
**Signature:** `(generated_module, vector_catalog -> test_bundle)`  
**Purity class:** IO  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. GenerateModule_v1
2. ValidateScaffold_v1
3. BindTests_v1
4. Emit scaffold_report
```

---
## 7) Trace & Metrics
### Logging rule
- Scaffold generation emits deterministic file and validation records.
### Trace schema
- `run_header`: operator_id, template_hash
- `iter`: file_path, status
- `run_end`: scaffold_status
### Metric schema
- `files_generated`, `validation_failures`
### Comparability guarantee
- Comparable iff same operator record + template hash.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- Required files/sections present.
#### VII.B Operator test vectors (mandatory)
- Scaffold generation fixtures.
#### VII.C Golden traces (mandatory)
- Golden generated-path traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for generated file set and normalized content hash.
#### VIII.B Allowed refactor categories
- Template engine internals preserving output artifacts.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of generated module hashes.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- Generation cursor and partial output index.
### Serialization
- Canonical CBOR.
### Restore semantics
- Resumed generation must produce identical outputs.

FILE: layer4-implementation/Operator-Conformance-Matrix.md
==========================================================
# UML_OS Operator Conformance Matrix
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.OperatorConformanceMatrix_v1`  
**Purpose (1 sentence):** Define deterministic operator implementation and conformance tracking for coding progress and release gating.  
**Spec Version:** `UML_OS.Implementation.OperatorConformanceMatrix_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Implementation governance and conformance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.OperatorConformanceMatrix_v1`
- **Purpose (1 sentence):** Canonical operator conformance tracking contract.
### 0.A Objective Semantics
- optimize for maximal conformance coverage with minimal unresolved blockers.
### 0.B Reproducibility Contract
- conformance verdict reproducible from registry hash + evidence hashes.
### 0.C Numeric Policy
- binary64 only for summary metrics.
### 0.D Ordering and Tie-Break Policy
- rows ordered by `operator_id` lexical ascending.
### 0.E Parallel, Concurrency, and Reduction Policy
- operator checks may run in parallel; merged deterministically.
### 0.F Environment and Dependency Policy
- conformance checks run under lockfile-pinned toolchain.
### 0.G Operator Manifest
- `UML_OS.Implementation.LoadOperatorRegistry_v1`
- `UML_OS.Implementation.ResolveOperatorEvidence_v1`
- `UML_OS.Implementation.ScoreOperatorConformance_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- implementation governance operators under `UML_OS.Implementation.*`.
### 0.I Outputs and Metric Schema
- outputs: `(conformance_matrix, conformance_summary, blockers)`.
### 0.J Spec Lifecycle Governance
- scoring rubric changes are MAJOR.
### 0.K Failure and Error Semantics
- unresolved mandatory evidence emits deterministic failure.
### 0.L Input/Data Provenance
- consumes registry artifact, test manifests, trace/certificate references.

---
## 2) System Model
### I.A Persistent State
- conformance matrix state keyed by `operator_id`.
### I.B Inputs and Hyperparameters
- operator registry, code map, test map, evidence map.
### I.C Constraints and Feasible Set
- each operator must map to exactly one implementation owner.
### I.D Transient Variables
- per-operator status and scoring details.
### I.E Invariants and Assertions
- no duplicate operator ids.

---
## 3) Initialization
1. Load operator registry.
2. Load implementation/test/evidence indexes.
3. Initialize conformance accumulator.

---
## 4) Operator Manifest
- `UML_OS.Implementation.LoadOperatorRegistry_v1`
- `UML_OS.Implementation.ResolveOperatorEvidence_v1`
- `UML_OS.Implementation.ScoreOperatorConformance_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Implementation.ResolveOperatorEvidence_v1`  
**Signature:** `(operator_id, evidence_indexes -> evidence_row)`  
**Purity class:** PURE  
**Definition:** Resolves implementation path, tests, vectors, and trace evidence for operator.

**Operator:** `UML_OS.Implementation.ScoreOperatorConformance_v1`  
**Signature:** `(evidence_row -> conformance_status, score)`  
**Purity class:** PURE  
**Definition:** Produces deterministic status in `{STUB, PARTIAL, COMPLETE, CERTIFIED}`.

---
## 6) Procedure
```text
1. registry <- LoadOperatorRegistry_v1(...)
2. for operator_id in sorted(registry):
     evidence_row <- ResolveOperatorEvidence_v1(...)
     status <- ScoreOperatorConformance_v1(evidence_row)
3. aggregate summary metrics
4. fail if required operators not COMPLETE+ for target gate
```

---
## 7) Trace & Metrics
- Metrics: `coverage_pct`, `stub_count`, `partial_count`, `complete_count`, `certified_count`.
- Trace fields: `operator_id`, `status`, `missing_evidence_codes`.

---
## 8) Validation
- Golden conformance matrix snapshots.
- Deterministic sorting and scoring vector checks.

---
## 9) Refactor & Equivalence
- E0 for matrix rows and statuses.
- E1 for non-gating timing counters only.

---
## 10) Checkpoint/Restore
- checkpoint stores processed operator cursor + partial summary.
- restore resumes and yields identical final matrix.

---
## 11) Profile Threshold Policy (Normative)
- Conformance matrix MUST classify each operator as:
  - `required_core`, `required_enterprise`, `required_regulated`, or `optional`.
- Coverage thresholds are enforced by profile:
  - `core`: at most 5% optional gaps; no required-core blockers.
  - `enterprise`: at most 2% optional gaps; no required-enterprise blockers.
  - `regulated`: no gaps in required-regulated set.
- Output contract extension:
  - `conformance_summary` MUST include `coverage_pct_by_profile` and `blockers_by_profile`.
- External certification label mapping:
  - operators/modules with `CERTIFIED` status and zero blockers in target profile MAY be labeled `UML_OS Certified Module`.

FILE: layer4-implementation/Operator-Registry-CBOR-Contract.md
==============================================================
# UML_OS Operator Registry CBOR Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Registry.OperatorRegistryCBOR_v1`
**Purpose (1 sentence):** Define the canonical machine-readable `operator_registry.cbor` artifact used by codegen, lint, runtime validation, and release evidence.
**Spec Version:** `UML_OS.Registry.OperatorRegistryCBOR_v1` | 2026-02-19 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Operator interface artifact governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Registry.OperatorRegistryCBOR_v1`
- **Purpose (1 sentence):** Canonical registry artifact for operator contracts.
### 0.A Objective Semantics
- Ensure a single deterministic source for operator signatures and constraints.
### 0.B Reproducibility Contract
- Artifact replayable and hash-identical from `(operator_entries, schema_digests, error_registry_hash, cbor_profile_hash)`.
### 0.C Numeric Policy
- N/A except deterministic integer ordering and binary-safe digest handling.
### 0.D Ordering and Tie-Break Policy
- Operator records sorted by authoritative ordering from `docs/layer1-foundation/Operator-Registry-Schema.md` (numeric `version_num` compare for `vN`).
- Field ordering follows canonical CBOR rules only.
### 0.E Parallel, Concurrency, and Reduction Policy
- Registry generation may parallelize parsing, but final merge order is deterministic.
### 0.F Environment and Dependency Policy
- Canonical serialization uses `docs/layer1-foundation/Canonical-CBOR-Profile.md`.
### 0.G Operator Manifest
- `UML_OS.Registry.BuildOperatorRegistryArtifact_v1`
- `UML_OS.Registry.ValidateOperatorRegistryArtifact_v1`
- `UML_OS.Implementation.SpecLint_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Canonical artifact path: `contracts/operator_registry.cbor`.
### 0.I Outputs and Metric Schema
- Outputs: `(operator_registry_cbor, operator_registry_root_hash, validation_report)`.
### 0.J Spec Lifecycle Governance
- Field-set or digest preimage change is MAJOR.
### 0.K Failure and Error Semantics
- Invalid records or digest mismatches fail deterministically.
### 0.L Input/Data Provenance
- Inputs include API interface contracts, mapping contracts, and error registry snapshot.

---
## 2) System Model
### I.A Persistent State
- Registry artifact history and published root hashes.
### I.B Inputs and Hyperparameters
- Operator entries, schema digests, error-code allowlists, purity classes, capability requirements.
### I.C Constraints and Feasible Set
- `operator_id` unique per version; no duplicate `(operator_id, version)` entries.
- Canonical ordering for `operator_records` is inherited from `docs/layer1-foundation/Operator-Registry-Schema.md`:
  - sort by `(operator_id, version_num)`,
  - `version_num = parse_uint(version[1:])` for `version` format `^v[0-9]+$`.
### I.D Transient Variables
- parse table, normalized entry list, digest resolution cache.
### I.E Invariants and Assertions
- `signature_digest` must match canonical preimage formula from `docs/layer1-foundation/Operator-Registry-Schema.md`.

### II.F Canonical Artifact Schema (Normative)
- Authoritative schema is defined in `docs/layer1-foundation/Operator-Registry-Schema.md` (Section `II.F Canonical Operator Record Schema`).
- This contract MUST NOT redefine required fields, names, or top-level layout for `contracts/operator_registry.cbor`.
- Optional non-authoritative build metadata (for example `generated_at`) may be emitted in sidecar documentation artifacts only; it is not part of the canonical registry object.

### II.G Artifact Hash (Normative)
- `operator_registry_root_hash = SHA-256(CBOR_CANONICAL(["operator_registry_v1", registry_schema_version, operator_records]))`
- This hash must match `operator_contracts_root_hash` in `docs/layer2-specs/Execution-Certificate.md`.
- Any informational metadata not present in the authoritative schema (for example `generated_at`) is excluded from this hash preimage.
- Canonical serialization profile for this preimage is `CanonicalSerialization_v1` from `docs/layer1-foundation/Canonical-CBOR-Profile.md`.

---
## 3) Procedure
```text
1. Load operator entries from docs/layer1-foundation/API-Interfaces.md and docs/layer4-implementation/Code-Generation-Mapping.md
2. Resolve digest_refs using docs/layer1-foundation/Digest-Catalog.md
3. Normalize + validate entry schema
4. Encode canonical CBOR and compute operator_registry_root_hash
5. Emit artifact and validation report
```

---
## 4) Validation
- Golden vectors for serialization and digest stability.
- Cross-check against `docs/layer1-foundation/Operator-Registry-Schema.md`.
- Cross-check signatures against `docs/layer4-implementation/Backend-Adapter-Guide.md`.

---
## 5) Wiring References
- `docs/layer1-foundation/API-Interfaces.md`
- `docs/layer1-foundation/Operator-Registry-Schema.md`
- `docs/layer1-foundation/Digest-Catalog.md`
- `docs/layer4-implementation/Code-Generation-Mapping.md`
- `docs/layer4-implementation/Backend-Adapter-Guide.md`
- `docs/layer4-implementation/Repo-Layout-and-Interfaces.md`

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Operator-SDK-Scaffold-Template.md
=============================================================
# UML_OS Operator SDK Scaffold Template Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.OperatorSDKScaffold_v1`  
**Purpose (1 sentence):** Define deterministic scaffold templates for implementing new operators with required validation, tracing, and error semantics.  
**Spec Version:** `UML_OS.Implementation.OperatorSDKScaffold_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Operator implementation scaffolding.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.OperatorSDKScaffold_v1`
- **Purpose (1 sentence):** Canonical scaffold template for operator implementation.
### 0.A Objective Semantics
- minimize scaffold drift and missing contract hooks.
### 0.B Reproducibility Contract
- scaffold generation reproducible from `(operator_id, template_hash, sdk_profile_hash)`.
### 0.C Numeric Policy
- N/A except deterministic status counters.
### 0.D Ordering and Tie-Break Policy
- generated sections ordered by canonical template order.
### 0.E Parallel, Concurrency, and Reduction Policy
- scaffolds can generate in parallel with deterministic file naming.
### 0.F Environment and Dependency Policy
- SDK version pinned.
### 0.G Operator Manifest
- `UML_OS.Implementation.GenerateOperatorScaffold_v1`
- `UML_OS.Implementation.ValidateScaffoldHooks_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- generated modules mirror `UML_OS.<subsystem>.<name>_vN`.
### 0.I Outputs and Metric Schema
- outputs: `(scaffold_files, scaffold_validation_report)`.
### 0.J Spec Lifecycle Governance
- scaffold required-hook changes are MAJOR.
### 0.K Failure and Error Semantics
- missing required hooks is deterministic failure.
### 0.L Input/Data Provenance
- scaffold bound to operator registry record hash.

---
## 2) System Model
### I.A Persistent State
- scaffold template catalog.
### I.B Inputs and Hyperparameters
- operator id, purity class, side effects, signature digest.
### I.C Constraints and Feasible Set
- operator id must exist in operator registry.
### I.D Transient Variables
- generated file buffers.
### I.E Invariants and Assertions
- scaffold includes validation, trace emit, and deterministic error path.

---
## 3) Initialization
1. Load template catalog and SDK config.
2. Resolve operator registry entry.
3. Initialize generation context.

---
## 4) Operator Manifest
- `UML_OS.Implementation.GenerateOperatorScaffold_v1`
- `UML_OS.Implementation.ValidateScaffoldHooks_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Implementation.GenerateOperatorScaffold_v1`  
**Signature:** `(operator_registry_record, template -> scaffold_files)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** Generates canonical operator implementation skeleton.

---
## 6) Procedure
```text
1. Resolve operator record
2. Generate scaffold files
3. Validate required hooks and signatures
4. Emit scaffold validation report
```

---
## 7) Trace & Metrics
- Metrics: `files_generated`, `hook_violations`, `signature_mismatches`.
- Trace includes operator id and scaffold hash.

---
## 8) Validation
- golden scaffold snapshots for representative operator types.
- deterministic file ordering and hook-inclusion tests.

---
## 9) Refactor & Equivalence
- E0 for scaffold output files and validation report.

---
## 10) Checkpoint/Restore
- checkpoint stores generation cursor and partial output hash.
- restore continues generation deterministically.

FILE: layer4-implementation/PR-Review-Checklist.md
==================================================
# UML_OS PR Review Checklist
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.PRReviewChecklist_v1`  
**Purpose (1 sentence):** Define deterministic pull-request review gates for contract safety, replay integrity, and regression risk control.  
**Spec Version:** `UML_OS.Implementation.PRReviewChecklist_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Engineering governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.PRReviewChecklist_v1`
- **Purpose (1 sentence):** Deterministic PR quality gating checklist.
### 0.A Objective Semantics
- minimize unresolved high-severity findings.
### 0.B Reproducibility Contract
- review verdict reproducible from changed files + checklist version.
### 0.C Numeric Policy
- binary64 for computed risk scores.
### 0.D Ordering and Tie-Break Policy
- findings sorted by severity then file path then line.
### 0.E Parallel, Concurrency, and Reduction Policy
- independent checks may run in parallel; reductions deterministic.
### 0.F Environment and Dependency Policy
- checklist toolchain pinned by lockfile.
### 0.G Operator Manifest
- `UML_OS.Implementation.ScanChangedContracts_v1`
- `UML_OS.Implementation.ScorePRRisk_v1`
- `UML_OS.Implementation.DecideReviewGate_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- operators under `UML_OS.Implementation.*`.
### 0.I Outputs and Metric Schema
- `(review_findings, review_gate, review_metrics)`.
### 0.J Spec Lifecycle Governance
- gate criteria changes are MAJOR.
### 0.K Failure and Error Semantics
- unresolved blocker findings force deterministic failure.
### 0.L Input/Data Provenance
- uses git diff, registry hash, test outputs.

---
## 2) System Model
### I.A Persistent State
- checklist version, ruleset hash.
### I.B Inputs and Hyperparameters
- changed files, changed operators, CI evidence bundle.
### I.C Constraints and Feasible Set
- PR must include evidence for changed contract-critical docs/code.
### I.D Transient Variables
- per-check findings.
### I.E Invariants and Assertions
- no merge on blocker-level findings.

---
## 3) Initialization
1. Load ruleset.
2. Load changed file manifest.
3. Initialize findings container.

---
## 4) Operator Manifest
- `UML_OS.Implementation.ScanChangedContracts_v1`
- `UML_OS.Implementation.ScorePRRisk_v1`
- `UML_OS.Implementation.DecideReviewGate_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Implementation.ScanChangedContracts_v1`  
**Signature:** `(changed_files, ruleset -> findings)`  
**Purity class:** PURE  
**Definition:** Detects contract-impacting changes and missing updates.

**Operator:** `UML_OS.Implementation.ScorePRRisk_v1`
**Signature:** `(findings, evidence_bundle -> risk_score, review_metrics)`
**Purity class:** PURE
**Definition:** Computes deterministic risk score and review metrics from findings and attached evidence.

**Operator:** `UML_OS.Implementation.DecideReviewGate_v1`  
**Signature:** `(findings, risk_score -> gate_verdict)`  
**Purity class:** PURE  
**Definition:** Produces `PASS/WARN/FAIL` deterministically.

---
## 6) Procedure
```text
1. findings <- ScanChangedContracts_v1(...)
2. risk <- ScorePRRisk_v1(findings)
3. gate <- DecideReviewGate_v1(findings, risk)
4. if gate == FAIL: Error.Emit_v1(CONTRACT_VIOLATION)
5. return (review_findings, review_gate, review_metrics)
```

---
## 7) Trace & Metrics
- Metrics: `blocker_count`, `major_count`, `coverage_delta`, `risk_score`.
- Trace includes checklist version and rule hash.

---
## 8) Validation
- Golden PR examples for pass/warn/fail.
- Regression test for deterministic finding ordering.

---
## 9) Refactor & Equivalence
- E0 for gate verdict and finding ordering.
- E1 allowed for non-gating timing metrics only.

---
## 10) Checkpoint/Restore
- Review checkpoint stores findings and gate snapshot.
- Restore reproduces exact verdict.

FILE: layer4-implementation/Profiling-and-Optimization-Guide.md
===============================================================
# UML_OS Profiling and Optimization Guide
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ProfilingOptimizationGuide_v1`  
**Purpose (1 sentence):** Define deterministic profiling workflows and optimization acceptance criteria for runtime, memory, and throughput improvements.  
**Spec Version:** `UML_OS.Implementation.ProfilingOptimizationGuide_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Performance engineering.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ProfilingOptimizationGuide_v1`
- **Purpose (1 sentence):** Deterministic performance analysis and optimization gate contract.
### 0.A Objective Semantics
- maximize throughput while preserving correctness and deterministic guarantees.
### 0.B Reproducibility Contract
- profile verdict reproducible from fixed inputs, profile config, and environment fingerprint.
### 0.C Numeric Policy
- binary64 metrics aggregation and nearest-rank quantiles.
### 0.D Ordering and Tie-Break Policy
- profile samples sorted by timestamp then sample_seq.
### 0.E Parallel, Concurrency, and Reduction Policy
- per-rank profiling reduced deterministically.
### 0.F Environment and Dependency Policy
- profiling requires pinned determinism profile and toolchain.
### 0.G Operator Manifest
- `UML_OS.Perf.CaptureProfileWindow_v1`
- `UML_OS.Perf.AggregatePerfMetrics_v1`
- `UML_OS.Perf.EvaluatePerfGate_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- performance operators under `UML_OS.Perf.*`.
### 0.I Outputs and Metric Schema
- outputs: `(perf_snapshot, perf_regression_report, gate_verdict)`.
### 0.J Spec Lifecycle Governance
- gate threshold changes are MAJOR.
### 0.K Failure and Error Semantics
- threshold violation emits deterministic regression code.
### 0.L Input/Data Provenance
- performance runs tied to dataset/model/checkpoint hashes.

---
## 2) System Model
### I.A Persistent State
- baseline snapshots and threshold catalog.
### I.B Inputs and Hyperparameters
- profile id, sample count, warmup count, metric thresholds.
### I.C Constraints and Feasible Set
- sample count must exceed minimum for gate evaluation.
### I.D Transient Variables
- raw timing and memory samples.
### I.E Invariants and Assertions
- same workload shape and batch across baseline/candidate comparisons.

---
## 3) Initialization
1. Load baseline perf snapshot.
2. Load profile configuration.
3. Initialize sampling buffers.

---
## 4) Operator Manifest
- `UML_OS.Perf.CaptureProfileWindow_v1`
- `UML_OS.Perf.AggregatePerfMetrics_v1`
- `UML_OS.Perf.EvaluatePerfGate_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Perf.AggregatePerfMetrics_v1`  
**Signature:** `(samples, quantile_policy -> perf_snapshot)`  
**Purity class:** PURE  
**Definition:** Computes deterministic aggregates including p50/p95/p99 with declared quantile rule.

**Operator:** `UML_OS.Perf.EvaluatePerfGate_v1`  
**Signature:** `(baseline, candidate, thresholds -> verdict)`  
**Purity class:** PURE  
**Definition:** Produces deterministic pass/fail with regression diagnostics.

---
## 6) Procedure
```text
1. capture profiling window
2. aggregate deterministic metrics
3. compare against baseline thresholds
4. emit verdict and regression report
```

---
## 7) Trace & Metrics
- Metrics: `throughput`, `latency_p50`, `latency_p95`, `latency_p99`, `peak_memory_bytes`, `fragmentation_ratio`.
- Trace includes profile id and metric snapshot hash.

---
## 8) Validation
- golden profile traces for reference workloads.
- regression vectors for threshold violations.

---
## 9) Refactor & Equivalence
- E0 for metric aggregation logic and gate verdict.
- E1 for wall-clock variance only when outside committed gates.

---
## 10) Checkpoint/Restore
- checkpoint stores partial sample buffers and aggregation cursor.
- restore continues deterministic aggregation.

FILE: layer4-implementation/Reference-Implementations.md
========================================================
# UML_OS Reference Implementations Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ReferenceImplementations_v1`  
**Purpose (1 sentence):** Define canonical coding-level signatures and pseudocode for critical operators to eliminate implementation ambiguity.  
**Spec Version:** `UML_OS.Implementation.ReferenceImplementations_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Developer implementation guidance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ReferenceImplementations_v1`
- **Purpose (1 sentence):** Normative coding reference for critical operators.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize implementation drift across languages/backends.
### 0.B Reproducibility Contract
- Reference behavior must be replayable under identical inputs and policy hashes.
### 0.C Numeric Policy
- Critical arithmetic paths use binary64 and deterministic ordering.
### 0.D Ordering and Tie-Break Policy
- Stable deterministic index/rank ordering in all reference loops.
### 0.E Parallel, Concurrency, and Reduction Policy
- Reference code is sequential semantics; parallel implementations must be equivalent.
### 0.F Environment and Dependency Policy
- Reference implementations are language-agnostic and side-effect explicit.
### 0.G Operator Manifest
- `UML_OS.Data.NextBatch_v2`
- `UML_OS.DifferentialPrivacy.Apply_v3`
- `UML_OS.TMMU.PrepareMemory_v2`
- `UML_OS.Replay.CompareTrace_v1`
- `UML_OS.Certificate.EvidenceValidate_v1`
### 0.H Namespacing and Packaging
- One reference module per operator family.
### 0.I Outputs and Metric Schema
- Outputs are canonical return structs per operator signature.
### 0.J Spec Lifecycle Governance
- Signature/algorithm-semantic changes are MAJOR.
### 0.K Failure and Error Semantics
- Error handling must map to `docs/layer1-foundation/Error-Codes.md` IDs only.
### 0.L Input/Data Provenance
- Inputs reference manifest/checkpoint/trace/schema hashes.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- none; references are pure semantic templates.
### I.B Inputs and Hyperparameters
- operator-specific typed inputs.
### I.C Constraints and Feasible Set
- valid only for schema-valid inputs.
### I.D Transient Variables
- local deterministic work buffers.
### I.E Invariants and Assertions
- signatures and side-effects must match `docs/layer1-foundation/API-Interfaces.md`.

### II.F Canonical Function Signatures (Normative)
- `UML_OS.Data.NextBatch_v2(dataset_key, world_size, rank, stage_type, cursor_in) -> (indices, cursor_next, metrics)`
- `UML_OS.DifferentialPrivacy.Apply_v3(gradients, dp_config, t, state) -> (noisy_gradients, state_next, metrics)`
- `UML_OS.TMMU.PrepareMemory_v2(ir_dag, execution_order, mode, arena_config) -> (tensor_map, metrics)`
- `UML_OS.Replay.CompareTrace_v1(trace_a, trace_b, replay_mode) -> divergence_report`
- `UML_OS.Certificate.EvidenceValidate_v1(manifest, trace, checkpoint, replay_ctx) -> validation_report`
- All signatures must be derived from `contracts/operator_registry.cbor`; manual signature drift is forbidden.
- Alias note: short helper names may appear in pseudocode, but normative identity is always the fully-qualified operator id.

### II.G Normative Reference Pseudocode (Required)
- `CBOR_CANONICAL(value)`:
  - encode using `docs/layer1-foundation/Canonical-CBOR-Profile.md` (definite lengths, no duplicate keys, key order by `(len(encoded_key), encoded_key)`).
  - reject non-UTF8 text keys and forbidden float values in signed payloads.
- `ResolveDigestRef_v1(digest_ref, digest_catalog)`:
  - if tail matches `^[0-9a-f]{64}$`, return inline bytes32 digest.
  - else resolve label in `digest_catalog`; abort with `CONTRACT_VIOLATION` if missing.
- `TraceRecordHashChain_v1(normalized_records)`:
  - `h = SHA-256(CBOR_CANONICAL(["trace_chain_v1"]))`
  - for each record in canonical order:
    - `r = SHA-256(CBOR_CANONICAL(record))`
    - `h = SHA-256(CBOR_CANONICAL(["trace_chain_v1", h, r]))`
  - return `h` as `trace_final_hash` in linear-chain mode.
- `WalChainAndFinalize_v1(records)`:
  - compute each `record_hash_i = SHA-256(CBOR_CANONICAL(["wal_record_v1", tenant_id, run_id, wal_seq_i, record_type_i, prev_record_hash_i, payload_i]))`.
  - terminal `FINALIZE` record hash is `commit_record_hash`.
  - `wal_terminal_hash = commit_record_hash`.
- `PublishCommitPointer_v1(pointer_payload)`:
  - payload must include `{trace_final_hash, checkpoint_hash, lineage_root_hash, execution_certificate_hash, wal_terminal_hash}`.
  - publish `runs/<tenant_id>/<run_id>/COMMITTED` via conditional create-if-absent.
  - if object exists, compare payload hash; mismatch is deterministic failure.

---
## 3) Initialization
1. Load typed schemas.
2. Validate operator signatures.
3. Bind deterministic helper primitives.

---
## 4) Operator Manifest
- `UML_OS.Implementation.Ref.NextBatch_v2`
- `UML_OS.Implementation.Ref.ApplyDP_v3`
- `UML_OS.Implementation.Ref.PrepareMemory_v2`
- `UML_OS.Implementation.Ref.ReplayCompare_v1`
- `UML_OS.Implementation.Ref.EvidenceValidate_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Implementation.Ref.NextBatch_v2`  
**Category:** Implementation  
**Signature:** `(dataset_key, world_size, rank, stage_type, cursor_in -> indices, cursor_next, metrics)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** canonical sampling pseudocode consistent with `docs/layer2-specs/Data-NextBatch.md`.

**Operator:** `UML_OS.Implementation.Ref.ApplyDP_v3`  
**Category:** Implementation  
**Signature:** `(gradients, dp_config, t, state -> noisy_gradients, state_next, metrics)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic control / stochastic noise per RNG contract  
**Definition:** canonical DP pseudocode consistent with `docs/layer2-specs/DifferentialPrivacy-Apply.md`.

**Operator:** `UML_OS.Implementation.Ref.PrepareMemory_v2`  
**Category:** Implementation  
**Signature:** `(ir_dag, execution_order, mode, arena_config -> tensor_map, metrics)`  
**Purity class:** STATEFUL  
**Determinism:** deterministic  
**Definition:** canonical injective arena-offset planner pseudocode.

**Operator:** `UML_OS.Implementation.Ref.ReplayCompare_v1`
**Category:** Implementation
**Signature:** `(trace_a, trace_b, replay_mode -> divergence_report)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** canonical comparator pseudocode aligned with `docs/layer2-specs/Replay-Determinism.md`.

**Operator:** `UML_OS.Implementation.Ref.EvidenceValidate_v1`
**Category:** Implementation
**Signature:** `(manifest, trace, checkpoint, replay_ctx -> validation_report)`
**Purity class:** PURE
**Determinism:** deterministic
**Definition:** canonical evidence-link validation pseudocode aligned with `docs/layer2-specs/Execution-Certificate.md`.

---
## 6) Procedure
```text
1. Validate schemas and signatures.
2. Execute operator-specific reference procedure.
3. Emit canonical outputs and metrics.
4. Verify expected side-effects set.
```

---
## 7) Trace & Metrics
### Logging rule
- reference runs emit deterministic debug traces for compare-only use.
### Trace schema
- `run_header`: operator, signature_digest
- `iter`: step, local_state_hash
- `run_end`: output_hash
### Metric schema
- `steps`, `deterministic_checks_passed`
### Comparability guarantee
- comparable iff signatures, inputs, and policies are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- no hidden globals, total state updates, deterministic ordering.
#### VII.B Operator test vectors (mandatory)
- each reference function must pass catalog vectors from `docs/layer3-tests/Test-Vectors-Catalog.md`.
#### VII.C Golden traces (mandatory)
- golden output hashes per reference operator.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for outputs and side-effects on deterministic paths.
#### VIII.B Allowed refactor categories
- language/runtime rewrites preserving signature and semantics.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare against golden vectors and output hashes.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- optional local reference-state snapshots for debug replay.
### Serialization
- deterministic CBOR.
### Restore semantics
- restored reference state yields identical outputs.

FILE: layer4-implementation/Reference-Stack-Minimal.md
======================================================
# UML_OS Minimal Runnable Reference Stack
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.ReferenceStack.Minimal_v1`  
**Purpose (1 sentence):** Define a minimal runnable reference implementation that proves the full deterministic lifecycle from manifest to certificate and replay.  
**Spec Version:** `UML_OS.ReferenceStack.Minimal_v1` | 2026-02-20 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Executable reference implementation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.ReferenceStack.Minimal_v1`
- **Purpose (1 sentence):** End-to-end runnable proof of contract interoperability.
### 0.A Objective Semantics
- Execute the smallest useful pipeline that demonstrates deterministic lifecycle closure.
### 0.B Reproducibility Contract
- Replayable given `(manifest_hash, env_manifest_hash, replay_token, operator_registry_root_hash, fixture_hash)`.
### 0.C Numeric Policy
- IEEE-754 binary64, round-to-nearest ties-to-even.
### 0.D Ordering and Tie-Break Policy
- Single-worker deterministic ordering by step index.
### 0.E Parallel, Concurrency, and Reduction Policy
- No parallel execution in minimal stack.
### 0.F Environment and Dependency Policy
- Locked dependency manifest required.
### 0.G Operator Manifest
- `UML_OS.Config.NormalizeDefaults_v1`
- `UML_OS.Data.NextBatch_v2`
- `UML_OS.Model.ModelIR_Executor_v1`
- `UML_OS.Trace.ComputeTraceHash_v1`
- `UML_OS.Checkpoint.Write_v1`
- `UML_OS.Certificate.Build_v1`
- `UML_OS.Replay.CompareTrace_v1`
### 0.H Namespacing and Packaging
- Reference stack package path: `reference/minimal_stack/`.
### 0.I Outputs and Metric Schema
- Outputs: `(run_report, trace_final_hash, checkpoint_hash, certificate_hash, replay_verdict)`.
### 0.J Spec Lifecycle Governance
- Breaking lifecycle changes require MAJOR bump.
### 0.K Failure and Error Semantics
- Deterministic abort on first contract violation.
### 0.L Input/Data Provenance
- Fixture dataset, model IR, and manifest must be content-addressed.

---
## 2) System Model
### I.A Persistent State
- Minimal run state: manifest, RNG offsets, model params, trace chain state.
### I.B Inputs and Hyperparameters
- tiny synthetic dataset, tiny linear model IR, fixed seed.
### I.C Constraints and Feasible Set
- Single-node local mode only.
### I.D Transient Variables
- per-step batch, logits/loss, gradients, trace events.
### I.E Invariants and Assertions
- Same inputs produce same trace/certificate hashes.

---
## 3) Procedure
```text
1. Load canonical manifest + fixtures.
2. Normalize config defaults and derive replay_token.
3. For each train step: NextBatch_v2 -> ModelIR_Executor_v1.
4. Emit trace records and compute trace_final_hash.
5. Write checkpoint and compute checkpoint_hash.
6. Build execution certificate and compute certificate_hash.
7. Replay same run and compare trace with Replay.CompareTrace_v1.
8. Emit run_report and replay_verdict.
```

---
## 4) Validation
- Required deliverable: runnable script that reproduces identical lifecycle hashes on every supported host profile.
- Required artifacts:
  - `fixtures/hello-core/manifest.core.yaml`
  - `fixtures/hello-core/model_ir.json`
  - `fixtures/hello-core/tiny_synth_dataset.jsonl`
  - `goldens/hello-core/trace_snippet.json`
  - `goldens/hello-core/checkpoint_header.json`
  - `goldens/hello-core/execution_certificate.json`
  - `contracts/operator_registry.cbor`
  - `contracts/catalog-manifest.json`
  - `vectors/hello-core/vectors.json`
  - `vectors/hello-core/vectors-manifest.json`

## 4.A Artifact Identity Verification (Normative)
- Before claiming runnable-reference conformance, run:
  - `python tools/verify_doc_artifacts.py`
- Hash identities used by this contract are the values in:
  - `contracts/catalog-manifest.json`
  - `fixtures/hello-core/fixture-manifest.json`
  - `goldens/hello-core/golden-manifest.json`

---
## 5) Related Contracts
- `docs/layer2-specs/UML_OS-Kernel-v3.22-OS.md`
- `docs/layer2-specs/ModelIR-Executor.md`
- `docs/layer2-specs/Execution-Certificate.md`
- `docs/layer2-specs/Replay-Determinism.md`

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Release-Evidence-Assembler.md
=========================================================
# UML_OS Release Evidence Assembler Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Release.EvidenceAssembler_v1`  
**Purpose (1 sentence):** Define deterministic assembly of release evidence bundles consumed by certificate signing and deployment gates.  
**Spec Version:** `UML_OS.Release.EvidenceAssembler_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Release governance and evidence binding.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Release.EvidenceAssembler_v1`
- **Purpose (1 sentence):** Deterministic release evidence assembly contract.
### 0.A Objective Semantics
- minimize missing or inconsistent release evidence.
### 0.B Reproducibility Contract
- evidence bundle reproducible from `(release_manifest_hash, artifact_hash_set, assembly_policy_hash)`.
### 0.C Numeric Policy
- hash-based commitments only.
### 0.D Ordering and Tie-Break Policy
- evidence entries sorted by `(evidence_type, evidence_id)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- evidence fetches parallel; final assembly deterministic.
### 0.F Environment and Dependency Policy
- assembler runtime and policy pinned.
### 0.G Operator Manifest
- `UML_OS.Release.CollectEvidenceRefs_v1`
- `UML_OS.Release.BuildEvidenceBundle_v1`
- `UML_OS.Release.ValidateEvidenceBundle_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Release.*` namespace.
### 0.I Outputs and Metric Schema
- outputs: `(evidence_bundle_ref, evidence_bundle_hash, validation_report)`.
### 0.J Spec Lifecycle Governance
- required evidence field changes are MAJOR.
### 0.K Failure and Error Semantics
- missing mandatory evidence fails assembly.
### 0.L Input/Data Provenance
- all evidence refs must be content-addressed.

---
## 2) System Model
### I.A Persistent State
- evidence policy catalog and assembler version.
### I.B Inputs and Hyperparameters
- release manifest, trace/checkpoint/certificate refs, registry refs.
 - optional external-verification artifacts:
   - certification evidence bundles (backend/store),
   - observability mapping bundle hash,
   - performance tier baseline artifacts,
   - chaos/recovery proof packs.
### I.C Constraints and Feasible Set
- mandatory evidence set must be complete.
### I.D Transient Variables
- resolved evidence rows and validation diagnostics.
### I.E Invariants and Assertions
- bundle hash uniquely identifies assembled evidence set.
- external-verification-ready releases MUST include certification and observability evidence when target profile is `enterprise` or `regulated`.

### II.F External Verification Evidence Extensions (Normative)
- When release target profile is `enterprise` or `regulated`, evidence bundle MUST include:
  - `backend_certification_bundle_hash`,
  - `artifact_store_certification_bundle_hash`,
  - `certification_evidence_bundle_hash` from conformance harness,
  - `observability_mapping_hash` (OTel/Prometheus mapping),
  - `performance_tier_report_hash`,
  - `chaos_recovery_proof_pack_hash` (mandatory in `regulated` mode).
- Bundle completeness failure on any mandatory extension is deterministic fatal.

---
## 3) Initialization
1. Load evidence policy.
2. Resolve required evidence set.
3. Initialize assembly context.

---
## 4) Operator Manifest
- `UML_OS.Release.CollectEvidenceRefs_v1`
- `UML_OS.Release.BuildEvidenceBundle_v1`
- `UML_OS.Release.ValidateEvidenceBundle_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Release.BuildEvidenceBundle_v1`  
**Signature:** `(evidence_refs, policy -> evidence_bundle)`  
**Purity class:** IO  
**Determinism:** deterministic  
**Definition:** Builds canonical evidence bundle and computes commitment hash.

---
## 6) Procedure
```text
1. Collect required evidence refs
2. Build canonical evidence bundle
3. Validate completeness and hash links
4. Emit bundle ref and bundle hash
```

---
## 7) Trace & Metrics
- Metrics: `required_evidence_total`, `missing_evidence_count`, `bundle_size_bytes`.
- Trace includes bundle hash and validation status.

---
## 8) Validation
- golden evidence bundles for release profiles.
- deterministic ordering and hash stability tests.

---
## 9) Refactor & Equivalence
- E0 for bundle hash and validation verdict.

---
## 10) Checkpoint/Restore
- checkpoint stores evidence-resolution cursor and partial bundle hash.
- restore continues assembly deterministically.

---
## 11) Related Contracts
- `docs/layer4-implementation/Contracts-Artifact-Lifecycle.md`
- `docs/layer2-specs/Execution-Certificate.md`
- `docs/layer2-specs/Run-Commit-WAL.md`
- `docs/layer3-tests/Game-Day-Scenarios.md`
- `docs/layer4-implementation/Third-Party-Operator-Certification-Program.md`
 - `docs/layer4-implementation/Disaster-Recovery-Operations-Runbook.md`
 - `docs/layer4-implementation/Incident-Postmortem-Template.md`

---
## 12) Evidence Interchange and Recovery Proof Binding (Normative)
- Release evidence MUST be exportable as a portable interchange package:
  - `evidence_bundle.cbor`
  - `evidence_manifest.json`
  - `evidence_signatures/`
  - `verification_instructions.txt`
- Interchange package hash:
  - `evidence_interchange_hash = SHA-256(CBOR_CANONICAL([evidence_bundle_hash, evidence_manifest_hash, signatures_hash]))`.
- Third-party verification requirement:
  - package must be verifiable without repository-local state beyond published contract hashes and trust roots.
- Regulated releases MUST embed or reference:
  - `chaos_recovery_proof_pack_hash`,
  - `conformance_coverage_report_hash`,
  - `sbom_hash`,
  - `operator_registry_root_hash`.

## 13) Canonical Artifact Inputs (Normative)
- Canonical contracts and catalogs for doc-phase verifiable assembly:
  - `contracts/operator_registry.cbor`
  - `contracts/digest_catalog.cbor`
  - `contracts/error_codes.cbor`
  - `contracts/capability_catalog.cbor`
  - `contracts/schema_catalog.cbor`
  - `contracts/vectors_catalog.cbor`
  - `contracts/catalog-manifest.json`
- Minimal pinned fixture/evidence inputs:
  - `fixtures/hello-core/fixture-manifest.json`
  - `goldens/hello-core/golden-manifest.json`
  - `vectors/hello-core/vectors-manifest.json`

FILE: layer4-implementation/Repo-Layout-and-Interfaces.md
=========================================================
# UML_OS Repo Layout and Interfaces Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.RepoLayoutInterfaces_v1`  
**Purpose (1 sentence):** Define canonical repository structure, module boundaries, and ownership aligned to operator interface contracts.  
**Spec Version:** `UML_OS.Implementation.RepoLayoutInterfaces_v1` | 2026-02-18 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Implementation architecture and module governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.RepoLayoutInterfaces_v1`
- **Purpose (1 sentence):** Canonical codebase layout and boundary contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary comparison rule: deterministic total preorder over declared primary metric tuple with `EPS_EQ` tie handling.
- Invalid objective policy: `NaN/Inf` ranked as worst-case and handled deterministically per 0.K.
- Minimize code ownership ambiguity and cross-module contract drift.
### 0.B Reproducibility Contract
- layout and interface manifests are hash-addressed and versioned.
### 0.C Numeric Policy
- N/A except hash and version identifiers.
### 0.D Ordering and Tie-Break Policy
- module resolution order is deterministic lexical path order.
### 0.E Parallel, Concurrency, and Reduction Policy
- build graph resolution deterministic by declared dependencies.
### 0.F Environment and Dependency Policy
- dependency boundaries enforced by static import rules.
### 0.G Operator Manifest
- `UML_OS.Implementation.ValidateRepoLayout_v1`
- `UML_OS.Implementation.ValidateModuleBoundaries_v1`
- `UML_OS.Implementation.ValidateOwnershipMap_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- namespace roots: `src/`, `tests/`, `vectors/`, `schemas/`, `ops/`.
### 0.I Outputs and Metric Schema
- outputs: `(layout_report, boundary_report, ownership_report)`.
### 0.J Spec Lifecycle Governance
- boundary/ownership semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- boundary violations emit deterministic errors.
### 0.L Input/Data Provenance
- repo state bound to commit hash and manifest hash.

---
### 0.Z EQC Mandatory Declarations Addendum
- Seed space: `seed âˆˆ {0..2^64-1}` when stochastic sub-operators are used.
- PRNG family: `Philox4x32-10` for declared stochastic operators.
- Randomness locality: all sampling occurs only inside declared stochastic operators in section 5.
- Replay guarantee: replayable given (seed, PRNG family, numeric policy, ordering policy, parallel policy, environment policy).
- Replay token: deterministic per-run token contribution is defined and included in trace records.
- Floating-point format: IEEE-754 binary64 unless explicitly declared otherwise.
- Rounding mode: round-to-nearest ties-to-even unless explicitly overridden.
- Fast-math policy: forbidden for critical checks and verdict paths.
- Named tolerances: `EPS_EQ=1e-10`, `EPS_DENOM=1e-12`, and domain-specific thresholds as declared.
- NaN/Inf policy: invalid values trigger deterministic failure handling per 0.K.
- Normalized exponentials: stable log-sum-exp required when exponential paths are used (otherwise N/A).
- Overflow/underflow: explicit abort or clamp behavior must be declared (this contract uses deterministic abort on critical paths).
- Approx-equality: `a â‰ˆ b` iff `|a-b| <= EPS_EQ` when tolerance checks apply.
- Transcendental functions policy: deterministic implementation requirements are inherited from consuming operators.
- Reference runtime class: CPU-only/GPU-enabled/distributed as required by the consuming workflow.
- Compiler/flags: deterministic compilation; fast-math disabled for critical paths.
- Dependency manifest: pinned runtime dependencies and versions are required.
- Determinism level: `BITWISE` for contract-critical outputs unless a stricter local declaration exists.
- Error trace rule: final failure record includes `t`, `failure_code`, `failure_operator`, replay token, and minimal diagnostics.
- Recovery policy: none unless explicitly declared; default is deterministic abort-only.

## 2) System Model
### I.A Persistent State
- module registry and ownership map.
### I.B Inputs and Hyperparameters
- repo tree, module manifest, ownership manifest.
### I.C Constraints and Feasible Set
- every mapped operator must have exactly one module target.
### I.D Transient Variables
- validation diagnostics.
### I.E Invariants and Assertions
- ownership coverage complete for mapped operators.

### II.F Canonical Layout (Normative)
- `src/data`, `src/model`, `src/dp`, `src/tmmu`, `src/replay`, `src/trace`, `src/checkpoint`, `src/backend`, `src/security`, `src/registry`, `src/tracking`, `src/monitor`, `src/cert`.
- `tests/unit`, `tests/integration`, `tests/replay`, `tests/perf`.
- `vectors/<operator_id>/`.
- `schemas/` for config/trace/checkpoint/api schemas.
- `tools/spec_lint.py` mandatory linter entrypoint for cross-file contract consistency.
- `contracts/operator_registry.cbor` canonical machine-readable operator registry artifact.
- Additional authoritative contract artifacts:
  - `contracts/digest_catalog.cbor`
  - `contracts/determinism_profiles.cbor`
  - `wal/run_commit/<tenant_id>/<run_id>/records/<wal_seq>.cbor`
  - `runs/<tenant_id>/<run_id>/COMMITTED` (conditional commit pointer object)

### II.G Ownership Map (Normative)
- `data team`: `src/data/*`
- `model team`: `src/model/*`
- `privacy team`: `src/dp/*`
- `runtime team`: `src/tmmu/*`, `src/checkpoint/*`
- `platform team`: `src/tracking/*`, `src/monitor/*`, `src/config/*`
- `security team`: `src/security/*`, `src/cert/*`
- `governance team`: `src/registry/*`

### II.H Operator Registry Artifact (Normative)
- `contracts/operator_registry.cbor` is the single source of truth for operator interface metadata.
- construction and validation contract: `docs/layer4-implementation/Operator-Registry-CBOR-Contract.md`.
- Required fields per operator record:
  - `operator_id`, `version`, `surface`,
  - `request_schema_digest`, `response_schema_digest`, `signature_digest`,
  - `side_effects`, `allowed_error_codes`, `purity_class`, `required_capabilities`.
- `docs/layer1-foundation/API-Interfaces.md` and `docs/layer4-implementation/Code-Generation-Mapping.md` are rendered/derived views and must not diverge from the artifact.
- Any divergence is a deterministic `CONTRACT_VIOLATION` at lint time.

---
## 3) Initialization
1. Load repo layout manifest.
2. Load ownership manifest.
3. Load operator mapping manifest.

---
## 4) Operator Manifest
- `UML_OS.Implementation.ValidateRepoLayout_v1`
- `UML_OS.Implementation.ValidateModuleBoundaries_v1`
- `UML_OS.Implementation.ValidateOwnershipMap_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Implementation.ValidateRepoLayout_v1`  
**Category:** Implementation  
**Signature:** `(repo_tree, layout_contract -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** checks required directories/files and canonical placement rules.

**Operator:** `UML_OS.Implementation.ValidateModuleBoundaries_v1`  
**Category:** Implementation  
**Signature:** `(import_graph, boundary_rules -> report)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** enforces allowed dependencies and forbids boundary leaks.

---
## 6) Procedure
```text
1. ValidateRepoLayout_v1
2. ValidateModuleBoundaries_v1
3. ValidateOwnershipMap_v1
4. Emit reports and fail on violations
```

---
## 7) Trace & Metrics
### Logging rule
- repository validation emits deterministic structural diagnostics.
### Trace schema
- `run_header`: commit_hash, mapping_hash
- `iter`: module_id, check_id, status
- `run_end`: violation_count
### Metric schema
- `missing_paths`, `boundary_violations`, `ownership_gaps`
### Comparability guarantee
- comparable iff repo snapshot and contracts are identical.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- every mapped API operator has exactly one repo module target.
#### VII.B Operator test vectors (mandatory)
- valid/invalid layout trees and boundary graphs.
#### VII.C Golden traces (mandatory)
- golden layout validation traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for reports and violation counts.
#### VIII.B Allowed refactor categories
- tooling implementation changes preserving validation semantics.
#### VIII.C Equivalence test procedure (mandatory)
- exact compare of reports for golden repo snapshots.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- validator cursor and partial diagnostics.
### Serialization
- deterministic CBOR.
### Restore semantics
- resumed validation yields identical final report.

FILE: layer4-implementation/Research-Extensions-Roadmap.md
==========================================================
# UML_OS Research Extensions Roadmap
**Spec Version:** v1.0.0 | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**EQC Compliance:** Informational roadmap; non-normative for current production profile guarantees.

## 1) Federated Learning Extension
- Extend execution and evidence contracts for cross-silo coordination.
- Define global privacy-budget coordination semantics.

## 2) Verifiable Delay Functions for Fairness
- Explore VDF-linked sampling proofs for auditable batch-order fairness.

## 3) Zero-Knowledge Proofs for Model Integrity
- Explore zk proof systems for private yet verifiable training correctness claims.

## 4) Adoption Rule
- Any promoted research extension must first define deterministic contracts, migration path, and conformance vectors.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Research Extensions Roadmap" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Runtime-State-Machine-Reference.md
==============================================================
# UML_OS Runtime State Machine Reference
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Runtime.StateMachineReference_v1`  
**Purpose (1 sentence):** Define canonical runtime state machines and deterministic transition semantics for kernel, orchestrator, and execution subsystems.  
**Spec Version:** `UML_OS.Runtime.StateMachineReference_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Runtime lifecycle and transition correctness.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Runtime.StateMachineReference_v1`
- **Purpose (1 sentence):** Canonical runtime lifecycle transition contract.
### 0.A Objective Semantics
- minimize illegal transitions and stuck states.
### 0.B Reproducibility Contract
- transition history reproducible from event log + transition rules hash.
### 0.C Numeric Policy
- binary64 for timers/metrics only.
### 0.D Ordering and Tie-Break Policy
- transition arbitration by `(event_seq, source, transition_id)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- competing transitions resolved by deterministic CAS policy.
### 0.F Environment and Dependency Policy
- runtime transition engine version pinned.
### 0.G Operator Manifest
- `UML_OS.Runtime.ValidateTransition_v1`
- `UML_OS.Runtime.ApplyTransitionCAS_v1`
- `UML_OS.Runtime.EmitTransitionTrace_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- runtime lifecycle operators under `UML_OS.Runtime.*`.
### 0.I Outputs and Metric Schema
- outputs: `(new_state, transition_record, state_metrics)`.
### 0.J Spec Lifecycle Governance
- state additions/removals are MAJOR.
### 0.K Failure and Error Semantics
- illegal transition emits deterministic failure.
### 0.L Input/Data Provenance
- state transitions sourced from signed event records.

---
## 2) System Model
### I.A Persistent State
- runtime state, transition sequence, lease state.
### I.B Inputs and Hyperparameters
- current state, event, policy hash, expected transition seq.
### I.C Constraints and Feasible Set
- transition must exist in allowed transition table.
### I.D Transient Variables
- candidate transition and conflict diagnostics.
### I.E Invariants and Assertions
- transition sequence strictly monotonic.

---
## 3) Initialization
1. Load state machine definition.
2. Load current runtime state snapshot.
3. Initialize transition evaluator.

---
## 4) Operator Manifest
- `UML_OS.Runtime.ValidateTransition_v1`
- `UML_OS.Runtime.ApplyTransitionCAS_v1`
- `UML_OS.Runtime.EmitTransitionTrace_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Runtime.ValidateTransition_v1`  
**Signature:** `(state, event, transition_table -> transition_ok, next_state)`  
**Purity class:** PURE  
**Definition:** Validates that requested transition is legal and deterministic.

**Operator:** `UML_OS.Runtime.ApplyTransitionCAS_v1`  
**Signature:** `(state_store, expected_seq, transition_record -> committed)`  
**Purity class:** STATEFUL  
**Definition:** Applies transition atomically using compare-and-swap semantics.

---
## 6) Procedure
```text
1. validate transition legality
2. build transition record with deterministic idempotency key
3. apply CAS transition
4. emit trace record
5. return new state
```

---
## 7) Trace & Metrics
- Metrics: `illegal_transition_count`, `conflict_retry_count`, `stuck_state_duration`.
- Trace records include `from_state`, `to_state`, `transition_seq`, `idempotency_key`.

---
## 8) Validation
- golden transition tables and event streams.
- conflict simulation tests for deterministic CAS behavior.

---
## 9) Refactor & Equivalence
- E0 for transition acceptance/rejection and resulting state.

---
## 10) Checkpoint/Restore
- runtime checkpoint stores state + transition sequence + active lease.
- restore continues from exact sequence point.

FILE: layer4-implementation/SDK-Usage-Guide.md
==============================================
# UML_OS SDK Usage Guide Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.SDK.UsageGuide_v1`  
**Purpose (1 sentence):** Define deterministic SDK usage patterns for syscall/service interfaces, error handling, and replay-safe client behavior.  
**Spec Version:** `UML_OS.SDK.UsageGuide_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Client integration and API correctness.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.SDK.UsageGuide_v1`
- **Purpose (1 sentence):** Deterministic SDK integration contract.
### 0.A Objective Semantics
- Optimization sense: `MINIMIZE`
- Objective type: `Scalar`
- Primary objective: prevent client-side contract drift and non-replayable calls.
### 0.B Reproducibility Contract
- Replayable given `(operator_registry_root_hash, sdk_version, request_digest, response_digest)`.
### 0.C Numeric Policy
- Numeric payload fields must preserve declared scalar types exactly.
### 0.D Ordering and Tie-Break Policy
- Request maps and list fields must be canonicalized before digest/signature use.
### 0.E Parallel, Concurrency, and Reduction Policy
- Concurrent calls allowed; idempotent call semantics must follow registry declarations.
### 0.F Environment and Dependency Policy
- SDK must validate digests against `docs/layer1-foundation/API-Interfaces.md` and registry artifacts.
### 0.G Operator Manifest
- `UML_OS.SDK.ValidateRequest_v1`
- `UML_OS.SDK.DispatchCall_v1`
- `UML_OS.SDK.ValidateResponse_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.SDK.*`
### 0.I Outputs and Metric Schema
- Outputs: `(sdk_call_report, response_payload)`
- Metrics: `calls_total`, `calls_failed`, `schema_mismatch_count`
### 0.J Spec Lifecycle Governance
- SDK behavior changes affecting canonicalization are MAJOR.
### 0.K Failure and Error Semantics
- Nonconformant requests/responses fail deterministically.
### 0.L Input/Data Provenance
- Every SDK call must bind operator id, version, and resolved schema digests.

---
## 2) System Model
### I.A Persistent State
- Local interface cache and digest map.
### I.B Inputs and Hyperparameters
- operator id/version, request payload, auth context, replay context.
### I.C Constraints and Feasible Set
- Valid iff request/response match declared schemas.
### I.D Transient Variables
- call diagnostics and serialization buffers.
### I.E Invariants and Assertions
- SDK must never mutate request semantics after digest binding.

---
## 3) Initialization
1. Load operator registry and digest catalog.
2. Resolve request/response digests.
3. Validate SDK environment compatibility.

---
## 4) Operator Manifest
- `UML_OS.SDK.ValidateRequest_v1`
- `UML_OS.SDK.DispatchCall_v1`
- `UML_OS.SDK.ValidateResponse_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.SDK.ValidateRequest_v1`  
**Signature:** `(operator_id, request_payload, schema_digest -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

**Operator:** `UML_OS.SDK.DispatchCall_v1`  
**Signature:** `(operator_id, request_payload, auth_context -> response_payload)`  
**Purity class:** IO  
**Determinism:** deterministic under fixed inputs and backend state.

**Operator:** `UML_OS.SDK.ValidateResponse_v1`  
**Signature:** `(operator_id, response_payload, schema_digest -> validation_report)`  
**Purity class:** PURE  
**Determinism:** deterministic.

---
## 6) Procedure
```text
1. ValidateRequest_v1
2. DispatchCall_v1
3. ValidateResponse_v1
4. Return response_payload + sdk_call_report
```

---
## 7) Trace & Metrics
### Logging rule
- SDK calls emit deterministic request/response validation events.
### Trace schema
- `run_header`: sdk_version, operator_registry_root_hash
- `iter`: operator_id, call_id, status
- `run_end`: call_report_hash
### Metric schema
- `calls_total`, `calls_failed`, `schema_mismatch_count`
### Comparability guarantee
- Comparable iff same SDK version, registry root, and payloads.

---
## 8) Validation
#### VII.A Lint rules (mandatory)
- No calls with unresolved schema digests.
#### VII.B Operator test vectors (mandatory)
- Valid/invalid request-response fixtures.
#### VII.C Golden traces (mandatory)
- Golden SDK call traces.

---
## 9) Refactor & Equivalence
#### VIII.A Equivalence levels
- E0 for validated request/response hashes and error mapping.
#### VIII.B Allowed refactor categories
- SDK transport/runtime changes preserving call semantics.
#### VIII.C Equivalence test procedure (mandatory)
- Exact compare of validation reports on fixed fixtures.

---
## 10) Checkpoint/Restore
### Checkpoint contents
- SDK cache snapshot and call cursor.
### Serialization
- Canonical CBOR.
### Restore semantics
- Restored SDK state must preserve identical validation and dispatch behavior.

FILE: layer4-implementation/SRE-Incident-Triage-Playbook.md
===========================================================
# UML_OS SRE Incident Triage Playbook
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Operations.SREIncidentTriage_v1`  
**Purpose (1 sentence):** Define deterministic incident triage and remediation workflow for runtime, replay, storage, and governance failures.  
**Spec Version:** `UML_OS.Operations.SREIncidentTriage_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Production reliability operations.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Operations.SREIncidentTriage_v1`
- **Purpose (1 sentence):** Deterministic incident triage and escalation contract.
### 0.A Objective Semantics
- minimize MTTR while preserving evidence integrity.
### 0.B Reproducibility Contract
- triage outcome reproducible from incident evidence bundle hash.
### 0.C Numeric Policy
- binary64 for SLO impact and timing metrics.
### 0.D Ordering and Tie-Break Policy
- triage order fixed by severity then detector timestamp.
### 0.E Parallel, Concurrency, and Reduction Policy
- independent incident checks parallelizable; verdict merge deterministic.
### 0.F Environment and Dependency Policy
- incident analysis uses frozen evidence artifacts only.
### 0.G Operator Manifest
- `UML_OS.Operations.ClassifyIncident_v1`
- `UML_OS.Operations.RunTriageChecklist_v1`
- `UML_OS.Operations.EmitRemediationPlan_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Operations.*` namespace.
### 0.I Outputs and Metric Schema
- outputs: `(incident_report, triage_verdict, remediation_plan)`.
### 0.J Spec Lifecycle Governance
- severity model changes are MAJOR.
### 0.K Failure and Error Semantics
- missing mandatory evidence is a fatal triage failure.
### 0.L Input/Data Provenance
- incident evidence must include trace/checkpoint/WAL/certificate references.

---
## 2) System Model
### I.A Persistent State
- incident catalog and remediation runbooks.
### I.B Inputs and Hyperparameters
- incident id, evidence bundle refs, triage profile.
### I.C Constraints and Feasible Set
- triage cannot proceed without evidence integrity verification.
### I.D Transient Variables
- per-check findings and severity updates.
### I.E Invariants and Assertions
- every incident ends in deterministic terminal state.

---
## 3) Initialization
1. Load incident profile and severity matrix.
2. Load evidence bundle.
3. Initialize triage context.

---
## 4) Operator Manifest
- `UML_OS.Operations.ClassifyIncident_v1`
- `UML_OS.Operations.RunTriageChecklist_v1`
- `UML_OS.Operations.EmitRemediationPlan_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Operations.RunTriageChecklist_v1`  
**Signature:** `(incident_class, evidence -> triage_findings)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Executes incident-class-specific deterministic checks and returns findings.

---
## 6) Procedure
```text
1. Classify incident
2. Run deterministic triage checklist
3. Emit remediation plan with ordered actions
4. Record terminal triage verdict
```

---
## 7) Trace & Metrics
- Metrics: `incidents_by_severity`, `mttr_minutes`, `evidence_integrity_failures`.
- Trace includes incident class, checklist id, and remediation plan hash.

---
## 8) Validation
- incident replay fixtures for WAL corruption, replay divergence, checkpoint mismatch, certificate mismatch.
- deterministic triage ordering tests.

---
## 9) Refactor & Equivalence
- E0 for incident class and remediation action order.

---
## 10) Checkpoint/Restore
- triage checkpoint stores completed checklist steps and findings hash.
- restore continues deterministically from next step.

FILE: layer4-implementation/Schema-Evolution-Playbook.md
========================================================
# UML_OS Schema Evolution Playbook
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.SchemaEvolutionPlaybook_v1`  
**Purpose (1 sentence):** Provide deterministic procedures for introducing, validating, and migrating contract schemas without replay or audit breakage.  
**Spec Version:** `UML_OS.Implementation.SchemaEvolutionPlaybook_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Contract migration governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.SchemaEvolutionPlaybook_v1`
- **Purpose (1 sentence):** Deterministic schema evolution workflow.
### 0.A Objective Semantics
- minimize migration risk and compatibility breaks.
### 0.B Reproducibility Contract
- migration outputs reproducible from `(old_schema, new_schema, inputs)`.
### 0.C Numeric Policy
- binary64 only for migration metrics.
### 0.D Ordering and Tie-Break Policy
- migration rules applied in sorted rule-id order.
### 0.E Parallel, Concurrency, and Reduction Policy
- independent objects migrate in parallel; deterministic merge order.
### 0.F Environment and Dependency Policy
- migration toolchain locked and versioned.
### 0.G Operator Manifest
- `UML_OS.Implementation.ValidateSchemaChange_v1`
- `UML_OS.Implementation.RunSchemaMigration_v1`
- `UML_OS.Implementation.VerifyMigrationEquivalence_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- migration operators under `UML_OS.Implementation.*`.
### 0.I Outputs and Metric Schema
- `(migration_report, migrated_hashes, equivalence_report)`.
### 0.J Spec Lifecycle Governance
- breaking schema changes require MAJOR + migration operator.
### 0.K Failure and Error Semantics
- invalid migration path emits deterministic error.
### 0.L Input/Data Provenance
- old/new schema hashes and migration input object hashes logged.

---
## 2) System Model
### I.A Persistent State
- migration rules registry.
### I.B Inputs and Hyperparameters
- schema type, from_version, to_version, migration mode.
### I.C Constraints and Feasible Set
- migration path must be explicitly allowed.
### I.D Transient Variables
- per-record migration deltas.
### I.E Invariants and Assertions
- no silent field drops on committed fields.

---
## 3) Initialization
1. Load source and target schema.
2. Validate migration operator availability.
3. Prepare migration plan.

---
## 4) Operator Manifest
- `UML_OS.Implementation.ValidateSchemaChange_v1`
- `UML_OS.Implementation.RunSchemaMigration_v1`
- `UML_OS.Implementation.VerifyMigrationEquivalence_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Implementation.ValidateSchemaChange_v1`  
**Signature:** `(old_schema, new_schema -> change_report)`  
**Purity class:** PURE  
**Definition:** Classifies changes into additive/compatible/breaking classes.

**Operator:** `UML_OS.Implementation.RunSchemaMigration_v1`  
**Signature:** `(objects, migration_rules -> migrated_objects)`  
**Purity class:** PURE  
**Definition:** Applies deterministic migration transformations.

---
## 6) Procedure
```text
1. change_report <- ValidateSchemaChange_v1(...)
2. if change_report.invalid: Error.Emit_v1(CONTRACT_VIOLATION)
3. migrated <- RunSchemaMigration_v1(...)
4. eq <- VerifyMigrationEquivalence_v1(...)
5. return migration_report
```

---
## 7) Trace & Metrics
- Metrics: `objects_migrated`, `migration_failures`, `field_additions`, `field_removals`.
- Trace records include source and target schema hashes.

---
## 8) Validation
- Golden migration vectors for each schema family.
- Replay test: same input yields identical migrated hashes.

---
## 9) Refactor & Equivalence
- E0 for migrated object hashes.
- E1 only for non-critical counters.

---
## 10) Checkpoint/Restore
- Migration checkpoint stores cursor and partially migrated object list hash.
- Restore continues deterministically.

---
## 11) Deprecation Economics Addendum (Normative)
- Time-bounded deprecation windows are mandatory:
  - every deprecated field/operator/schema variant MUST declare `sunset_release`.
  - default minimum grace window is `N=2` MINOR releases unless superseded by stricter profile policy.
- Breaking schema changes MUST include:
  - an explicit migration operator reference,
  - migration evidence vectors,
  - customer-visible compatibility statement.
- Customer-facing guarantee:
  - artifacts produced before `sunset_release` remain readable/migratable through published migration operators.

---
## 12) LTS and Compatibility Window Policy (Normative)
- Contract lifecycle classes:
  - `stable`, `lts`, `experimental`.
- LTS guarantees:
  - LTS-tagged schemas/operators remain supported for at least one MAJOR + four MINOR releases.
- Compatibility statement MUST declare:
  - forward-read window,
  - backward-read window,
  - migration path obligations,
  - removal date for deprecated forms.

FILE: layer4-implementation/Scope-and-Non-Goals.md
==================================================
# UML_OS Scope and Non-Goals
**Spec Version:** v1.0.0 | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**EQC Compliance:** Governance companion; normative boundary declarations.

## 1) In Scope
- deterministic operator contracts,
- reproducible execution lifecycle,
- audit/evidence/certificate binding,
- profile-based deployment governance.

## 2) Out of Scope
- prescribing a single scheduler implementation strategy,
- mandating a specific UI/UX technology stack,
- defining proprietary cloud control planes,
- forcing one storage vendor/runtime for all deployments.

## 3) Boundary Rule
- Where behavior is out-of-scope, the implementation MUST still preserve declared contract invariants (hashes, ordering, error semantics, evidence linkage).

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Scope and Non-Goals" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Security-Case-Template.md
=====================================================
# UML_OS Security Case Template
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Security.SecurityCaseTemplate_v1`
**Purpose (1 sentence):** Provide a deterministic, hash-addressed template for auditor-ready security case submissions.
**Spec Version:** `UML_OS.Security.SecurityCaseTemplate_v1` | 2026-02-21 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Security.SecurityCaseTemplate_v1`
- **Purpose (1 sentence):** Deterministic security-case packaging template.
- **Spec Version:** `UML_OS.Security.SecurityCaseTemplate_v1` | 2026-02-21 | Authors: Olejar Damir
- **Domain / Problem Class:** audit-ready control mapping and evidence binding.
### 0.A Objective Semantics
- Convert threat controls into verifiable evidence obligations.
### 0.B Reproducibility Contract
- Replayable given `(security_case_input_set, control_catalog_hash, evidence_refs)`.
### 0.C Numeric Policy
- N/A.
### 0.D Ordering and Tie-Break Policy
- Control entries sorted by `control_id`.
### 0.E Parallel, Concurrency, and Reduction Policy
- Control checks parallelizable; verdict aggregation deterministic fail-dominant.
### 0.F Environment and Dependency Policy
- Required evidence must be content-addressed and canonical.
### 0.G Operator Manifest
- `UML_OS.Product.EmitSecurityCase_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `security_case/<profile>/<release_id>/`.
### 0.I Outputs and Metric Schema
- Outputs: `(security_case_report, security_case_hash)`.
### 0.J Spec Lifecycle Governance
- Template fields are MAJOR-governed.
### 0.K Failure and Error Semantics
- Missing required evidence path is deterministic failure.
### 0.L Input/Data Provenance
- Inputs from threat model, policy transcripts, execution certificate, release evidence.

## 2) Template Schema (Normative)
- `security_case` object must contain:
  - `profile_id` (`core|enterprise|regulated`)
  - `assets[]`
  - `trust_boundaries[]`
  - `attacker_capabilities[]`
  - `controls[]` with fields:
    - `control_id`
    - `mitigation`
    - `evidence_locations[]`
    - `verification_procedure_ref`
    - `verdict`

## 3) Identity Rule (Normative)
- `security_case_hash = SHA-256(CBOR_CANONICAL(["security_case_v1", security_case]))`.

## 4) References
- `docs/layer4-implementation/Threat-Model-and-Control-Crosswalk.md`
- `docs/layer2-specs/Security-Compliance-Profile.md`
- `docs/layer4-implementation/Evidence-Catalog.md`

## 6) Procedure
```text
1. Build control entries from threat model crosswalk.
2. Resolve evidence locations and run verification procedures.
3. Emit control verdicts and security_case report.
4. Compute security_case_hash.
```

FILE: layer4-implementation/Security-Coding-Checklist.md
========================================================
# UML_OS Security Coding Checklist
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Security.CodingChecklist_v1`  
**Purpose (1 sentence):** Define deterministic secure-coding requirements and enforcement checks for implementation and review pipelines.  
**Spec Version:** `UML_OS.Security.CodingChecklist_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Secure implementation governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Security.CodingChecklist_v1`
- **Purpose (1 sentence):** Deterministic secure-coding review contract.
### 0.A Objective Semantics
- minimize exploitable defects and policy violations.
### 0.B Reproducibility Contract
- checklist verdict reproducible from code snapshot + checklist version.
### 0.C Numeric Policy
- binary64 for risk scoring and trend metrics.
### 0.D Ordering and Tie-Break Policy
- findings sorted by severity then path then line.
### 0.E Parallel, Concurrency, and Reduction Policy
- static checks parallelized; finding merge deterministic.
### 0.F Environment and Dependency Policy
- scanner versions and rule packs pinned.
### 0.G Operator Manifest
- `UML_OS.Security.RunStaticSecurityChecks_v1`
- `UML_OS.Security.VerifySecretHandlingRules_v1`
- `UML_OS.Security.VerifyAuthzPathCoverage_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- security governance operators under `UML_OS.Security.*`.
### 0.I Outputs and Metric Schema
- outputs: `(security_findings, security_gate, security_metrics)`.
### 0.J Spec Lifecycle Governance
- mandatory security rule changes are MAJOR.
### 0.K Failure and Error Semantics
- blocker vulnerability findings fail gate deterministically.
### 0.L Input/Data Provenance
- source tree hash, ruleset hash, toolchain hash logged.

---
## 2) System Model
### I.A Persistent State
- security ruleset and suppression registry.
### I.B Inputs and Hyperparameters
- changed files, codebase snapshot, enforcement profile.
### I.C Constraints and Feasible Set
- no undocumented suppression allowed.
### I.D Transient Variables
- per-rule findings.
### I.E Invariants and Assertions
- all authz-critical paths must be covered by checks.

---
## 3) Initialization
1. Load security ruleset.
2. Load source snapshot metadata.
3. Initialize findings sink.

---
## 4) Operator Manifest
- `UML_OS.Security.RunStaticSecurityChecks_v1`
- `UML_OS.Security.VerifySecretHandlingRules_v1`
- `UML_OS.Security.VerifyAuthzPathCoverage_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Security.VerifySecretHandlingRules_v1`  
**Signature:** `(source_snapshot, ruleset -> findings)`  
**Purity class:** PURE  
**Definition:** Enforces key/secret handling constraints and redaction usage rules.

**Operator:** `UML_OS.Security.VerifyAuthzPathCoverage_v1`  
**Signature:** `(code_map, authz_contract -> coverage_report)`  
**Purity class:** PURE  
**Definition:** Confirms required capability checks exist on protected operator paths.

---
## 6) Procedure
```text
1. run static security checks
2. validate secret handling and redaction policies
3. verify authz-path coverage
4. aggregate findings and gate verdict
5. fail on blocker findings
```

---
## 7) Trace & Metrics
- Metrics: `critical_findings`, `high_findings`, `authz_coverage_pct`, `secret_leak_findings`.
- Trace includes ruleset hash and suppression list hash.

---
## 8) Validation
- golden vulnerable and clean code fixtures.
- deterministic ordering of findings and gate verdict.

---
## 9) Refactor & Equivalence
- E0 for gate verdict and blocker finding identities.

---
## 10) Checkpoint/Restore
- checkpoint stores file cursor, findings hash, and partial verdict state.
- restore resumes scan deterministically.

FILE: layer4-implementation/Spec-Lint-Implementation.md
=======================================================
# UML_OS Spec Lint Implementation Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.SpecLint_v1`  
**Purpose (1 sentence):** Define deterministic implementation requirements for cross-document linting and contract-consistency enforcement.  
**Spec Version:** `UML_OS.Implementation.SpecLint_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Contract linting and CI enforcement.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.SpecLint_v1`
- **Purpose (1 sentence):** Deterministic cross-spec lint implementation contract.
### 0.A Objective Semantics
- minimize unresolved contract inconsistencies.
### 0.B Reproducibility Contract
- lint verdict reproducible from `(docs_set_hash, lint_rules_hash, operator_registry_root_hash)`.
### 0.C Numeric Policy
- binary64 only for aggregate lint metrics.
### 0.D Ordering and Tie-Break Policy
- findings ordered by severity, file path, line.
### 0.E Parallel, Concurrency, and Reduction Policy
- checks parallelizable; finding reduction deterministic.
### 0.F Environment and Dependency Policy
- pinned parser/runtime versions required.
### 0.G Operator Manifest
- `UML_OS.Implementation.LoadDocSet_v1`
- `UML_OS.Implementation.RunSpecLintRules_v1`
- `UML_OS.Implementation.AggregateLintVerdict_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- linter entrypoint: `tools/spec_lint.py`.
- normative rule catalog: `docs/layer4-implementation/Spec-Lint-Rules.md`.
### 0.I Outputs and Metric Schema
- outputs: `(lint_report, lint_verdict, lint_metrics)`.
### 0.J Spec Lifecycle Governance
- rule semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- blocker lint findings fail CI deterministically.
### 0.L Input/Data Provenance
- lint run records docs hash and rules hash.

---
## 2) System Model
### I.A Persistent State
- lint ruleset registry.
### I.B Inputs and Hyperparameters
- markdown set, registry artifacts, strictness profile.
### I.C Constraints and Feasible Set
- all referenced contracts must be parseable.
### I.D Transient Variables
- per-rule findings and diagnostics.
### I.E Invariants and Assertions
- no undefined operator or error code references.

---
## 3) Initialization
1. Load lint ruleset and parser profile.
2. Load operator/error registries.
3. Initialize findings collector.

---
## 4) Operator Manifest
- `UML_OS.Implementation.LoadDocSet_v1`
- `UML_OS.Implementation.RunSpecLintRules_v1`
- `UML_OS.Implementation.AggregateLintVerdict_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Implementation.RunSpecLintRules_v1`  
**Signature:** `(doc_set, rule_set -> findings)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Executes rule suite over parsed docs and emits normalized findings.

---
## 6) Procedure
```text
1. Load docs and registries
2. Execute lint rules deterministically
3. Aggregate verdict
4. Fail on blocker-level findings
```

---
## 7) Trace & Metrics
- Metrics: `finding_count`, `blocker_count`, `major_count`, `files_scanned`.
- Trace includes `docs_set_hash`, `rules_hash`, `registry_hashes`.

---
## 8) Validation
- golden lint fixtures (pass/fail) required.
- regression tests for rule determinism and ordering.

---
## 9) Refactor & Equivalence
- E0 for lint verdict and normalized finding list.

---
## 10) Checkpoint/Restore
- checkpoint stores file cursor, rule cursor, findings hash.
- restore must reproduce identical verdict.

FILE: layer4-implementation/Spec-Lint-Rules.md
==============================================
# UML_OS Spec Lint Rules Catalog
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.SpecLintRules_v1`
**Purpose (1 sentence):** Define the normative lint-rule catalog and severities for deterministic cross-document contract validation.
**Spec Version:** `UML_OS.Implementation.SpecLintRules_v1` | 2026-02-19 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Lint rules governance.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.SpecLintRules_v1`
- **Purpose (1 sentence):** Deterministic rule catalog for `tools/spec_lint.py`.
### 0.A Objective Semantics
- Maximize contract coherence and eliminate silent cross-file drift.
### 0.B Reproducibility Contract
- Rule verdicts replayable from `(docs_set_hash, rules_catalog_hash, registry_hashes)`.
### 0.C Numeric Policy
- binary64 for aggregate statistics only.
### 0.D Ordering and Tie-Break Policy
- findings ordered by `(severity desc, doc_path asc, line asc, rule_id asc)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- rules may run in parallel; merged findings must preserve deterministic ordering.
### 0.F Environment and Dependency Policy
- parser and regex engine versions pinned in tooling manifest.
### 0.G Operator Manifest
- `UML_OS.Implementation.SpecLint_v1`
- `UML_OS.Implementation.LoadRuleCatalog_v1`
- `UML_OS.Implementation.EvaluateRuleSet_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Rule catalog source path: `docs/layer4-implementation/Spec-Lint-Rules.md`.
### 0.I Outputs and Metric Schema
- outputs: `(findings, verdict, lint_metrics)`.
### 0.J Spec Lifecycle Governance
- New BLOCKER rules are MINOR; changed rule semantics are MAJOR.
### 0.K Failure and Error Semantics
- BLOCKER findings fail validation deterministically.
### 0.L Input/Data Provenance
- lint run stores docs hash and catalog hash in trace metadata.

---
## 2) Normative Rule Set
| Rule ID | Severity | Description | Failure Code |
|---|---|---|---|
| `EQC.LINK.RESOLVE` | BLOCKER | Every project-local `.md` reference must resolve. | `CONTRACT_VIOLATION` |
| `EQC.GRAPH.PARITY` | BLOCKER | Every discovered doc reference must have an edge in `ecosystem-graph.yaml`. | `CONTRACT_VIOLATION` |
| `EQC.GRAPH.STALE_EDGE` | BLOCKER | `REFERENCES` edges must correspond to real references in source docs. | `CONTRACT_VIOLATION` |
| `EQC.REG.PATH.EXISTS` | BLOCKER | Every `FilePath` in registry must exist and be non-empty. | `CONTRACT_VIOLATION` |
| `EQC.REG.VERSION.MATCH` | BLOCKER | Registry version declaration must match file-declared version token policy. | `CONTRACT_VIOLATION` |
| `EQC.EDGE.DECLARED` | BLOCKER | Graph edge types must be declared in source doc `DeclaredEdgeTypes`. | `CONTRACT_VIOLATION` |
| `EQC.LAYER.IMPORTS` | BLOCKER | `IMPORTS/EXTENDS` must not target higher layer. | `CONTRACT_VIOLATION` |
| `EQC.GRAPH.REACHABLE` | MAJOR | All docs must be reachable from `CORE-MASTER-001` via metadata/governance edges. | `CONTRACT_VIOLATION` |
| `EQC.DOCID.UNIQUE` | BLOCKER | Registry `DocID` values must be unique. | `CONTRACT_VIOLATION` |
| `EQC.FILEPATH.UNIQUE` | BLOCKER | Registry `FilePath` values must be unique. | `CONTRACT_VIOLATION` |

---
## 3) Rule Evaluation Procedure
```text
1. Parse registry + graph + markdown corpus
2. Resolve references and build discovered ref set
3. Run blocker rules first
4. Run MAJOR/MINOR informational rules
5. Emit deterministic finding stream and verdict
```

---
## 4) Wiring References
- `docs/layer4-implementation/Spec-Lint-Implementation.md`
- `docs/layer4-implementation/Repo-Layout-and-Interfaces.md`
- `ecosystem.md`
- `ecosystem-registry.yaml`
- `ecosystem-graph.yaml`

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Test-Harness-Implementation.md
==========================================================
# UML_OS Test Harness Implementation Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Test.HarnessImplementation_v1`  
**Purpose (1 sentence):** Define deterministic harness architecture for loading vectors, executing suites, and evaluating outcomes.  
**Spec Version:** `UML_OS.Test.HarnessImplementation_v1` | 2026-02-19 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

**Domain / Problem Class:** Test harness implementation.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Test.HarnessImplementation_v1`
- **Purpose (1 sentence):** Deterministic harness execution model.
### 0.A Objective Semantics
- minimize flaky or ambiguous test outcomes.
### 0.B Reproducibility Contract
- harness verdict reproducible from `(vectors_catalog_hash, harness_config_hash)`.
### 0.C Numeric Policy
- binary64 for metric comparisons unless exact hashes required.
### 0.D Ordering and Tie-Break Policy
- vector execution order by `(suite_id, vector_id)`.
### 0.E Parallel, Concurrency, and Reduction Policy
- parallel vector execution allowed with deterministic result merge.
### 0.F Environment and Dependency Policy
- harness env pinned; deterministic profile required.
### 0.G Operator Manifest
- `UML_OS.Test.LoadVectorSet_v1`
- `UML_OS.Test.ExecuteVector_v1`
- `UML_OS.Test.CompareExpected_v1`
- `UML_OS.Test.AggregateHarnessReport_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- `UML_OS.Test.*` namespace.
### 0.I Outputs and Metric Schema
- outputs: `(suite_results, harness_report, harness_verdict)`.
### 0.J Spec Lifecycle Governance
- comparator semantics changes are MAJOR.
### 0.K Failure and Error Semantics
- malformed vectors or comparator mismatch fail deterministically.
### 0.L Input/Data Provenance
- vectors loaded by content hash.

---
## 2) System Model
### I.A Persistent State
- harness config and comparator registry.
### I.B Inputs and Hyperparameters
- suite ids, vector catalog, comparison profile.
### I.C Constraints and Feasible Set
- every vector must declare expected output or expected error.
### I.D Transient Variables
- per-vector runtime outputs.
### I.E Invariants and Assertions
- every vector produces exactly one terminal result.

---
## 3) Initialization
1. Load vectors catalog.
2. Validate harness configuration.
3. Initialize comparator state.

---
## 4) Operator Manifest
- `UML_OS.Test.LoadVectorSet_v1`
- `UML_OS.Test.ExecuteVector_v1`
- `UML_OS.Test.CompareExpected_v1`
- `UML_OS.Test.AggregateHarnessReport_v1`
- `UML_OS.Error.Emit_v1`

---
## 5) Operator Definitions
**Operator:** `UML_OS.Test.CompareExpected_v1`  
**Signature:** `(observed, expected, compare_profile -> verdict)`  
**Purity class:** PURE  
**Determinism:** deterministic  
**Definition:** Compares outputs with exact or tolerance profile rules and emits canonical verdict.

---
## 6) Procedure
```text
1. Load vectors for selected suites
2. Execute each vector deterministically
3. Compare observed vs expected
4. Aggregate suite and harness verdict
```

---
## 7) Trace & Metrics
- Metrics: `vectors_total`, `vectors_passed`, `vectors_failed`, `suite_failures`.
- Trace includes vector ids, operator ids, compare profile hash.

---
## 8) Validation
- harness self-tests with meta-vectors.
- deterministic ordering and report hash tests.

---
## 9) Refactor & Equivalence
- E0 for vector verdicts and harness report hash.

---
## 10) Checkpoint/Restore
- checkpoint stores vector cursor and accumulated results hash.
- restore resumes without changing final verdict.

FILE: layer4-implementation/Third-Party-Operator-Certification-Program.md
=========================================================================
# UML_OS Third-Party Operator Certification Program
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Marketplace.OperatorCertification_v1`  
**Purpose (1 sentence):** Define deterministic lifecycle for third-party operator development, conformance certification, and publication.  
**Spec Version:** `UML_OS.Marketplace.OperatorCertification_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) Program Levels
- `Level 1`: local conformance pass.
- `Level 2`: profile conformance pass (`core` / `enterprise`).
- `Level 3`: regulated-grade certification with full evidence package.

## 2) Required Inputs
- operator registry entry,
- canonical signatures/digest refs,
- test vectors,
- conformance harness reports,
- security declaration,
- SBOM hash.

## 3) Certification Evidence Package Format
- `operator_package_manifest.json`
- `operator_contract_bundle.cbor`
- `conformance_package.cbor`
- `security_statement.json`
- `sbom.json`
- `certification_verdict.json`

## 4) Publication Rules
- Only deterministic, hash-addressed, and signature-verified packages may be published.
- Certified package must include sunset/deprecation metadata.

## 5) Revocation and Renewal
- Revocation emits signed revocation record with reason code.
- Renewal requires rerun of profile-appropriate conformance suites.

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Third-Party Operator Certification Program" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

FILE: layer4-implementation/Threat-Model-and-Control-Crosswalk.md
=================================================================
# UML_OS Threat Model and Control Crosswalk
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Security.ThreatModelCrosswalk_v1`  
**Purpose (1 sentence):** Formalize attacker model, trust boundaries, and control-to-evidence mapping for auditor-ready verification.  
**Spec Version:** `UML_OS.Security.ThreatModelCrosswalk_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) Threat Model Scope
- Assets: manifests, model state, trace, checkpoints, certificates, policy bundles, keys.
- Trust boundaries: client, daemon, storage backend, backend driver, attestation service, verifier.
- Attacker capabilities: tampering, replay, unauthorized access, partial storage corruption, network partition manipulation.

## 2) Control Mapping
- Each control entry MUST define:
  - `control_id`
  - `threat_ids`
  - `required_mitigations`
  - `evidence_fields`
  - `verification_procedure`

## 3) Mode-Specific Obligations
- `core`: baseline authz + evidence integrity.
- `enterprise`: adds operational governance controls.
- `regulated`: adds attestation/revocation/control-crosswalk completeness requirements.

## 4) Verification Output
- `control_crosswalk_report`
- `control_crosswalk_hash`

## 5) Related Contracts
- `docs/layer2-specs/Security-Compliance-Profile.md`
- `docs/layer2-specs/Execution-Certificate.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Threat Model and Control Crosswalk" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

## 6) Security Case Template Reference (Normative)
- `docs/layer4-implementation/Security-Case-Template.md` defines hash-addressed auditor package structure for this crosswalk.

FILE: layer4-implementation/Tooling-Suite.md
============================================
# UML_OS Tooling Suite Contract
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ToolingSuiteContract_v1`  
**Purpose (1 sentence):** Define deterministic tool interfaces, output schemas, and hash commitments for first-party UML_OS tooling.  
**Spec Version:** `UML_OS.Implementation.ToolingSuiteContract_v1` | 2026-02-21 | Authors: Olejar Damir  
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Implementation.ToolingSuiteContract_v1`
- **Purpose (1 sentence):** Deterministic tooling interoperability.
### 0.A Objective Semantics
- Tooling outputs are machine-verifiable and replayable.
### 0.B Reproducibility Contract
- Replayable given `(tool_id, tool_version, input_bundle_hash, output_schema_version, canonical_profile_id)`.
### 0.C Numeric Policy
- Numeric outputs use explicit scalar types; no locale-sensitive formatting.
### 0.D Ordering and Tie-Break Policy
- All object outputs are canonical CBOR maps; arrays with ordering semantics use deterministic sort keys defined per tool.
### 0.E Parallel, Concurrency, and Reduction Policy
- Parallel execution allowed; output merge is deterministic fail-dominant.
### 0.F Environment and Dependency Policy
- Canonical serialization profile is `CanonicalSerialization_v1`.
### 0.G Operator Manifest
- `UML_OS.Tooling.ManifestInit_v1`
- `UML_OS.Tooling.MigrationAssist_v1`
- `UML_OS.Tooling.ReplayShadowMonitor_v1`
- `UML_OS.Tooling.TraceSemanticDiff_v1`
- `UML_OS.Error.Emit_v1`
### 0.H Namespacing and Packaging
- Tool IDs: `umlos-init`, `umlos-migrate-assist`, `umlos-replay-monitor`, `umlos-trace-diff`.
### 0.I Outputs and Metric Schema
- Outputs: `(tooling_report, tooling_bundle_hash, tooling_verdict)`.
### 0.J Spec Lifecycle Governance
- Output schema changes are MAJOR-governed.
### 0.K Failure and Error Semantics
- Any schema violation in emitted tool output is deterministic failure.
### 0.L Input/Data Provenance
- Tool inputs and outputs must be content-addressed.

### 0.Z EQC Mandatory Declarations Addendum
- `stochastic_used: false`
- `seed_space: N/A`
- `prng_family: N/A`
- `rng_ownership: N/A`
- `numeric_kernel: N/A`
- `tolerances: N/A`
- `determinism_level: BITWISE`
- `error_trace: inherited from docs/layer1-foundation/Error-Codes.md`

---
## 2) Tool Output Schemas (Normative)
### I.A `umlos init`
- Output schema:
  - `manifest_path:string`
  - `manifest_hash:bytes32`
  - `validation_report_hash:bytes32`
  - `profile_id:enum(core|enterprise|regulated)`

### I.B `umlos migrate-assist`
- Output schema:
  - `input_artifact_hash:bytes32`
  - `migrated_artifact_hash:bytes32`
  - `migration_report_hash:bytes32`
  - `equivalence_verdict:enum(pass|fail)`

### I.C `umlos replay-monitor`
- Output schema:
  - `run_id:string`
  - `shadow_replay_trace_hash:bytes32`
  - `divergence_summary_hash:bytes32`
  - `monitor_verdict:enum(pass|fail)`

### I.D `umlos trace-diff`
- Output schema:
  - `lhs_trace_hash:bytes32`
  - `rhs_trace_hash:bytes32`
  - `first_divergence_path:string`
  - `determinism_class:enum(E0|E1|E2)`
  - `diff_report_hash:bytes32`

---
## 3) Hash Commitments (Normative)
- Tooling bundle identity:
  - `tooling_bundle_hash = SHA-256(CBOR_CANONICAL(["tooling_suite_v1", tool_outputs_map]))`
- Per-tool output identity:
  - `tool_output_hash = SHA-256(CBOR_CANONICAL(["tool_output_v1", tool_id, output_object]))`

---
## 4) Procedure
```text
1. Execute each enabled tooling component with canonical input artifacts.
2. Validate each emitted output object against its schema.
3. Compute per-tool output hashes and aggregate tooling_bundle_hash.
4. Emit deterministic tooling_report and final tooling_verdict.
```

---
## 6) Procedure
```text
1. Execute each enabled tooling component with canonical input artifacts.
2. Validate each emitted output object against its schema.
3. Compute per-tool output hashes and aggregate tooling_bundle_hash.
4. Emit deterministic tooling_report and final tooling_verdict.
```

FILE: layer4-implementation/Tooling-and-Automation-Suite.md
===========================================================
# UML_OS Tooling and Automation Suite
**EQC Compliance:** Merged single-file EQC v1.1 Option A.

**Algorithm:** `UML_OS.Implementation.ToolingSuite_v1`  
**Purpose (1 sentence):** Define a comprehensive tooling surface that makes UML_OS contracts directly executable, inspectable, and automatable.  
**Spec Version:** `UML_OS.Implementation.ToolingSuite_v1` | 2026-02-20 | Authors: Olejar Damir
**Normativity Legend:** `docs/layer1-foundation/Normativity-Legend.md`


---
## 1) Mandatory Tools
### I.A Declarative Manifest Generator
- CLI: `umlos init`
- Function:
  - interactively gather model/data/privacy/deployment inputs,
  - emit valid `manifest.yaml`,
  - run schema validation and show deterministic errors.
- Output identity:
  - `generated_manifest_hash = SHA-256(CBOR_CANONICAL(manifest))`.

### I.B Visual IR Explorer
- Tool: `umlos ir-explorer`
- Function:
  - load UML_Model_IR,
  - render graph topology,
  - display liveness intervals,
  - display TMMU slot assignments and reuse windows.

### I.C Automated Migration Assistant
- CLI: `umlos migrate`
- Function:
  - detect source schema versions,
  - invoke migration operators (`ManifestMigrate`, checkpoint/trace migrators),
  - verify migrated outputs against expected hashes and compatibility constraints.

### I.D Continuous Replay Monitor
- Service: `umlos replay-monitor`
- Function:
  - monitor production run metadata,
  - trigger deterministic shadow replays,
  - emit divergence alerts and first-divergence evidence bundles.

### I.E Semantic Trace Differ
- CLI: `umlos diff trace_a trace_b`
- Function:
  - find first divergence,
  - color/classify fields by determinism class (`E0/E1/E2`),
  - emit machine-readable root-cause summary.

---
## 2) Validation and Output Contracts
- Every tool must emit stable machine-readable output (`json`/`cbor`) and optional human rendering.
- Tool output hashes must be reproducible for identical inputs and environment manifests.

---
## 3) Related Contracts
- `docs/layer2-specs/Config-Schema.md`
- `docs/layer2-specs/ModelIR-Executor.md`
- `docs/layer2-specs/Replay-Determinism.md`
- `docs/layer4-implementation/Schema-Evolution-Playbook.md`

---
## 1) Header & Global Semantics
### 0.0 Identity
- **Algorithm:** `UML_OS.Structural.Addendum_v1`
- **Purpose (1 sentence):** Structural EQC compliance addendum for "UML_OS Tooling and Automation Suite" without altering existing semantics.
- **Spec Version:** `UML_OS.Structural.Addendum_v1` | 2026-02-20 | Authors: ML2ML
- **Domain / Problem Class:** Documentation governance and structural conformance.
### 0.Z EQC Mandatory Declarations Addendum
- This document inherits deterministic, numeric, and failure policies from its referenced normative contracts unless explicitly overridden.

---
## 6) Procedure
```text
1. Read and apply this document together with its referenced normative contracts.
2. Preserve deterministic ordering and evidence linkage requirements declared by those contracts.
3. Emit deterministic documentation compliance record for governance tracking.
```

