Glyphser Push-Button Codegen Milestones
=====================================

Goal
----
Move from strong prose specs to a verified, one-click code generation pipeline that produces deployable software deterministically.

Current Readiness (Today)
-------------------------
Status: not yet enough for full push-button production generation.

What is ready:
1. Strong multi-layer prose contract coverage.
2. Determinism and evidence semantics are largely defined.
3. Good foundation to begin Milestones 1-3 immediately.

What is missing:
1. Complete machine-readable schemas for every contract.
2. Fully generator-ready operator registry metadata.
3. Full ambiguity closure for all algorithmic and edge-case behavior.
4. Production-grade codegen templates and end-to-end generator pipeline.
5. Verified one-command build/test/deploy generation path.

Milestone 1: Machine-Readable Contract Layer
--------------------------------------------
1. Define canonical IDL/schema format for all contracts (types, enums, required/optional fields, defaults).
	- Scope:
		- Every contract in layers 1-4 that defines inputs, outputs, state, operators, trace records, checkpoints, and evidence hashes.
		- All referenced shared types (hashes, ids, enums, profile objects, manifests, records, operator payloads).
	- Required schema contents:
		- Field names, types, nullability, required/optional status.
		- Default values and defaulting rules.
		- Numeric constraints (ranges, precision, tolerance defaults).
		- String/bytes constraints (encoding, length, normalization, format).
		- Enum domains and unknown-value handling.
		- Ordering/canonicalization rules (sorting keys, tie-breakers, stable iteration order).
		- Hash preimage definitions (exact canonical object used for each hash).
		- Validation errors mapped to concrete error codes.
		- Version tag and compatibility policy (MAJOR/MINOR/PATCH behavior).
	- Execution sub-steps:
		- Choose one authoritative machine-readable format (or tightly governed pair) and freeze it.
		- Generate a schema file for each existing Markdown contract.
		- Add cross-file references using stable schema IDs/digests.
		- Build a linter that detects prose-schema drift.
		- Add CI gate: fail on missing schema, unresolved reference, or digest mismatch.
	- Definition of done:
		- 100% contract coverage by machine-readable schemas.
		- Every operator input/output and record type resolves to a schema ID.
		- No undocumented fields or implicit defaults remain in prose-only form.
		- CI passes schema completeness, reference integrity, and hash determinism checks.
		- A code generator can consume schemas without reading prose for structural typing decisions.
	- First-task execution plan (actionable):
		- Phase 1: Format decision
			- Select one canonical schema format (or a governed pair) and freeze it in writing.
			- Define canonical encoding and digest rule for schema artifacts.
			- Deliverable: `Schema-Format-Decision` note with examples.
		- Phase 2: Meta-schema
			- Create a meta-schema describing required fields for every contract schema artifact.
			- Include typing rules, nullability, defaults, constraints, and version fields.
			- Deliverable: versioned meta-schema file + validator.
		- Phase 3: Conventions
			- Define naming conventions for schema IDs, field paths, enum names, and operator I/O references.
			- Define cross-file reference format and unresolved-reference failure behavior.
			- Deliverable: conventions document with canonical examples.
		- Phase 4: Pilot conversion
			- Convert 2-3 representative contracts (one per layer) to validate the format.
			- Compare converted schemas against prose to confirm no information loss.
			- Deliverable: pilot schema artifacts + parity report.
		- Phase 5: CI gate bootstrap
			- Add initial CI checks: schema parse, meta-schema validation, and stable hash computation.
			- Fail on missing required metadata in schema artifacts.
			- Deliverable: green CI on pilot set with strict failure conditions.
	- Acceptance criteria for first task:
		- Canonical format is frozen and documented.
		- Meta-schema validates pilot artifacts without exceptions.
		- Pilot artifacts preserve all contract fields and constraints from source docs.
		- CI gate enforces format validity and deterministic schema hashing.
	- DONE (so far):
		- Format decision frozen in `schemas/SCHEMA_FORMAT_DECISION.txt`.
		- Meta-schema created in `schemas/contract_schema_meta.json`.
		- Conventions documented in `schemas/SCHEMA_CONVENTIONS.txt`.
		- Pilot artifacts created:
			- `schemas/pilot/l1_error_codes.schema.json`
			- `schemas/pilot/l2_config_schema.schema.json`
			- `schemas/pilot/l3_test_plan.schema.json`
		- Bootstrap schema gate implemented and executed:
			- `tools/schema_gate.py`
			- Result: `PASS: validated 3 schema artifacts`.
		- Pilot coverage expanded to all Layer1 contracts:
			- Added 9 additional Layer1 pilot schema artifacts under `schemas/pilot/`.
			- Total validated pilot artifacts: 12.
		- Cross-reference gate hardened:
			- `tools/schema_gate.py` now verifies each operator ID in a pilot artifact appears in its `source_doc`.
			- `tools/schema_gate.py` now also verifies declared outputs/procedure return names are present in source docs (prose drift check).
			- Result: `PASS: validated 12 schema artifacts`.
		- CI integration completed:
			- Added `.github/workflows/schema-gate.yml` to run schema gate on schema/docs/workflow changes.
		- First-task execution plan status: COMPLETE.
2. Convert every Markdown contract into machine-readable artifacts (CBOR schema/JSON schema/IDL).
3. Add schema validation CI gate: no prose-schema drift allowed.
4. Version all schemas with strict compatibility rules (MAJOR/MINOR/PATCH).

Deliverable:
- Complete machine-readable schema set with deterministic validation.


Milestone 2: Executable Operator Registry
-----------------------------------------
1. Expand operator registry entries to include full signatures, purity, side effects, dependencies, and error codes.
2. Add explicit determinism metadata per operator (E0/E1 behavior, tolerances, ordering).
3. Link each operator to canonical input/output schema digests.
4. Add CI rule: every referenced operator must resolve in registry and pass schema checks.

Deliverable:
- Generator-ready operator registry artifact.


Milestone 3: Deterministic Algorithm Closure
--------------------------------------------
1. Resolve all remaining optional/ambiguous branches in algorithms.
2. Define canonical behavior for edge cases, tie-breaks, and failure paths.
3. Provide reference pseudocode-to-spec mapping for each critical operator.
4. Freeze numeric policies (tolerances, NaN/Inf handling, quantile method, rounding).

Deliverable:
- Fully unambiguous execution semantics for codegen.


Milestone 4: Test Case and Vector Definition (TDD First)
---------------------------------------------------------
1. Define full deterministic test inventory before code generation:
	- unit tests per operator contract,
	- integration matrix cases,
	- replay/checkpoint cases,
	- evidence/hash-link integrity cases,
	- failure-injection and storage-recovery cases.
2. Freeze canonical test vectors and expected outputs/hashes.
3. Define red/green criteria per test class and equivalence profile (E0/E1).
4. Add CI checks that validate test completeness against contract/operator inventory.

Deliverable:
- Frozen contract-driven test suite and vector catalog that serve as the executable spec.


Milestone 5: Conformance and Gate Pipeline (Before Codegen)
------------------------------------------------------------
1. Implement mandatory verification pipeline over tests/spec artifacts:
	- schema conformance,
	- interface/signature conformance,
	- replay determinism,
	- checkpoint/restore,
	- evidence integrity.
2. Enforce registry parity and hash-chain integrity checks in CI.
3. Enforce release-gate policies over test evidence.
4. Block implementation/codegen milestones until this pipeline is green on reference fixtures.

Deliverable:
- Policy-enforced CI proving tests/specs are complete and deterministic before implementation.


Milestone 6: Reference Implementations for Critical Operators
--------------------------------------------------------------
1. Implement minimal reference operators/stubs to execute the frozen tests.
2. Prioritize high-risk deterministic paths first.
3. Verify outputs against golden vectors under required profiles.
4. Lock canonical behavior for sensitive operators.

Deliverable:
- Verified reference baseline that passes contract-driven tests.


Milestone 7: Codegen Target Architecture
----------------------------------------
1. Decide primary generation targets (language, runtime, storage, transport).
2. Define generated project layout (modules, package boundaries, config loading).
3. Define runtime integration contracts (logging, tracing, metrics, authz, persistence).
4. Standardize generated build/test scripts and dependency lock policy.

Deliverable:
- Approved target architecture profile for generation.


Milestone 8: Generator + Templates
----------------------------------
1. Build generator pipeline that consumes schemas + operator registry.
2. Implement templates for:
   - data models
   - operator interfaces/stubs
   - validation layers
   - error handling
   - trace/checkpoint/WAL bindings
3. Require generated code to run the already-frozen test suite unchanged.
4. Add idempotent regeneration workflow (safe re-run without manual edits loss).

Deliverable:
- End-to-end code generator producing compilable projects validated by pre-defined tests.


Milestone 9: Deployment-Ready Generation
----------------------------------------
1. Generate deployment artifacts (container, runtime configs, policy bindings).
2. Generate environment-specific manifests with deterministic defaults.
3. Add migration and rollback generation for schema/operator changes.
4. Validate production profile (managed/confidential/regulated) end-to-end.

Deliverable:
- One-command generation + deployable artifact bundle.


Milestone 10: Push-Button Production Readiness
----------------------------------------------
Exit criteria:
1. One command generates code, tests, manifests, and release evidence.
2. Generated system passes all conformance and release gates without manual patching.
3. Replay determinism and checkpoint restore pass in target environments.
4. Documentation, registry, and generated code remain drift-free under CI.

Final Deliverable:
- Trusted push-button generation workflow for Glyphser implementations.
